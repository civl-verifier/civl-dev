// Boogie program verifier version 2.4.1.10503, Copyright (c) 2003-2014, Microsoft.
// Command Line Options: /noWitnessInference /noCommutativityTriggers /noVerify /CivlDesugaredFile:desugared_files/verified-ft.desugared.bpl ../verified-ft.bpl

type Tid = int;

const unique nil: Tid;

function {:inline} ValidTid(tid: Tid) : bool
{
  tid != nil && tid >= 0
}

type {:datatype} Epoch;

function {:constructor} epoch(tid: Tid, clock: int) : Epoch;

const unique SHARED: Epoch;

function {:inline} EpochInc(e: Epoch) : Epoch
{
  epoch(tid#epoch(e), clock#epoch(e) + 1)
}

function {:inline} EpochIsShared(e: Epoch) : bool
{
  e == SHARED
}

function {:inline} EpochLeq(e1: Epoch, e2: Epoch) : bool
{
  tid#epoch(e1) == tid#epoch(e2) && clock#epoch(e1) <= clock#epoch(e2)
}

function {:inline} max(a: int, b: int) : int
{
  (if a < b then b else a)
}

function {:inline} EpochMax(e1: Epoch, e2: Epoch) : Epoch
{
  epoch(tid#epoch(e1), max(clock#epoch(e1), clock#epoch(e2)))
}

function {:inline} EpochInit(tid: Tid) : Epoch
{
  epoch(tid, 0)
}

type VC = [Tid]Epoch;

function {:inline} VCArrayLen(vc: VC) : int
{
  clock#epoch(vc[-1])
}

function {:inline} VCArraySetLen(vc: VC, n: int) : VC
{
  vc[-1 := epoch(-1, n)]
}

function {:inline} VCArrayGet(vc: VC, i: int) : Epoch
{
  vc[i]
}

type Lock;

type Var;

type {:datatype} Shadowable;

function {:constructor} ShadowableTid(tid: Tid) : Shadowable;

function {:constructor} ShadowableLock(l: Lock) : Shadowable;

function {:constructor} ShadowableVar(x: Var) : Shadowable;

var shadow.VC: [Shadowable]VC;

var shadow.Lock: [Shadowable]Tid;

var sx.W: [Var]Epoch;

var sx.R: [Var]Epoch;

type ThreadStatus = int;

function {:inline} UNUSED() : ThreadStatus
{
  0
}

function {:inline} NEW() : ThreadStatus
{
  1
}

function {:inline} RUNNING() : ThreadStatus
{
  2
}

function {:inline} STOPPED() : ThreadStatus
{
  3
}

var thread.State: [Tid]ThreadStatus;

var thread.ForkedBy: [Tid]Tid;

var thread.HasJoined: [Tid,Tid]bool;

const unique EMPTY_MAP: [Tid]Epoch;

axiom (forall i: Tid :: EMPTY_MAP[i] == EpochInit(i));

function {:inline} VC.bottom() : VC
{
  VCArraySetLen(EMPTY_MAP, 0)
}

function {:inline false} VarsRepOk(w: [Var]Epoch, r: [Var]Epoch) : bool;

axiom (forall w: [Var]Epoch, r: [Var]Epoch :: 
  {:inline false} { VarsRepOk(w, r): bool } 
  VarsRepOk(w, r): bool
     <==> (forall v: Var :: ValidTid(tid#epoch(w[v])))
       && (forall v: Var :: 
        r[v] == SHARED || (tid#epoch(r[v]) >= 0 && tid#epoch(r[v]) != nil)));

function {:inline false} VCRepOk(vc: VC) : bool;

axiom (forall vc: VC :: 
  {:inline false} { VCRepOk(vc): bool } 
  VCRepOk(vc): bool
     <==> VCArrayLen(vc) >= 0
       && (forall j: int :: 
        { vc[j] } 
        0 <= j && j < VCArrayLen(vc) ==> clock#epoch(vc[j]) >= 0)
       && (forall j: int :: 
        { vc[j] } 
        0 <= j && j < VCArrayLen(vc) ==> tid#epoch(vc[j]) == j)
       && (forall j: int :: VCArrayLen(vc) <= j ==> vc[j] == EpochInit(j)));

function {:inline} VCsRepOk(vcs: [Shadowable]VC) : bool
{
  (forall s: Shadowable :: VCRepOk(vcs[s]))
}

function {:inline} FTRepOk(vcs: [Shadowable]VC, w: [Var]Epoch, r: [Var]Epoch) : bool
{
  VCsRepOk(vcs) && VarsRepOk(w, r)
}

function {:inline} LocksPreserved(tid: Tid, oldLocks: [Shadowable]Tid, locks: [Shadowable]Tid) : bool
{
  (forall v: Shadowable :: oldLocks[v] == tid ==> locks[v] == tid)
}

function {:inline} SharedInvPreserved(oldR: [Var]Epoch, r: [Var]Epoch) : bool
{
  (forall x: Var :: oldR[x] == SHARED ==> r[x] == SHARED)
}

function {:inline} FTPreserved(tid: Tid, 
    oldLocks: [Shadowable]Tid, 
    oldVcs: [Shadowable]VC, 
    oldW: [Var]Epoch, 
    oldR: [Var]Epoch, 
    locks: [Shadowable]Tid, 
    vcs: [Shadowable]VC, 
    w: [Var]Epoch, 
    r: [Var]Epoch)
   : bool
{
  LocksPreserved(tid, oldLocks, locks)
     && SharedInvPreserved(oldR, r)
     && (forall s: Shadowable :: oldLocks[s] == tid ==> vcs[s] == oldVcs[s])
     && (forall x: Var :: oldLocks[ShadowableVar(x)] == tid ==> r[x] == oldR[x])
     && (forall x: Var :: oldLocks[ShadowableVar(x)] == tid ==> w[x] == oldW[x])
}

procedure GhostRead() returns (lock: [Shadowable]Tid, data: [Shadowable][Tid]Epoch);
  ensures lock == shadow.Lock;
  ensures data == shadow.VC;



implementation GhostRead() returns (lock: [Shadowable]Tid, data: [Shadowable][Tid]Epoch)
{
  /*** structured program:
    lock := shadow.Lock;
    data := shadow.VC;
  **** end structured program */

  anon0:
    lock := shadow.Lock;
    data := shadow.VC;
    return;
}



function {:builtin "MapConst"} TidMapConstBool(bool) : [Tid]bool;

function {:inline} TidCollector(x: Tid) : [Tid]bool
{
  TidMapConstBool(false)[x := true]
}

function {:inline false} f(i: int) : bool;

axiom (forall i: int :: {:inline false} { f(i): bool } f(i): bool <==> true);










type {:datatype} PendingAsync;

var pendingAsyncMultiset: [PendingAsync]int;

function {:constructor} PendingAsync_AcquireVarLock(tid: Tid, x: Var) : PendingAsync;

procedure {:inline 1} AddPendingAsync_AcquireVarLock(tid: Tid, x: Var);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_AcquireVarLock(tid: Tid, x: Var)
{

  L:
    pendingAsyncMultiset[PendingAsync_AcquireVarLock(tid, x)] := pendingAsyncMultiset[PendingAsync_AcquireVarLock(tid, x)] + 1;
    return;
}



function {:constructor} PendingAsync_ReleaseVarLock(tid: Tid, x: Var) : PendingAsync;

procedure {:inline 1} AddPendingAsync_ReleaseVarLock(tid: Tid, x: Var);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_ReleaseVarLock(tid: Tid, x: Var)
{

  L:
    pendingAsyncMultiset[PendingAsync_ReleaseVarLock(tid, x)] := pendingAsyncMultiset[PendingAsync_ReleaseVarLock(tid, x)] + 1;
    return;
}



function {:constructor} PendingAsync_ThreadStateGetE(tid: Tid) : PendingAsync;

procedure {:inline 1} AddPendingAsync_ThreadStateGetE(tid: Tid);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_ThreadStateGetE(tid: Tid)
{

  L:
    pendingAsyncMultiset[PendingAsync_ThreadStateGetE(tid)] := pendingAsyncMultiset[PendingAsync_ThreadStateGetE(tid)] + 1;
    return;
}



function {:constructor} PendingAsync_VarStateSetW(tid: Tid, x: Var, e: Epoch) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VarStateSetW(tid: Tid, x: Var, e: Epoch);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VarStateSetW(tid: Tid, x: Var, e: Epoch)
{

  L:
    pendingAsyncMultiset[PendingAsync_VarStateSetW(tid, x, e)] := pendingAsyncMultiset[PendingAsync_VarStateSetW(tid, x, e)] + 1;
    return;
}



function {:constructor} PendingAsync_VarStateGetW(tid: Tid, x: Var) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VarStateGetW(tid: Tid, x: Var);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VarStateGetW(tid: Tid, x: Var)
{

  L:
    pendingAsyncMultiset[PendingAsync_VarStateGetW(tid, x)] := pendingAsyncMultiset[PendingAsync_VarStateGetW(tid, x)] + 1;
    return;
}



function {:constructor} PendingAsync_VarStateGetWNoLock(tid: Tid, x: Var) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VarStateGetWNoLock(tid: Tid, x: Var);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VarStateGetWNoLock(tid: Tid, x: Var)
{

  L:
    pendingAsyncMultiset[PendingAsync_VarStateGetWNoLock(tid, x)] := pendingAsyncMultiset[PendingAsync_VarStateGetWNoLock(tid, x)] + 1;
    return;
}



function {:constructor} PendingAsync_VarStateSetR(tid: Tid, x: Var, e: Epoch) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VarStateSetR(tid: Tid, x: Var, e: Epoch);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VarStateSetR(tid: Tid, x: Var, e: Epoch)
{

  L:
    pendingAsyncMultiset[PendingAsync_VarStateSetR(tid, x, e)] := pendingAsyncMultiset[PendingAsync_VarStateSetR(tid, x, e)] + 1;
    return;
}



function {:constructor} PendingAsync_VarStateGetRNoLock(tid: Tid, x: Var) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VarStateGetRNoLock(tid: Tid, x: Var);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VarStateGetRNoLock(tid: Tid, x: Var)
{

  L:
    pendingAsyncMultiset[PendingAsync_VarStateGetRNoLock(tid, x)] := pendingAsyncMultiset[PendingAsync_VarStateGetRNoLock(tid, x)] + 1;
    return;
}



function {:constructor} PendingAsync_VarStateGetR(tid: Tid, x: Var) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VarStateGetR(tid: Tid, x: Var);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VarStateGetR(tid: Tid, x: Var)
{

  L:
    pendingAsyncMultiset[PendingAsync_VarStateGetR(tid, x)] := pendingAsyncMultiset[PendingAsync_VarStateGetR(tid, x)] + 1;
    return;
}



function {:constructor} PendingAsync_VarStateGetRShared(tid: Tid, x: Var) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VarStateGetRShared(tid: Tid, x: Var);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VarStateGetRShared(tid: Tid, x: Var)
{

  L:
    pendingAsyncMultiset[PendingAsync_VarStateGetRShared(tid, x)] := pendingAsyncMultiset[PendingAsync_VarStateGetRShared(tid, x)] + 1;
    return;
}



function {:constructor} PendingAsync_VCGetSize(tid: Tid, r: Shadowable) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VCGetSize(tid: Tid, r: Shadowable);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VCGetSize(tid: Tid, r: Shadowable)
{

  L:
    pendingAsyncMultiset[PendingAsync_VCGetSize(tid, r)] := pendingAsyncMultiset[PendingAsync_VCGetSize(tid, r)] + 1;
    return;
}



function {:constructor} PendingAsync_VCGetElem(tid: Tid, r: Shadowable, i: int) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VCGetElem(tid: Tid, r: Shadowable, i: int);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VCGetElem(tid: Tid, r: Shadowable, i: int)
{

  L:
    pendingAsyncMultiset[PendingAsync_VCGetElem(tid, r, i)] := pendingAsyncMultiset[PendingAsync_VCGetElem(tid, r, i)] + 1;
    return;
}



function {:constructor} PendingAsync_VCGetElemShared(tid: Tid, x: Var) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VCGetElemShared(tid: Tid, x: Var);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VCGetElemShared(tid: Tid, x: Var)
{

  L:
    pendingAsyncMultiset[PendingAsync_VCGetElemShared(tid, x)] := pendingAsyncMultiset[PendingAsync_VCGetElemShared(tid, x)] + 1;
    return;
}



function {:constructor} PendingAsync_VCSetElemShared(tid: Tid, x: Var, e: Epoch) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VCSetElemShared(tid: Tid, x: Var, e: Epoch);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VCSetElemShared(tid: Tid, x: Var, e: Epoch)
{

  L:
    pendingAsyncMultiset[PendingAsync_VCSetElemShared(tid, x, e)] := pendingAsyncMultiset[PendingAsync_VCSetElemShared(tid, x, e)] + 1;
    return;
}



function {:constructor} PendingAsync_VCSetElem(tid: Tid, r: Shadowable, i: int, e: Epoch) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VCSetElem(tid: Tid, r: Shadowable, i: int, e: Epoch);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VCSetElem(tid: Tid, r: Shadowable, i: int, e: Epoch)
{

  L:
    pendingAsyncMultiset[PendingAsync_VCSetElem(tid, r, i, e)] := pendingAsyncMultiset[PendingAsync_VCSetElem(tid, r, i, e)] + 1;
    return;
}



function {:constructor} PendingAsync_VCInit(tid: Tid, r: Shadowable) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VCInit(tid: Tid, r: Shadowable);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VCInit(tid: Tid, r: Shadowable)
{

  L:
    pendingAsyncMultiset[PendingAsync_VCInit(tid, r)] := pendingAsyncMultiset[PendingAsync_VCInit(tid, r)] + 1;
    return;
}



function {:constructor} PendingAsync_VC.Leq(tid: Tid, v1: Shadowable, v2: Shadowable) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VC.Leq(tid: Tid, v1: Shadowable, v2: Shadowable);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VC.Leq(tid: Tid, v1: Shadowable, v2: Shadowable)
{

  L:
    pendingAsyncMultiset[PendingAsync_VC.Leq(tid, v1, v2)] := pendingAsyncMultiset[PendingAsync_VC.Leq(tid, v1, v2)] + 1;
    return;
}



function {:constructor} PendingAsync_VC.Copy(tid: Tid, v1: Shadowable, v2: Shadowable) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VC.Copy(tid: Tid, v1: Shadowable, v2: Shadowable);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VC.Copy(tid: Tid, v1: Shadowable, v2: Shadowable)
{

  L:
    pendingAsyncMultiset[PendingAsync_VC.Copy(tid, v1, v2)] := pendingAsyncMultiset[PendingAsync_VC.Copy(tid, v1, v2)] + 1;
    return;
}



function {:constructor} PendingAsync_VC.Join(tid: Tid, v1: Shadowable, v2: Shadowable) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VC.Join(tid: Tid, v1: Shadowable, v2: Shadowable);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VC.Join(tid: Tid, v1: Shadowable, v2: Shadowable)
{

  L:
    pendingAsyncMultiset[PendingAsync_VC.Join(tid, v1, v2)] := pendingAsyncMultiset[PendingAsync_VC.Join(tid, v1, v2)] + 1;
    return;
}



function {:constructor} PendingAsync_VC.Inc(tid: Tid, v: Shadowable, i: int) : PendingAsync;

procedure {:inline 1} AddPendingAsync_VC.Inc(tid: Tid, v: Shadowable, i: int);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_VC.Inc(tid: Tid, v: Shadowable, i: int)
{

  L:
    pendingAsyncMultiset[PendingAsync_VC.Inc(tid, v, i)] := pendingAsyncMultiset[PendingAsync_VC.Inc(tid, v, i)] + 1;
    return;
}



function {:constructor} PendingAsync_Fork(tid: Tid, uid: Tid) : PendingAsync;

procedure {:inline 1} AddPendingAsync_Fork(tid: Tid, uid: Tid);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_Fork(tid: Tid, uid: Tid)
{

  L:
    pendingAsyncMultiset[PendingAsync_Fork(tid, uid)] := pendingAsyncMultiset[PendingAsync_Fork(tid, uid)] + 1;
    return;
}



function {:constructor} PendingAsync_Join(tid: Tid, uid: Tid) : PendingAsync;

procedure {:inline 1} AddPendingAsync_Join(tid: Tid, uid: Tid);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_Join(tid: Tid, uid: Tid)
{

  L:
    pendingAsyncMultiset[PendingAsync_Join(tid, uid)] := pendingAsyncMultiset[PendingAsync_Join(tid, uid)] + 1;
    return;
}



function {:constructor} PendingAsync_Acquire(tid: Tid, l: Lock) : PendingAsync;

procedure {:inline 1} AddPendingAsync_Acquire(tid: Tid, l: Lock);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_Acquire(tid: Tid, l: Lock)
{

  L:
    pendingAsyncMultiset[PendingAsync_Acquire(tid, l)] := pendingAsyncMultiset[PendingAsync_Acquire(tid, l)] + 1;
    return;
}



function {:constructor} PendingAsync_Release(tid: Tid, l: Lock) : PendingAsync;

procedure {:inline 1} AddPendingAsync_Release(tid: Tid, l: Lock);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_Release(tid: Tid, l: Lock)
{

  L:
    pendingAsyncMultiset[PendingAsync_Release(tid, l)] := pendingAsyncMultiset[PendingAsync_Release(tid, l)] + 1;
    return;
}



function {:constructor} PendingAsync_Write(tid: Tid, x: Var) : PendingAsync;

procedure {:inline 1} AddPendingAsync_Write(tid: Tid, x: Var);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_Write(tid: Tid, x: Var)
{

  L:
    pendingAsyncMultiset[PendingAsync_Write(tid, x)] := pendingAsyncMultiset[PendingAsync_Write(tid, x)] + 1;
    return;
}



function {:constructor} PendingAsync_Read(tid: Tid, x: Var) : PendingAsync;

procedure {:inline 1} AddPendingAsync_Read(tid: Tid, x: Var);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_Read(tid: Tid, x: Var)
{

  L:
    pendingAsyncMultiset[PendingAsync_Read(tid, x)] := pendingAsyncMultiset[PendingAsync_Read(tid, x)] + 1;
    return;
}



function {:constructor} PendingAsync_ReleaseJoinLock(tid: Tid, uid: Tid) : PendingAsync;

procedure {:inline 1} AddPendingAsync_ReleaseJoinLock(tid: Tid, uid: Tid);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_ReleaseJoinLock(tid: Tid, uid: Tid)
{

  L:
    pendingAsyncMultiset[PendingAsync_ReleaseJoinLock(tid, uid)] := pendingAsyncMultiset[PendingAsync_ReleaseJoinLock(tid, uid)] + 1;
    return;
}



function {:constructor} PendingAsync_ChooseThreadToJoin(tid: Tid) : PendingAsync;

procedure {:inline 1} AddPendingAsync_ChooseThreadToJoin(tid: Tid);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_ChooseThreadToJoin(tid: Tid)
{

  L:
    pendingAsyncMultiset[PendingAsync_ChooseThreadToJoin(tid)] := pendingAsyncMultiset[PendingAsync_ChooseThreadToJoin(tid)] + 1;
    return;
}



function {:constructor} PendingAsync_AllocTid(tid: Tid) : PendingAsync;

procedure {:inline 1} AddPendingAsync_AllocTid(tid: Tid);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_AllocTid(tid: Tid)
{

  L:
    pendingAsyncMultiset[PendingAsync_AllocTid(tid)] := pendingAsyncMultiset[PendingAsync_AllocTid(tid)] + 1;
    return;
}



function {:constructor} PendingAsync_StartThread(tid: Tid, uid: Tid) : PendingAsync;

procedure {:inline 1} AddPendingAsync_StartThread(tid: Tid, uid: Tid);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_StartThread(tid: Tid, uid: Tid)
{

  L:
    pendingAsyncMultiset[PendingAsync_StartThread(tid, uid)] := pendingAsyncMultiset[PendingAsync_StartThread(tid, uid)] + 1;
    return;
}



function {:constructor} PendingAsync_ChooseLockToAcquire(tid: Tid) : PendingAsync;

procedure {:inline 1} AddPendingAsync_ChooseLockToAcquire(tid: Tid);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_ChooseLockToAcquire(tid: Tid)
{

  L:
    pendingAsyncMultiset[PendingAsync_ChooseLockToAcquire(tid)] := pendingAsyncMultiset[PendingAsync_ChooseLockToAcquire(tid)] + 1;
    return;
}



function {:constructor} PendingAsync_ChooseLockToRelease(tid: Tid) : PendingAsync;

procedure {:inline 1} AddPendingAsync_ChooseLockToRelease(tid: Tid);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_ChooseLockToRelease(tid: Tid)
{

  L:
    pendingAsyncMultiset[PendingAsync_ChooseLockToRelease(tid)] := pendingAsyncMultiset[PendingAsync_ChooseLockToRelease(tid)] + 1;
    return;
}



function {:constructor} PendingAsync_ReleaseChosenLock(tid: Tid, l: Lock) : PendingAsync;

procedure {:inline 1} AddPendingAsync_ReleaseChosenLock(tid: Tid, l: Lock);
  modifies pendingAsyncMultiset;



implementation {:inline 1} AddPendingAsync_ReleaseChosenLock(tid: Tid, l: Lock)
{

  L:
    pendingAsyncMultiset[PendingAsync_ReleaseChosenLock(tid, l)] := pendingAsyncMultiset[PendingAsync_ReleaseChosenLock(tid, l)] + 1;
    return;
}



procedure {:inline 1} AtomicAcquireVarLock_1(tid: Tid, x: Var);
  modifies shadow.Lock;



procedure {:inline 1} AtomicReleaseVarLock_1(tid: Tid, x: Var);
  modifies shadow.Lock;



procedure {:inline 1} AtomicThreadStateGetE_1(tid: Tid) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateSetW_1(tid: Tid, x: Var, e: Epoch);
  modifies sx.W;



procedure {:inline 1} AtomicVarStateGetW_1(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetWNoLock_1(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateSetR_1(tid: Tid, x: Var, e: Epoch);
  modifies sx.R;



procedure {:inline 1} AtomicVarStateGetRNoLock_1(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetR_1(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetRShared_1(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVCGetSize_1(tid: Tid, r: Shadowable) returns (i: int);



procedure {:inline 1} AtomicVCGetElem_1(tid: Tid, r: Shadowable, i: int) returns (e: Epoch);



procedure {:inline 1} AtomicVCGetElemShared_1(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVCSetElemShared_1(tid: Tid, x: Var, e: Epoch);
  modifies shadow.VC;



procedure {:inline 1} AtomicVCSetElem_1(tid: Tid, r: Shadowable, i: int, e: Epoch);
  modifies shadow.VC;



procedure {:inline 1} AtomicVCInit_1(tid: Tid, r: Shadowable);
  modifies shadow.VC;



procedure {:inline 1} AtomicReleaseJoinLock_1(tid: Tid, uid: Tid);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseThreadToJoin_1(tid: Tid) returns (uid: Tid);
  modifies shadow.Lock, thread.HasJoined;



procedure {:inline 1} AtomicAllocTid_1(tid: Tid) returns (uid: Tid);
  modifies thread.State, thread.ForkedBy, shadow.Lock;



procedure {:inline 1} AtomicStartThread_1(tid: Tid, uid: Tid);
  modifies thread.State, shadow.Lock;



procedure {:inline 1} AtomicChooseLockToAcquire_1(tid: Tid) returns (l: Lock);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseLockToRelease_1(tid: Tid) returns (l: Lock);



procedure {:inline 1} AtomicReleaseChosenLock_1(tid: Tid, l: Lock);
  modifies shadow.Lock;



implementation {:inline 1} AtomicAcquireVarLock_1(tid: Tid, x: Var)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == nil;
    shadow.Lock[ShadowableVar(x)] := tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableVar(x)] == nil;
    shadow.Lock[ShadowableVar(x)] := tid;
    return;
}



implementation {:inline 1} AtomicReleaseVarLock_1(tid: Tid, x: Var)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    shadow.Lock[ShadowableVar(x)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableVar(x)] := nil;
    return;
}



implementation {:inline 1} AtomicThreadStateGetE_1(tid: Tid) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    e := shadow.VC[ShadowableTid(tid)][tid];
  **** end structured program */

  anon0:
    e := shadow.VC[ShadowableTid(tid)][tid];
    return;
}



implementation {:inline 1} AtomicVarStateSetW_1(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    sx.W[x] := e;
  **** end structured program */

  anon0:
    sx.W[x] := e;
    return;
}



implementation {:inline 1} AtomicVarStateGetW_1(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    e := sx.W[x];
  **** end structured program */

  anon0:
    e := sx.W[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetWNoLock_1(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    e := sx.W[x];
  **** end structured program */

  anon0:
    e := sx.W[x];
    return;
}



implementation {:inline 1} AtomicVarStateSetR_1(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    assert sx.R[x] != SHARED;
    sx.R[x] := e;
  **** end structured program */

  anon0:
    sx.R[x] := e;
    return;
}



implementation {:inline 1} AtomicVarStateGetRNoLock_1(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    e := sx.R[x];
  **** end structured program */

  anon0:
    e := sx.R[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetR_1(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    e := sx.R[x];
  **** end structured program */

  anon0:
    e := sx.R[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetRShared_1(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assume sx.R[x] == SHARED;
    e := SHARED;
  **** end structured program */

  anon0:
    assume sx.R[x] == SHARED;
    e := SHARED;
    return;
}



implementation {:inline 1} AtomicVCGetSize_1(tid: Tid, r: Shadowable) returns (i: int)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[r] == tid;
    i := VCArrayLen(shadow.VC[r]);
  **** end structured program */

  anon0:
    i := VCArrayLen(shadow.VC[r]);
    return;
}



implementation {:inline 1} AtomicVCGetElem_1(tid: Tid, r: Shadowable, i: int) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[r] == tid;
    e := VCArrayGet(shadow.VC[r], i);
  **** end structured program */

  anon0:
    e := VCArrayGet(shadow.VC[r], i);
    return;
}



implementation {:inline 1} AtomicVCGetElemShared_1(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert sx.R[x] == SHARED;
    assert ValidTid(tid);
    e := VCArrayGet(shadow.VC[ShadowableVar(x)], tid);
  **** end structured program */

  anon0:
    e := VCArrayGet(shadow.VC[ShadowableVar(x)], tid);
    return;
}



implementation {:inline 1} AtomicVCSetElemShared_1(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert sx.R[x] == SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    shadow.VC[ShadowableVar(x)][tid] := e;
    shadow.VC[ShadowableVar(x)] := VCArraySetLen(shadow.VC[ShadowableVar(x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(x)]), tid + 1));
  **** end structured program */

  anon0:
    shadow.VC[ShadowableVar(x)][tid] := e;
    shadow.VC[ShadowableVar(x)] := VCArraySetLen(shadow.VC[ShadowableVar(x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(x)]), tid + 1));
    return;
}



implementation {:inline 1} AtomicVCSetElem_1(tid: Tid, r: Shadowable, i: int, e: Epoch)
{
  /*** structured program:
    assert is#ShadowableVar(r) ==> sx.R[x#ShadowableVar(r)] != SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[r] == tid;
    shadow.VC[r][i] := e;
    shadow.VC[r] := VCArraySetLen(shadow.VC[r], max(VCArrayLen(shadow.VC[r]), i + 1));
  **** end structured program */

  anon0:
    shadow.VC[r][i] := e;
    shadow.VC[r] := VCArraySetLen(shadow.VC[r], max(VCArrayLen(shadow.VC[r]), i + 1));
    return;
}



implementation {:inline 1} AtomicVCInit_1(tid: Tid, r: Shadowable)
{
  /*** structured program:
    assert ValidTid(tid);
    assert is#ShadowableVar(r) ==> sx.R[x#ShadowableVar(r)] != SHARED;
    assert shadow.Lock[r] == tid;
    shadow.VC[r] := VC.bottom();
  **** end structured program */

  anon0:
    shadow.VC[r] := VC.bottom();
    return;
}



implementation {:inline 1} AtomicReleaseJoinLock_1(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    shadow.Lock[ShadowableTid(uid)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableTid(uid)] := nil;
    return;
}



implementation {:inline 1} AtomicChooseThreadToJoin_1(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
    return;
}



implementation {:inline 1} AtomicAllocTid_1(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
    return;
}



implementation {:inline 1} AtomicStartThread_1(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert thread.State[uid] == NEW();
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
  **** end structured program */

  anon0:
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
    return;
}



implementation {:inline 1} AtomicChooseLockToAcquire_1(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
    return;
}



implementation {:inline 1} AtomicChooseLockToRelease_1(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == tid;
    return;
}



implementation {:inline 1} AtomicReleaseChosenLock_1(tid: Tid, l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableLock(l)] == tid;
    shadow.Lock[ShadowableLock(l)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableLock(l)] := nil;
    return;
}



procedure {:inline 1} AtomicAcquireVarLock_10(tid: Tid, x: Var);
  modifies shadow.Lock;



procedure {:inline 1} AtomicReleaseVarLock_10(tid: Tid, x: Var);
  modifies shadow.Lock;



procedure {:inline 1} AtomicThreadStateGetE_10(tid: Tid) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateSetW_10(tid: Tid, x: Var, e: Epoch);
  modifies sx.W;



procedure {:inline 1} AtomicVarStateGetW_10(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetWNoLock_10(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateSetR_10(tid: Tid, x: Var, e: Epoch);
  modifies sx.R;



procedure {:inline 1} AtomicVarStateGetRNoLock_10(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetR_10(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetRShared_10(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVCGetSize_10(tid: Tid, r: Shadowable) returns (i: int);



procedure {:inline 1} AtomicVCGetElem_10(tid: Tid, r: Shadowable, i: int) returns (e: Epoch);



procedure {:inline 1} AtomicVCGetElemShared_10(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVCSetElemShared_10(tid: Tid, x: Var, e: Epoch);
  modifies shadow.VC;



procedure {:inline 1} AtomicVCSetElem_10(tid: Tid, r: Shadowable, i: int, e: Epoch);
  modifies shadow.VC;



procedure {:inline 1} AtomicVCInit_10(tid: Tid, r: Shadowable);
  modifies shadow.VC;



procedure {:inline 1} AtomicReleaseJoinLock_10(tid: Tid, uid: Tid);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseThreadToJoin_10(tid: Tid) returns (uid: Tid);
  modifies shadow.Lock, thread.HasJoined;



procedure {:inline 1} AtomicAllocTid_10(tid: Tid) returns (uid: Tid);
  modifies thread.State, thread.ForkedBy, shadow.Lock;



procedure {:inline 1} AtomicStartThread_10(tid: Tid, uid: Tid);
  modifies thread.State, shadow.Lock;



procedure {:inline 1} AtomicChooseLockToAcquire_10(tid: Tid) returns (l: Lock);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseLockToRelease_10(tid: Tid) returns (l: Lock);



procedure {:inline 1} AtomicReleaseChosenLock_10(tid: Tid, l: Lock);
  modifies shadow.Lock;



implementation {:inline 1} AtomicAcquireVarLock_10(tid: Tid, x: Var)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == nil;
    shadow.Lock[ShadowableVar(x)] := tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableVar(x)] == nil;
    shadow.Lock[ShadowableVar(x)] := tid;
    return;
}



implementation {:inline 1} AtomicReleaseVarLock_10(tid: Tid, x: Var)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    shadow.Lock[ShadowableVar(x)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableVar(x)] := nil;
    return;
}



implementation {:inline 1} AtomicThreadStateGetE_10(tid: Tid) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    e := shadow.VC[ShadowableTid(tid)][tid];
  **** end structured program */

  anon0:
    e := shadow.VC[ShadowableTid(tid)][tid];
    return;
}



implementation {:inline 1} AtomicVarStateSetW_10(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    sx.W[x] := e;
  **** end structured program */

  anon0:
    sx.W[x] := e;
    return;
}



implementation {:inline 1} AtomicVarStateGetW_10(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    e := sx.W[x];
  **** end structured program */

  anon0:
    e := sx.W[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetWNoLock_10(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    e := sx.W[x];
  **** end structured program */

  anon0:
    e := sx.W[x];
    return;
}



implementation {:inline 1} AtomicVarStateSetR_10(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    assert sx.R[x] != SHARED;
    sx.R[x] := e;
  **** end structured program */

  anon0:
    sx.R[x] := e;
    return;
}



implementation {:inline 1} AtomicVarStateGetRNoLock_10(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    e := sx.R[x];
  **** end structured program */

  anon0:
    e := sx.R[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetR_10(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    e := sx.R[x];
  **** end structured program */

  anon0:
    e := sx.R[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetRShared_10(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assume sx.R[x] == SHARED;
    e := SHARED;
  **** end structured program */

  anon0:
    assume sx.R[x] == SHARED;
    e := SHARED;
    return;
}



implementation {:inline 1} AtomicVCGetSize_10(tid: Tid, r: Shadowable) returns (i: int)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[r] == tid;
    i := VCArrayLen(shadow.VC[r]);
  **** end structured program */

  anon0:
    i := VCArrayLen(shadow.VC[r]);
    return;
}



implementation {:inline 1} AtomicVCGetElem_10(tid: Tid, r: Shadowable, i: int) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[r] == tid;
    e := VCArrayGet(shadow.VC[r], i);
  **** end structured program */

  anon0:
    e := VCArrayGet(shadow.VC[r], i);
    return;
}



implementation {:inline 1} AtomicVCGetElemShared_10(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert sx.R[x] == SHARED;
    assert ValidTid(tid);
    e := VCArrayGet(shadow.VC[ShadowableVar(x)], tid);
  **** end structured program */

  anon0:
    e := VCArrayGet(shadow.VC[ShadowableVar(x)], tid);
    return;
}



implementation {:inline 1} AtomicVCSetElemShared_10(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert sx.R[x] == SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    shadow.VC[ShadowableVar(x)][tid] := e;
    shadow.VC[ShadowableVar(x)] := VCArraySetLen(shadow.VC[ShadowableVar(x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(x)]), tid + 1));
  **** end structured program */

  anon0:
    shadow.VC[ShadowableVar(x)][tid] := e;
    shadow.VC[ShadowableVar(x)] := VCArraySetLen(shadow.VC[ShadowableVar(x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(x)]), tid + 1));
    return;
}



implementation {:inline 1} AtomicVCSetElem_10(tid: Tid, r: Shadowable, i: int, e: Epoch)
{
  /*** structured program:
    assert is#ShadowableVar(r) ==> sx.R[x#ShadowableVar(r)] != SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[r] == tid;
    shadow.VC[r][i] := e;
    shadow.VC[r] := VCArraySetLen(shadow.VC[r], max(VCArrayLen(shadow.VC[r]), i + 1));
  **** end structured program */

  anon0:
    shadow.VC[r][i] := e;
    shadow.VC[r] := VCArraySetLen(shadow.VC[r], max(VCArrayLen(shadow.VC[r]), i + 1));
    return;
}



implementation {:inline 1} AtomicVCInit_10(tid: Tid, r: Shadowable)
{
  /*** structured program:
    assert ValidTid(tid);
    assert is#ShadowableVar(r) ==> sx.R[x#ShadowableVar(r)] != SHARED;
    assert shadow.Lock[r] == tid;
    shadow.VC[r] := VC.bottom();
  **** end structured program */

  anon0:
    shadow.VC[r] := VC.bottom();
    return;
}



implementation {:inline 1} AtomicReleaseJoinLock_10(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    shadow.Lock[ShadowableTid(uid)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableTid(uid)] := nil;
    return;
}



implementation {:inline 1} AtomicChooseThreadToJoin_10(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
    return;
}



implementation {:inline 1} AtomicAllocTid_10(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
    return;
}



implementation {:inline 1} AtomicStartThread_10(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert thread.State[uid] == NEW();
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
  **** end structured program */

  anon0:
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
    return;
}



implementation {:inline 1} AtomicChooseLockToAcquire_10(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
    return;
}



implementation {:inline 1} AtomicChooseLockToRelease_10(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == tid;
    return;
}



implementation {:inline 1} AtomicReleaseChosenLock_10(tid: Tid, l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableLock(l)] == tid;
    shadow.Lock[ShadowableLock(l)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableLock(l)] := nil;
    return;
}



procedure {:inline 1} AtomicAcquireVarLock_11(tid: Tid, x: Var);
  modifies shadow.Lock;



procedure {:inline 1} AtomicReleaseVarLock_11(tid: Tid, x: Var);
  modifies shadow.Lock;



procedure {:inline 1} AtomicThreadStateGetE_11(tid: Tid) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateSetW_11(tid: Tid, x: Var, e: Epoch);
  modifies sx.W;



procedure {:inline 1} AtomicVarStateGetW_11(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetWNoLock_11(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateSetR_11(tid: Tid, x: Var, e: Epoch);
  modifies sx.R;



procedure {:inline 1} AtomicVarStateGetRNoLock_11(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetR_11(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetRShared_11(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVCGetElem_11(tid: Tid, r: Shadowable, i: int) returns (e: Epoch);



procedure {:inline 1} AtomicVCGetElemShared_11(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVCSetElemShared_11(tid: Tid, x: Var, e: Epoch);
  modifies shadow.VC;



procedure {:inline 1} AtomicVCSetElem_11(tid: Tid, r: Shadowable, i: int, e: Epoch);
  modifies shadow.VC;



procedure {:inline 1} AtomicVCInit_11(tid: Tid, r: Shadowable);
  modifies shadow.VC;



procedure {:inline 1} AtomicVC.Leq_11(tid: Tid, v1: Shadowable, v2: Shadowable) returns (res: bool);



procedure {:inline 1} AtomicVC.Copy_11(tid: Tid, v1: Shadowable, v2: Shadowable);
  modifies shadow.VC;



procedure {:inline 1} AtomicVC.Join_11(tid: Tid, v1: Shadowable, v2: Shadowable);
  modifies shadow.VC;



procedure {:inline 1} AtomicVC.Inc_11(tid: Tid, v: Shadowable, i: int);
  modifies shadow.VC;



procedure {:inline 1} AtomicReleaseJoinLock_11(tid: Tid, uid: Tid);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseThreadToJoin_11(tid: Tid) returns (uid: Tid);
  modifies shadow.Lock, thread.HasJoined;



procedure {:inline 1} AtomicAllocTid_11(tid: Tid) returns (uid: Tid);
  modifies thread.State, thread.ForkedBy, shadow.Lock;



procedure {:inline 1} AtomicStartThread_11(tid: Tid, uid: Tid);
  modifies thread.State, shadow.Lock;



procedure {:inline 1} AtomicChooseLockToAcquire_11(tid: Tid) returns (l: Lock);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseLockToRelease_11(tid: Tid) returns (l: Lock);



procedure {:inline 1} AtomicReleaseChosenLock_11(tid: Tid, l: Lock);
  modifies shadow.Lock;



implementation {:inline 1} AtomicAcquireVarLock_11(tid: Tid, x: Var)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == nil;
    shadow.Lock[ShadowableVar(x)] := tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableVar(x)] == nil;
    shadow.Lock[ShadowableVar(x)] := tid;
    return;
}



implementation {:inline 1} AtomicReleaseVarLock_11(tid: Tid, x: Var)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    shadow.Lock[ShadowableVar(x)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableVar(x)] := nil;
    return;
}



implementation {:inline 1} AtomicThreadStateGetE_11(tid: Tid) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    e := shadow.VC[ShadowableTid(tid)][tid];
  **** end structured program */

  anon0:
    e := shadow.VC[ShadowableTid(tid)][tid];
    return;
}



implementation {:inline 1} AtomicVarStateSetW_11(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    sx.W[x] := e;
  **** end structured program */

  anon0:
    sx.W[x] := e;
    return;
}



implementation {:inline 1} AtomicVarStateGetW_11(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    e := sx.W[x];
  **** end structured program */

  anon0:
    e := sx.W[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetWNoLock_11(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    e := sx.W[x];
  **** end structured program */

  anon0:
    e := sx.W[x];
    return;
}



implementation {:inline 1} AtomicVarStateSetR_11(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    assert sx.R[x] != SHARED;
    sx.R[x] := e;
  **** end structured program */

  anon0:
    sx.R[x] := e;
    return;
}



implementation {:inline 1} AtomicVarStateGetRNoLock_11(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    e := sx.R[x];
  **** end structured program */

  anon0:
    e := sx.R[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetR_11(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    e := sx.R[x];
  **** end structured program */

  anon0:
    e := sx.R[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetRShared_11(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assume sx.R[x] == SHARED;
    e := SHARED;
  **** end structured program */

  anon0:
    assume sx.R[x] == SHARED;
    e := SHARED;
    return;
}



implementation {:inline 1} AtomicVCGetElem_11(tid: Tid, r: Shadowable, i: int) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[r] == tid;
    e := VCArrayGet(shadow.VC[r], i);
  **** end structured program */

  anon0:
    e := VCArrayGet(shadow.VC[r], i);
    return;
}



implementation {:inline 1} AtomicVCGetElemShared_11(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert sx.R[x] == SHARED;
    assert ValidTid(tid);
    e := VCArrayGet(shadow.VC[ShadowableVar(x)], tid);
  **** end structured program */

  anon0:
    e := VCArrayGet(shadow.VC[ShadowableVar(x)], tid);
    return;
}



implementation {:inline 1} AtomicVCSetElemShared_11(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert sx.R[x] == SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    shadow.VC[ShadowableVar(x)][tid] := e;
    shadow.VC[ShadowableVar(x)] := VCArraySetLen(shadow.VC[ShadowableVar(x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(x)]), tid + 1));
  **** end structured program */

  anon0:
    shadow.VC[ShadowableVar(x)][tid] := e;
    shadow.VC[ShadowableVar(x)] := VCArraySetLen(shadow.VC[ShadowableVar(x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(x)]), tid + 1));
    return;
}



implementation {:inline 1} AtomicVCSetElem_11(tid: Tid, r: Shadowable, i: int, e: Epoch)
{
  /*** structured program:
    assert is#ShadowableVar(r) ==> sx.R[x#ShadowableVar(r)] != SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[r] == tid;
    shadow.VC[r][i] := e;
    shadow.VC[r] := VCArraySetLen(shadow.VC[r], max(VCArrayLen(shadow.VC[r]), i + 1));
  **** end structured program */

  anon0:
    shadow.VC[r][i] := e;
    shadow.VC[r] := VCArraySetLen(shadow.VC[r], max(VCArrayLen(shadow.VC[r]), i + 1));
    return;
}



implementation {:inline 1} AtomicVCInit_11(tid: Tid, r: Shadowable)
{
  /*** structured program:
    assert ValidTid(tid);
    assert is#ShadowableVar(r) ==> sx.R[x#ShadowableVar(r)] != SHARED;
    assert shadow.Lock[r] == tid;
    shadow.VC[r] := VC.bottom();
  **** end structured program */

  anon0:
    shadow.VC[r] := VC.bottom();
    return;
}



implementation {:inline 1} AtomicVC.Leq_11(tid: Tid, v1: Shadowable, v2: Shadowable) returns (res: bool)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[v1] == tid;
    assert shadow.Lock[v2] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert is#ShadowableVar(v1) ==> sx.R[x#ShadowableVar(v1)] == SHARED;
    assert !is#ShadowableVar(v2);
    res := (forall j: int :: 
      { f(j) } 
      0 <= j && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[v1], j), VCArrayGet(shadow.VC[v2], j)));
  **** end structured program */

  anon0:
    res := (forall j: int :: 
      { f(j) } 
      0 <= j && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[v1], j), VCArrayGet(shadow.VC[v2], j)));
    return;
}



implementation {:inline 1} AtomicVC.Copy_11(tid: Tid, v1: Shadowable, v2: Shadowable)
{
  var Vnew: VC;
  var shadow.VC.old: [Shadowable]VC;

  /*** structured program:
    assert ValidTid(tid);
    assert v1 != v2;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[v1] == tid;
    assert shadow.Lock[v2] == tid;
    assert !is#ShadowableVar(v1);
    assert !is#ShadowableVar(v2);
    assert VCRepOk(shadow.VC[v2]);
    assert VCRepOk(shadow.VC[v1]);
    if (*)
    {
        shadow.VC.old := shadow.VC;
        shadow.VC[v1] := Vnew;
        assume VCRepOk(Vnew);
        assume VCArrayLen(shadow.VC[v1])
           == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC[v2]));
        assume (forall j: int :: 
          0 <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    }
    else
    {
        shadow.VC[v1] := shadow.VC[v2];
    }
  **** end structured program */

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    shadow.VC[v1] := shadow.VC[v2];
    return;

  anon3_Then:
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := Vnew;
    assume VCRepOk(Vnew);
    assume VCArrayLen(shadow.VC[v1])
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC[v2]));
    assume (forall j: int :: 
      0 <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    return;
}



implementation {:inline 1} AtomicVC.Join_11(tid: Tid, v1: Shadowable, v2: Shadowable)
{
  var shadow.VC.old: [Shadowable]VC;
  var vcNew: VC;

  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[v1] == tid;
    assert shadow.Lock[v2] == tid;
    assert !is#ShadowableVar(v1);
    assert !is#ShadowableVar(v2);
    assert VCRepOk(shadow.VC[v2]);
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCRepOk(shadow.VC[v1]);
    assume VCArrayLen(shadow.VC[v1])
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
  **** end structured program */

  anon0:
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCRepOk(shadow.VC[v1]);
    assume VCArrayLen(shadow.VC[v1])
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
    return;
}



implementation {:inline 1} AtomicVC.Inc_11(tid: Tid, v: Shadowable, i: int)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[v] == tid;
    assert !is#ShadowableVar(v);
    assert i >= 0;
    assert VCRepOk(shadow.VC[v]);
    shadow.VC[v] := VCArraySetLen(shadow.VC[v], max(VCArrayLen(shadow.VC[v]), i + 1));
    shadow.VC[v] := shadow.VC[v][i := EpochInc(shadow.VC[v][i])];
  **** end structured program */

  anon0:
    shadow.VC[v] := VCArraySetLen(shadow.VC[v], max(VCArrayLen(shadow.VC[v]), i + 1));
    shadow.VC[v] := shadow.VC[v][i := EpochInc(shadow.VC[v][i])];
    return;
}



implementation {:inline 1} AtomicReleaseJoinLock_11(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    shadow.Lock[ShadowableTid(uid)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableTid(uid)] := nil;
    return;
}



implementation {:inline 1} AtomicChooseThreadToJoin_11(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
    return;
}



implementation {:inline 1} AtomicAllocTid_11(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
    return;
}



implementation {:inline 1} AtomicStartThread_11(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert thread.State[uid] == NEW();
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
  **** end structured program */

  anon0:
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
    return;
}



implementation {:inline 1} AtomicChooseLockToAcquire_11(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
    return;
}



implementation {:inline 1} AtomicChooseLockToRelease_11(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == tid;
    return;
}



implementation {:inline 1} AtomicReleaseChosenLock_11(tid: Tid, l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableLock(l)] == tid;
    shadow.Lock[ShadowableLock(l)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableLock(l)] := nil;
    return;
}



procedure {:inline 1} AtomicAcquireVarLock_20(tid: Tid, x: Var);
  modifies shadow.Lock;



procedure {:inline 1} AtomicReleaseVarLock_20(tid: Tid, x: Var);
  modifies shadow.Lock;



procedure {:inline 1} AtomicThreadStateGetE_20(tid: Tid) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateSetW_20(tid: Tid, x: Var, e: Epoch);
  modifies sx.W;



procedure {:inline 1} AtomicVarStateGetW_20(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetWNoLock_20(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateSetR_20(tid: Tid, x: Var, e: Epoch);
  modifies sx.R;



procedure {:inline 1} AtomicVarStateGetRNoLock_20(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetR_20(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVarStateGetRShared_20(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVCGetElem_20(tid: Tid, r: Shadowable, i: int) returns (e: Epoch);



procedure {:inline 1} AtomicVCGetElemShared_20(tid: Tid, x: Var) returns (e: Epoch);



procedure {:inline 1} AtomicVCSetElemShared_20(tid: Tid, x: Var, e: Epoch);
  modifies shadow.VC;



procedure {:inline 1} AtomicVCSetElem_20(tid: Tid, r: Shadowable, i: int, e: Epoch);
  modifies shadow.VC;



procedure {:inline 1} AtomicVCInit_20(tid: Tid, r: Shadowable);
  modifies shadow.VC;



procedure {:inline 1} AtomicVC.Leq_20(tid: Tid, v1: Shadowable, v2: Shadowable) returns (res: bool);



procedure {:inline 1} AtomicVC.Copy_20(tid: Tid, v1: Shadowable, v2: Shadowable);
  modifies shadow.VC;



procedure {:inline 1} AtomicVC.Join_20(tid: Tid, v1: Shadowable, v2: Shadowable);
  modifies shadow.VC;



procedure {:inline 1} AtomicVC.Inc_20(tid: Tid, v: Shadowable, i: int);
  modifies shadow.VC;



procedure {:inline 1} AtomicReleaseJoinLock_20(tid: Tid, uid: Tid);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseThreadToJoin_20(tid: Tid) returns (uid: Tid);
  modifies shadow.Lock, thread.HasJoined;



procedure {:inline 1} AtomicAllocTid_20(tid: Tid) returns (uid: Tid);
  modifies thread.State, thread.ForkedBy, shadow.Lock;



procedure {:inline 1} AtomicStartThread_20(tid: Tid, uid: Tid);
  modifies thread.State, shadow.Lock;



procedure {:inline 1} AtomicChooseLockToAcquire_20(tid: Tid) returns (l: Lock);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseLockToRelease_20(tid: Tid) returns (l: Lock);



procedure {:inline 1} AtomicReleaseChosenLock_20(tid: Tid, l: Lock);
  modifies shadow.Lock;



implementation {:inline 1} AtomicAcquireVarLock_20(tid: Tid, x: Var)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == nil;
    shadow.Lock[ShadowableVar(x)] := tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableVar(x)] == nil;
    shadow.Lock[ShadowableVar(x)] := tid;
    return;
}



implementation {:inline 1} AtomicReleaseVarLock_20(tid: Tid, x: Var)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    shadow.Lock[ShadowableVar(x)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableVar(x)] := nil;
    return;
}



implementation {:inline 1} AtomicThreadStateGetE_20(tid: Tid) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    e := shadow.VC[ShadowableTid(tid)][tid];
  **** end structured program */

  anon0:
    e := shadow.VC[ShadowableTid(tid)][tid];
    return;
}



implementation {:inline 1} AtomicVarStateSetW_20(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    sx.W[x] := e;
  **** end structured program */

  anon0:
    sx.W[x] := e;
    return;
}



implementation {:inline 1} AtomicVarStateGetW_20(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    e := sx.W[x];
  **** end structured program */

  anon0:
    e := sx.W[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetWNoLock_20(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    e := sx.W[x];
  **** end structured program */

  anon0:
    e := sx.W[x];
    return;
}



implementation {:inline 1} AtomicVarStateSetR_20(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    assert sx.R[x] != SHARED;
    sx.R[x] := e;
  **** end structured program */

  anon0:
    sx.R[x] := e;
    return;
}



implementation {:inline 1} AtomicVarStateGetRNoLock_20(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    e := sx.R[x];
  **** end structured program */

  anon0:
    e := sx.R[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetR_20(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    e := sx.R[x];
  **** end structured program */

  anon0:
    e := sx.R[x];
    return;
}



implementation {:inline 1} AtomicVarStateGetRShared_20(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assume sx.R[x] == SHARED;
    e := SHARED;
  **** end structured program */

  anon0:
    assume sx.R[x] == SHARED;
    e := SHARED;
    return;
}



implementation {:inline 1} AtomicVCGetElem_20(tid: Tid, r: Shadowable, i: int) returns (e: Epoch)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[r] == tid;
    e := VCArrayGet(shadow.VC[r], i);
  **** end structured program */

  anon0:
    e := VCArrayGet(shadow.VC[r], i);
    return;
}



implementation {:inline 1} AtomicVCGetElemShared_20(tid: Tid, x: Var) returns (e: Epoch)
{
  /*** structured program:
    assert sx.R[x] == SHARED;
    assert ValidTid(tid);
    e := VCArrayGet(shadow.VC[ShadowableVar(x)], tid);
  **** end structured program */

  anon0:
    e := VCArrayGet(shadow.VC[ShadowableVar(x)], tid);
    return;
}



implementation {:inline 1} AtomicVCSetElemShared_20(tid: Tid, x: Var, e: Epoch)
{
  /*** structured program:
    assert sx.R[x] == SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    shadow.VC[ShadowableVar(x)][tid] := e;
    shadow.VC[ShadowableVar(x)] := VCArraySetLen(shadow.VC[ShadowableVar(x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(x)]), tid + 1));
  **** end structured program */

  anon0:
    shadow.VC[ShadowableVar(x)][tid] := e;
    shadow.VC[ShadowableVar(x)] := VCArraySetLen(shadow.VC[ShadowableVar(x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(x)]), tid + 1));
    return;
}



implementation {:inline 1} AtomicVCSetElem_20(tid: Tid, r: Shadowable, i: int, e: Epoch)
{
  /*** structured program:
    assert is#ShadowableVar(r) ==> sx.R[x#ShadowableVar(r)] != SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[r] == tid;
    shadow.VC[r][i] := e;
    shadow.VC[r] := VCArraySetLen(shadow.VC[r], max(VCArrayLen(shadow.VC[r]), i + 1));
  **** end structured program */

  anon0:
    shadow.VC[r][i] := e;
    shadow.VC[r] := VCArraySetLen(shadow.VC[r], max(VCArrayLen(shadow.VC[r]), i + 1));
    return;
}



implementation {:inline 1} AtomicVCInit_20(tid: Tid, r: Shadowable)
{
  /*** structured program:
    assert ValidTid(tid);
    assert is#ShadowableVar(r) ==> sx.R[x#ShadowableVar(r)] != SHARED;
    assert shadow.Lock[r] == tid;
    shadow.VC[r] := VC.bottom();
  **** end structured program */

  anon0:
    shadow.VC[r] := VC.bottom();
    return;
}



implementation {:inline 1} AtomicVC.Leq_20(tid: Tid, v1: Shadowable, v2: Shadowable) returns (res: bool)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[v1] == tid;
    assert shadow.Lock[v2] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert is#ShadowableVar(v1) ==> sx.R[x#ShadowableVar(v1)] == SHARED;
    assert !is#ShadowableVar(v2);
    res := (forall j: int :: 
      { f(j) } 
      0 <= j && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[v1], j), VCArrayGet(shadow.VC[v2], j)));
  **** end structured program */

  anon0:
    res := (forall j: int :: 
      { f(j) } 
      0 <= j && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[v1], j), VCArrayGet(shadow.VC[v2], j)));
    return;
}



implementation {:inline 1} AtomicVC.Copy_20(tid: Tid, v1: Shadowable, v2: Shadowable)
{
  var Vnew: VC;
  var shadow.VC.old: [Shadowable]VC;

  /*** structured program:
    assert ValidTid(tid);
    assert v1 != v2;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[v1] == tid;
    assert shadow.Lock[v2] == tid;
    assert !is#ShadowableVar(v1);
    assert !is#ShadowableVar(v2);
    assert VCRepOk(shadow.VC[v2]);
    assert VCRepOk(shadow.VC[v1]);
    if (*)
    {
        shadow.VC.old := shadow.VC;
        shadow.VC[v1] := Vnew;
        assume VCRepOk(Vnew);
        assume VCArrayLen(shadow.VC[v1])
           == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC[v2]));
        assume (forall j: int :: 
          0 <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    }
    else
    {
        shadow.VC[v1] := shadow.VC[v2];
    }
  **** end structured program */

  anon0:
    goto anon3_Then, anon3_Else;

  anon3_Else:
    shadow.VC[v1] := shadow.VC[v2];
    return;

  anon3_Then:
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := Vnew;
    assume VCRepOk(Vnew);
    assume VCArrayLen(shadow.VC[v1])
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC[v2]));
    assume (forall j: int :: 
      0 <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    return;
}



implementation {:inline 1} AtomicVC.Join_20(tid: Tid, v1: Shadowable, v2: Shadowable)
{
  var shadow.VC.old: [Shadowable]VC;
  var vcNew: VC;

  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[v1] == tid;
    assert shadow.Lock[v2] == tid;
    assert !is#ShadowableVar(v1);
    assert !is#ShadowableVar(v2);
    assert VCRepOk(shadow.VC[v2]);
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCRepOk(shadow.VC[v1]);
    assume VCArrayLen(shadow.VC[v1])
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
  **** end structured program */

  anon0:
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCRepOk(shadow.VC[v1]);
    assume VCArrayLen(shadow.VC[v1])
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
    return;
}



implementation {:inline 1} AtomicVC.Inc_20(tid: Tid, v: Shadowable, i: int)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[v] == tid;
    assert !is#ShadowableVar(v);
    assert i >= 0;
    assert VCRepOk(shadow.VC[v]);
    shadow.VC[v] := VCArraySetLen(shadow.VC[v], max(VCArrayLen(shadow.VC[v]), i + 1));
    shadow.VC[v] := shadow.VC[v][i := EpochInc(shadow.VC[v][i])];
  **** end structured program */

  anon0:
    shadow.VC[v] := VCArraySetLen(shadow.VC[v], max(VCArrayLen(shadow.VC[v]), i + 1));
    shadow.VC[v] := shadow.VC[v][i := EpochInc(shadow.VC[v][i])];
    return;
}



implementation {:inline 1} AtomicReleaseJoinLock_20(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    shadow.Lock[ShadowableTid(uid)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableTid(uid)] := nil;
    return;
}



implementation {:inline 1} AtomicChooseThreadToJoin_20(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
    return;
}



implementation {:inline 1} AtomicAllocTid_20(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
    return;
}



implementation {:inline 1} AtomicStartThread_20(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert thread.State[uid] == NEW();
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
  **** end structured program */

  anon0:
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
    return;
}



implementation {:inline 1} AtomicChooseLockToAcquire_20(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
    return;
}



implementation {:inline 1} AtomicChooseLockToRelease_20(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == tid;
    return;
}



implementation {:inline 1} AtomicReleaseChosenLock_20(tid: Tid, l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableLock(l)] == tid;
    shadow.Lock[ShadowableLock(l)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableLock(l)] := nil;
    return;
}



procedure {:inline 1} AtomicFork_21(tid: Tid, uid: Tid);
  modifies shadow.VC;



procedure {:inline 1} AtomicJoin_21(tid: Tid, uid: Tid);
  modifies shadow.VC;



procedure {:inline 1} AtomicAcquire_21(tid: Tid, l: Lock);
  modifies shadow.VC;



procedure {:inline 1} AtomicRelease_21(tid: Tid, l: Lock);
  modifies shadow.VC;



procedure {:inline 1} AtomicWrite_21(tid: Tid, x: Var) returns (ok: bool);
  modifies sx.W;



procedure {:inline 1} AtomicRead_21(tid: Tid, x: Var) returns (ok: bool);
  modifies sx.R, shadow.VC;



procedure {:inline 1} AtomicReleaseJoinLock_21(tid: Tid, uid: Tid);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseThreadToJoin_21(tid: Tid) returns (uid: Tid);
  modifies shadow.Lock, thread.HasJoined;



procedure {:inline 1} AtomicAllocTid_21(tid: Tid) returns (uid: Tid);
  modifies thread.State, thread.ForkedBy, shadow.Lock;



procedure {:inline 1} AtomicStartThread_21(tid: Tid, uid: Tid);
  modifies thread.State, shadow.Lock;



procedure {:inline 1} AtomicChooseLockToAcquire_21(tid: Tid) returns (l: Lock);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseLockToRelease_21(tid: Tid) returns (l: Lock);



procedure {:inline 1} AtomicReleaseChosenLock_21(tid: Tid, l: Lock);
  modifies shadow.Lock;



implementation {:inline 1} AtomicFork_21(tid: Tid, uid: Tid)
{
  var shadow.VC.old: [Shadowable]VC;
  var vcNew: VC;
  var vcNew2: VC;
  var v1: Shadowable;
  var v2: Shadowable;

  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert tid != uid;
    v1 := ShadowableTid(uid);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume VCRepOk(shadow.VC[v1]);
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
    shadow.VC[ShadowableTid(tid)] := vcNew2;
    assume VCRepOk(vcNew2);
    assume VCArrayLen(vcNew2) == max(VCArrayLen(shadow.VC[ShadowableTid(tid)]), tid + 1);
    assume (forall j: int :: 
      0 <= j && j != tid
         ==> VCArrayGet(shadow.VC[ShadowableTid(tid)], j)
           == VCArrayGet(shadow.VC.old[ShadowableTid(tid)], j));
    assume VCArrayGet(shadow.VC[ShadowableTid(tid)], tid)
       == EpochInc(VCArrayGet(shadow.VC.old[ShadowableTid(tid)], tid));
  **** end structured program */

  anon0:
    v1 := ShadowableTid(uid);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume VCRepOk(shadow.VC[v1]);
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
    shadow.VC[ShadowableTid(tid)] := vcNew2;
    assume VCRepOk(vcNew2);
    assume VCArrayLen(vcNew2) == max(VCArrayLen(shadow.VC[ShadowableTid(tid)]), tid + 1);
    assume (forall j: int :: 
      0 <= j && j != tid
         ==> VCArrayGet(shadow.VC[ShadowableTid(tid)], j)
           == VCArrayGet(shadow.VC.old[ShadowableTid(tid)], j));
    assume VCArrayGet(shadow.VC[ShadowableTid(tid)], tid)
       == EpochInc(VCArrayGet(shadow.VC.old[ShadowableTid(tid)], tid));
    return;
}



implementation {:inline 1} AtomicJoin_21(tid: Tid, uid: Tid)
{
  var shadow.VC.old: [Shadowable]VC;
  var vcNew: VC;
  var v1: Shadowable;
  var v2: Shadowable;

  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert tid != uid;
    v1 := ShadowableTid(uid);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    shadow.VC[ShadowableTid(tid)] := vcNew;
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume VCRepOk(shadow.VC[ShadowableTid(tid)]);
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[ShadowableTid(tid)], j)
           == EpochMax(VCArrayGet(shadow.VC.old[ShadowableTid(tid)], j), 
            VCArrayGet(shadow.VC[ShadowableTid(uid)], j)));
  **** end structured program */

  anon0:
    v1 := ShadowableTid(uid);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    shadow.VC[ShadowableTid(tid)] := vcNew;
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume VCRepOk(shadow.VC[ShadowableTid(tid)]);
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[ShadowableTid(tid)], j)
           == EpochMax(VCArrayGet(shadow.VC.old[ShadowableTid(tid)], j), 
            VCArrayGet(shadow.VC[ShadowableTid(uid)], j)));
    return;
}



implementation {:inline 1} AtomicAcquire_21(tid: Tid, l: Lock)
{
  var shadow.VC.old: [Shadowable]VC;
  var vcNew: VC;
  var v1: Shadowable;
  var v2: Shadowable;

  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableLock(l)] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    v1 := ShadowableTid(tid);
    v2 := ShadowableLock(l);
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCRepOk(shadow.VC[v1]);
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
  **** end structured program */

  anon0:
    v1 := ShadowableTid(tid);
    v2 := ShadowableLock(l);
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCRepOk(shadow.VC[v1]);
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
    return;
}



implementation {:inline 1} AtomicRelease_21(tid: Tid, l: Lock)
{
  var shadow.VC.old: [Shadowable]VC;
  var vcNew: VC;
  var vcNew2: VC;
  var v1: Shadowable;
  var v2: Shadowable;

  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableLock(l)] == tid;
    v1 := ShadowableLock(l);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    if (*)
    {
        shadow.VC[v1] := vcNew;
        assume VCRepOk(vcNew);
        assume VCArrayLen(shadow.VC[v1])
           == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC[v2]));
        assume (forall j: int :: 
          0 <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    }
    else
    {
        shadow.VC[v1] := shadow.VC[v2];
    }

    shadow.VC[v2] := vcNew2;
    assume VCRepOk(vcNew2);
    assume VCArrayLen(vcNew2) == max(VCArrayLen(shadow.VC[v2]), tid + 1);
    assume (forall j: int :: 
      0 <= j && j != tid
         ==> VCArrayGet(shadow.VC[v2], j) == VCArrayGet(shadow.VC.old[v2], j));
    assume VCArrayGet(shadow.VC[v2], tid) == EpochInc(VCArrayGet(shadow.VC.old[v2], tid));
  **** end structured program */

  anon0:
    v1 := ShadowableLock(l);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    goto anon4_Then, anon4_Else;

  anon4_Else:
    shadow.VC[v1] := shadow.VC[v2];
    goto anon3;

  anon3:
    shadow.VC[v2] := vcNew2;
    assume VCRepOk(vcNew2);
    assume VCArrayLen(vcNew2) == max(VCArrayLen(shadow.VC[v2]), tid + 1);
    assume (forall j: int :: 
      0 <= j && j != tid
         ==> VCArrayGet(shadow.VC[v2], j) == VCArrayGet(shadow.VC.old[v2], j));
    assume VCArrayGet(shadow.VC[v2], tid) == EpochInc(VCArrayGet(shadow.VC.old[v2], tid));
    return;

  anon4_Then:
    shadow.VC[v1] := vcNew;
    assume VCRepOk(vcNew);
    assume VCArrayLen(shadow.VC[v1])
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC[v2]));
    assume (forall j: int :: 
      0 <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    goto anon3;
}



implementation {:inline 1} AtomicWrite_21(tid: Tid, x: Var) returns (ok: bool)
{
  var st: Shadowable;
  var sx: Shadowable;

  /*** structured program:
    assert ValidTid(tid);
    st := ShadowableTid(tid);
    sx := ShadowableVar(x);
    goto WriteFastPath, WriteExclusive, WritedShared, WriteWriteRace, ReadWriteRace, SharedWriteRace;

  WriteFastPath:
    ok := true;
    assume sx.W[x] == VCArrayGet(shadow.VC[st], tid);
    return;

  WriteExclusive:
    ok := true;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    sx.W[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  WritedShared:
    ok := true;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume sx.R[x] == SHARED;
    assume (forall j: int :: 
      { f(j) } 
      0 <= j && j < max(VCArrayLen(shadow.VC[sx]), VCArrayLen(shadow.VC[st])) && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[sx], j), VCArrayGet(shadow.VC[st], j)));
    sx.W[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  WriteWriteRace:
    ok := false;
    assume !EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    return;

  ReadWriteRace:
    ok := false;
    assume sx.R[x] != SHARED;
    assume !EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    return;

  SharedWriteRace:
    ok := false;
    assume sx.R[x] == SHARED;
    assume !(forall j: int :: 
      { f(j) } 
      0 <= j && j < max(VCArrayLen(shadow.VC[st]), VCArrayLen(shadow.VC[sx])) && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[sx], j), VCArrayGet(shadow.VC[st], j)));
    return;
  **** end structured program */

  anon0:
    st := ShadowableTid(tid);
    sx := ShadowableVar(x);
    goto WriteFastPath, WriteExclusive, WritedShared, WriteWriteRace, ReadWriteRace, SharedWriteRace;

  SharedWriteRace:
    ok := false;
    assume sx.R[x] == SHARED;
    assume !(forall j: int :: 
      { f(j) } 
      0 <= j && j < max(VCArrayLen(shadow.VC[st]), VCArrayLen(shadow.VC[sx])) && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[sx], j), VCArrayGet(shadow.VC[st], j)));
    return;

  ReadWriteRace:
    ok := false;
    assume sx.R[x] != SHARED;
    assume !EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    return;

  WriteWriteRace:
    ok := false;
    assume !EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    return;

  WritedShared:
    ok := true;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume sx.R[x] == SHARED;
    assume (forall j: int :: 
      { f(j) } 
      0 <= j && j < max(VCArrayLen(shadow.VC[sx]), VCArrayLen(shadow.VC[st])) && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[sx], j), VCArrayGet(shadow.VC[st], j)));
    sx.W[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  WriteExclusive:
    ok := true;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    sx.W[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  WriteFastPath:
    ok := true;
    assume sx.W[x] == VCArrayGet(shadow.VC[st], tid);
    return;
}



implementation {:inline 1} AtomicRead_21(tid: Tid, x: Var) returns (ok: bool)
{
  var st: Shadowable;
  var sx: Shadowable;
  var vc: VC;

  /*** structured program:
    assert ValidTid(tid);
    assert tid != nil && tid >= 0 && tid >= 0;
    st := ShadowableTid(tid);
    sx := ShadowableVar(x);
    goto ReadSameEpoch, ReadSharedSameEpoch, ReadExclusive, ReadShared, ReadShare, WriteReadRace;

  ReadSameEpoch:
    ok := true;
    assume sx.R[x] == VCArrayGet(shadow.VC[st], tid);
    return;

  ReadSharedSameEpoch:
    ok := true;
    assume sx.R[x] == SHARED;
    assume VCArrayGet(shadow.VC[sx], tid) == VCArrayGet(shadow.VC[st], tid);
    return;

  ReadExclusive:
    ok := true;
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    sx.R[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  ReadShared:
    ok := true;
    assume sx.R[x] == SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    shadow.VC[sx][tid] := VCArrayGet(shadow.VC[st], tid);
    shadow.VC[sx] := VCArraySetLen(shadow.VC[sx], max(VCArrayLen(shadow.VC[sx]), tid + 1));
    return;

  ReadShare:
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    shadow.VC[sx] := VC.bottom();
    shadow.VC[sx][tid#epoch(sx.R[x])] := sx.R[x];
    shadow.VC[sx][tid] := VCArrayGet(shadow.VC[st], tid);
    shadow.VC[sx] := VCArraySetLen(shadow.VC[sx], max(tid#epoch(sx.R[x]) + 1, tid + 1));
    sx.R[x] := SHARED;
    ok := true;
    return;

  WriteReadRace:
    ok := false;
    assume !EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    return;
  **** end structured program */

  anon0:
    st := ShadowableTid(tid);
    sx := ShadowableVar(x);
    goto ReadSameEpoch, ReadSharedSameEpoch, ReadExclusive, ReadShared, ReadShare, WriteReadRace;

  WriteReadRace:
    ok := false;
    assume !EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    return;

  ReadShare:
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    shadow.VC[sx] := VC.bottom();
    shadow.VC[sx][tid#epoch(sx.R[x])] := sx.R[x];
    shadow.VC[sx][tid] := VCArrayGet(shadow.VC[st], tid);
    shadow.VC[sx] := VCArraySetLen(shadow.VC[sx], max(tid#epoch(sx.R[x]) + 1, tid + 1));
    sx.R[x] := SHARED;
    ok := true;
    return;

  ReadShared:
    ok := true;
    assume sx.R[x] == SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    shadow.VC[sx][tid] := VCArrayGet(shadow.VC[st], tid);
    shadow.VC[sx] := VCArraySetLen(shadow.VC[sx], max(VCArrayLen(shadow.VC[sx]), tid + 1));
    return;

  ReadExclusive:
    ok := true;
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    sx.R[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  ReadSharedSameEpoch:
    ok := true;
    assume sx.R[x] == SHARED;
    assume VCArrayGet(shadow.VC[sx], tid) == VCArrayGet(shadow.VC[st], tid);
    return;

  ReadSameEpoch:
    ok := true;
    assume sx.R[x] == VCArrayGet(shadow.VC[st], tid);
    return;
}



implementation {:inline 1} AtomicReleaseJoinLock_21(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    shadow.Lock[ShadowableTid(uid)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableTid(uid)] := nil;
    return;
}



implementation {:inline 1} AtomicChooseThreadToJoin_21(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
    return;
}



implementation {:inline 1} AtomicAllocTid_21(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
    return;
}



implementation {:inline 1} AtomicStartThread_21(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert thread.State[uid] == NEW();
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
  **** end structured program */

  anon0:
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
    return;
}



implementation {:inline 1} AtomicChooseLockToAcquire_21(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
    return;
}



implementation {:inline 1} AtomicChooseLockToRelease_21(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == tid;
    return;
}



implementation {:inline 1} AtomicReleaseChosenLock_21(tid: Tid, l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableLock(l)] == tid;
    shadow.Lock[ShadowableLock(l)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableLock(l)] := nil;
    return;
}



procedure {:inline 1} AtomicFork_30(tid: Tid, uid: Tid);
  modifies shadow.VC;



procedure {:inline 1} AtomicJoin_30(tid: Tid, uid: Tid);
  modifies shadow.VC;



procedure {:inline 1} AtomicAcquire_30(tid: Tid, l: Lock);
  modifies shadow.VC;



procedure {:inline 1} AtomicRelease_30(tid: Tid, l: Lock);
  modifies shadow.VC;



procedure {:inline 1} AtomicWrite_30(tid: Tid, x: Var) returns (ok: bool);
  modifies sx.W;



procedure {:inline 1} AtomicRead_30(tid: Tid, x: Var) returns (ok: bool);
  modifies sx.R, shadow.VC;



procedure {:inline 1} AtomicReleaseJoinLock_30(tid: Tid, uid: Tid);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseThreadToJoin_30(tid: Tid) returns (uid: Tid);
  modifies shadow.Lock, thread.HasJoined;



procedure {:inline 1} AtomicAllocTid_30(tid: Tid) returns (uid: Tid);
  modifies thread.State, thread.ForkedBy, shadow.Lock;



procedure {:inline 1} AtomicStartThread_30(tid: Tid, uid: Tid);
  modifies thread.State, shadow.Lock;



procedure {:inline 1} AtomicChooseLockToAcquire_30(tid: Tid) returns (l: Lock);
  modifies shadow.Lock;



procedure {:inline 1} AtomicChooseLockToRelease_30(tid: Tid) returns (l: Lock);



procedure {:inline 1} AtomicReleaseChosenLock_30(tid: Tid, l: Lock);
  modifies shadow.Lock;



implementation {:inline 1} AtomicFork_30(tid: Tid, uid: Tid)
{
  var shadow.VC.old: [Shadowable]VC;
  var vcNew: VC;
  var vcNew2: VC;
  var v1: Shadowable;
  var v2: Shadowable;

  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert tid != uid;
    v1 := ShadowableTid(uid);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume VCRepOk(shadow.VC[v1]);
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
    shadow.VC[ShadowableTid(tid)] := vcNew2;
    assume VCRepOk(vcNew2);
    assume VCArrayLen(vcNew2) == max(VCArrayLen(shadow.VC[ShadowableTid(tid)]), tid + 1);
    assume (forall j: int :: 
      0 <= j && j != tid
         ==> VCArrayGet(shadow.VC[ShadowableTid(tid)], j)
           == VCArrayGet(shadow.VC.old[ShadowableTid(tid)], j));
    assume VCArrayGet(shadow.VC[ShadowableTid(tid)], tid)
       == EpochInc(VCArrayGet(shadow.VC.old[ShadowableTid(tid)], tid));
  **** end structured program */

  anon0:
    v1 := ShadowableTid(uid);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume VCRepOk(shadow.VC[v1]);
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
    shadow.VC[ShadowableTid(tid)] := vcNew2;
    assume VCRepOk(vcNew2);
    assume VCArrayLen(vcNew2) == max(VCArrayLen(shadow.VC[ShadowableTid(tid)]), tid + 1);
    assume (forall j: int :: 
      0 <= j && j != tid
         ==> VCArrayGet(shadow.VC[ShadowableTid(tid)], j)
           == VCArrayGet(shadow.VC.old[ShadowableTid(tid)], j));
    assume VCArrayGet(shadow.VC[ShadowableTid(tid)], tid)
       == EpochInc(VCArrayGet(shadow.VC.old[ShadowableTid(tid)], tid));
    return;
}



implementation {:inline 1} AtomicJoin_30(tid: Tid, uid: Tid)
{
  var shadow.VC.old: [Shadowable]VC;
  var vcNew: VC;
  var v1: Shadowable;
  var v2: Shadowable;

  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert tid != uid;
    v1 := ShadowableTid(uid);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    shadow.VC[ShadowableTid(tid)] := vcNew;
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume VCRepOk(shadow.VC[ShadowableTid(tid)]);
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[ShadowableTid(tid)], j)
           == EpochMax(VCArrayGet(shadow.VC.old[ShadowableTid(tid)], j), 
            VCArrayGet(shadow.VC[ShadowableTid(uid)], j)));
  **** end structured program */

  anon0:
    v1 := ShadowableTid(uid);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    shadow.VC[ShadowableTid(tid)] := vcNew;
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume VCRepOk(shadow.VC[ShadowableTid(tid)]);
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[ShadowableTid(tid)], j)
           == EpochMax(VCArrayGet(shadow.VC.old[ShadowableTid(tid)], j), 
            VCArrayGet(shadow.VC[ShadowableTid(uid)], j)));
    return;
}



implementation {:inline 1} AtomicAcquire_30(tid: Tid, l: Lock)
{
  var shadow.VC.old: [Shadowable]VC;
  var vcNew: VC;
  var v1: Shadowable;
  var v2: Shadowable;

  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableLock(l)] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    v1 := ShadowableTid(tid);
    v2 := ShadowableLock(l);
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCRepOk(shadow.VC[v1]);
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
  **** end structured program */

  anon0:
    v1 := ShadowableTid(tid);
    v2 := ShadowableLock(l);
    shadow.VC.old := shadow.VC;
    shadow.VC[v1] := vcNew;
    assume VCRepOk(shadow.VC[v1]);
    assume VCArrayLen(vcNew)
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC.old[v2]));
    assume (forall j: int :: 
      0 <= j
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(shadow.VC.old[v1], j), VCArrayGet(shadow.VC[v2], j)));
    return;
}



implementation {:inline 1} AtomicRelease_30(tid: Tid, l: Lock)
{
  var shadow.VC.old: [Shadowable]VC;
  var vcNew: VC;
  var vcNew2: VC;
  var v1: Shadowable;
  var v2: Shadowable;

  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableLock(l)] == tid;
    v1 := ShadowableLock(l);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    if (*)
    {
        shadow.VC[v1] := vcNew;
        assume VCRepOk(vcNew);
        assume VCArrayLen(shadow.VC[v1])
           == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC[v2]));
        assume (forall j: int :: 
          0 <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    }
    else
    {
        shadow.VC[v1] := shadow.VC[v2];
    }

    shadow.VC[v2] := vcNew2;
    assume VCRepOk(vcNew2);
    assume VCArrayLen(vcNew2) == max(VCArrayLen(shadow.VC[v2]), tid + 1);
    assume (forall j: int :: 
      0 <= j && j != tid
         ==> VCArrayGet(shadow.VC[v2], j) == VCArrayGet(shadow.VC.old[v2], j));
    assume VCArrayGet(shadow.VC[v2], tid) == EpochInc(VCArrayGet(shadow.VC.old[v2], tid));
  **** end structured program */

  anon0:
    v1 := ShadowableLock(l);
    v2 := ShadowableTid(tid);
    shadow.VC.old := shadow.VC;
    goto anon4_Then, anon4_Else;

  anon4_Else:
    shadow.VC[v1] := shadow.VC[v2];
    goto anon3;

  anon3:
    shadow.VC[v2] := vcNew2;
    assume VCRepOk(vcNew2);
    assume VCArrayLen(vcNew2) == max(VCArrayLen(shadow.VC[v2]), tid + 1);
    assume (forall j: int :: 
      0 <= j && j != tid
         ==> VCArrayGet(shadow.VC[v2], j) == VCArrayGet(shadow.VC.old[v2], j));
    assume VCArrayGet(shadow.VC[v2], tid) == EpochInc(VCArrayGet(shadow.VC.old[v2], tid));
    return;

  anon4_Then:
    shadow.VC[v1] := vcNew;
    assume VCRepOk(vcNew);
    assume VCArrayLen(shadow.VC[v1])
       == max(VCArrayLen(shadow.VC.old[v1]), VCArrayLen(shadow.VC[v2]));
    assume (forall j: int :: 
      0 <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    goto anon3;
}



implementation {:inline 1} AtomicWrite_30(tid: Tid, x: Var) returns (ok: bool)
{
  var st: Shadowable;
  var sx: Shadowable;

  /*** structured program:
    assert ValidTid(tid);
    st := ShadowableTid(tid);
    sx := ShadowableVar(x);
    goto WriteFastPath, WriteExclusive, WritedShared, WriteWriteRace, ReadWriteRace, SharedWriteRace;

  WriteFastPath:
    ok := true;
    assume sx.W[x] == VCArrayGet(shadow.VC[st], tid);
    return;

  WriteExclusive:
    ok := true;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    sx.W[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  WritedShared:
    ok := true;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume sx.R[x] == SHARED;
    assume (forall j: int :: 
      { f(j) } 
      0 <= j && j < max(VCArrayLen(shadow.VC[sx]), VCArrayLen(shadow.VC[st])) && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[sx], j), VCArrayGet(shadow.VC[st], j)));
    sx.W[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  WriteWriteRace:
    ok := false;
    assume !EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    return;

  ReadWriteRace:
    ok := false;
    assume sx.R[x] != SHARED;
    assume !EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    return;

  SharedWriteRace:
    ok := false;
    assume sx.R[x] == SHARED;
    assume !(forall j: int :: 
      { f(j) } 
      0 <= j && j < max(VCArrayLen(shadow.VC[st]), VCArrayLen(shadow.VC[sx])) && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[sx], j), VCArrayGet(shadow.VC[st], j)));
    return;
  **** end structured program */

  anon0:
    st := ShadowableTid(tid);
    sx := ShadowableVar(x);
    goto WriteFastPath, WriteExclusive, WritedShared, WriteWriteRace, ReadWriteRace, SharedWriteRace;

  SharedWriteRace:
    ok := false;
    assume sx.R[x] == SHARED;
    assume !(forall j: int :: 
      { f(j) } 
      0 <= j && j < max(VCArrayLen(shadow.VC[st]), VCArrayLen(shadow.VC[sx])) && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[sx], j), VCArrayGet(shadow.VC[st], j)));
    return;

  ReadWriteRace:
    ok := false;
    assume sx.R[x] != SHARED;
    assume !EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    return;

  WriteWriteRace:
    ok := false;
    assume !EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    return;

  WritedShared:
    ok := true;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume sx.R[x] == SHARED;
    assume (forall j: int :: 
      { f(j) } 
      0 <= j && j < max(VCArrayLen(shadow.VC[sx]), VCArrayLen(shadow.VC[st])) && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[sx], j), VCArrayGet(shadow.VC[st], j)));
    sx.W[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  WriteExclusive:
    ok := true;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    sx.W[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  WriteFastPath:
    ok := true;
    assume sx.W[x] == VCArrayGet(shadow.VC[st], tid);
    return;
}



implementation {:inline 1} AtomicRead_30(tid: Tid, x: Var) returns (ok: bool)
{
  var st: Shadowable;
  var sx: Shadowable;
  var vc: VC;

  /*** structured program:
    assert ValidTid(tid);
    assert tid != nil && tid >= 0 && tid >= 0;
    st := ShadowableTid(tid);
    sx := ShadowableVar(x);
    goto ReadSameEpoch, ReadSharedSameEpoch, ReadExclusive, ReadShared, ReadShare, WriteReadRace;

  ReadSameEpoch:
    ok := true;
    assume sx.R[x] == VCArrayGet(shadow.VC[st], tid);
    return;

  ReadSharedSameEpoch:
    ok := true;
    assume sx.R[x] == SHARED;
    assume VCArrayGet(shadow.VC[sx], tid) == VCArrayGet(shadow.VC[st], tid);
    return;

  ReadExclusive:
    ok := true;
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    sx.R[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  ReadShared:
    ok := true;
    assume sx.R[x] == SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    shadow.VC[sx][tid] := VCArrayGet(shadow.VC[st], tid);
    shadow.VC[sx] := VCArraySetLen(shadow.VC[sx], max(VCArrayLen(shadow.VC[sx]), tid + 1));
    return;

  ReadShare:
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    shadow.VC[sx] := VC.bottom();
    shadow.VC[sx][tid#epoch(sx.R[x])] := sx.R[x];
    shadow.VC[sx][tid] := VCArrayGet(shadow.VC[st], tid);
    shadow.VC[sx] := VCArraySetLen(shadow.VC[sx], max(tid#epoch(sx.R[x]) + 1, tid + 1));
    sx.R[x] := SHARED;
    ok := true;
    return;

  WriteReadRace:
    ok := false;
    assume !EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    return;
  **** end structured program */

  anon0:
    st := ShadowableTid(tid);
    sx := ShadowableVar(x);
    goto ReadSameEpoch, ReadSharedSameEpoch, ReadExclusive, ReadShared, ReadShare, WriteReadRace;

  WriteReadRace:
    ok := false;
    assume !EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    return;

  ReadShare:
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    shadow.VC[sx] := VC.bottom();
    shadow.VC[sx][tid#epoch(sx.R[x])] := sx.R[x];
    shadow.VC[sx][tid] := VCArrayGet(shadow.VC[st], tid);
    shadow.VC[sx] := VCArraySetLen(shadow.VC[sx], max(tid#epoch(sx.R[x]) + 1, tid + 1));
    sx.R[x] := SHARED;
    ok := true;
    return;

  ReadShared:
    ok := true;
    assume sx.R[x] == SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    shadow.VC[sx][tid] := VCArrayGet(shadow.VC[st], tid);
    shadow.VC[sx] := VCArraySetLen(shadow.VC[sx], max(VCArrayLen(shadow.VC[sx]), tid + 1));
    return;

  ReadExclusive:
    ok := true;
    assume sx.R[x] != SHARED;
    assume EpochLeq(sx.W[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.W[x])));
    assume EpochLeq(sx.R[x], VCArrayGet(shadow.VC[st], tid#epoch(sx.R[x])));
    sx.R[x] := VCArrayGet(shadow.VC[st], tid);
    return;

  ReadSharedSameEpoch:
    ok := true;
    assume sx.R[x] == SHARED;
    assume VCArrayGet(shadow.VC[sx], tid) == VCArrayGet(shadow.VC[st], tid);
    return;

  ReadSameEpoch:
    ok := true;
    assume sx.R[x] == VCArrayGet(shadow.VC[st], tid);
    return;
}



implementation {:inline 1} AtomicReleaseJoinLock_30(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    shadow.Lock[ShadowableTid(uid)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableTid(uid)] := nil;
    return;
}



implementation {:inline 1} AtomicChooseThreadToJoin_30(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == STOPPED() && ValidTid(uid);
    assume shadow.Lock[ShadowableTid(uid)] == nil;
    shadow.Lock[ShadowableTid(uid)] := tid;
    thread.HasJoined[tid, uid] := true;
    return;
}



implementation {:inline 1} AtomicAllocTid_30(tid: Tid) returns (uid: Tid)
{
  /*** structured program:
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
  **** end structured program */

  anon0:
    assume tid != uid;
    assume thread.State[uid] == UNUSED() && ValidTid(uid);
    thread.State[uid] := NEW();
    thread.ForkedBy[uid] := tid;
    shadow.Lock[ShadowableTid(uid)] := tid;
    assume VCRepOk(shadow.VC[ShadowableTid(uid)]);
    return;
}



implementation {:inline 1} AtomicStartThread_30(tid: Tid, uid: Tid)
{
  /*** structured program:
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert thread.State[uid] == NEW();
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
  **** end structured program */

  anon0:
    thread.State[uid] := RUNNING();
    shadow.Lock[ShadowableTid(uid)] := uid;
    return;
}



implementation {:inline 1} AtomicChooseLockToAcquire_30(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == nil;
    shadow.Lock[ShadowableLock(l)] := tid;
    return;
}



implementation {:inline 1} AtomicChooseLockToRelease_30(tid: Tid) returns (l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == tid;
  **** end structured program */

  anon0:
    assume shadow.Lock[ShadowableLock(l)] == tid;
    return;
}



implementation {:inline 1} AtomicReleaseChosenLock_30(tid: Tid, l: Lock)
{
  /*** structured program:
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableLock(l)] == tid;
    shadow.Lock[ShadowableLock(l)] := nil;
  **** end structured program */

  anon0:
    shadow.Lock[ShadowableLock(l)] := nil;
    return;
}



var linear_tid_hole: [Tid]bool;

function linear_tid_MapConstBool(b: bool) : [Tid]bool;

function linear_tid_MapConstInt(b: int) : [Tid]int;

function linear_tid_MapEq(a: [Tid]int, b: [Tid]int) : [Tid]bool;

function linear_tid_MapImp(a: [Tid]bool, b: [Tid]bool) : [Tid]bool;

function linear_tid_MapOr(a: [Tid]bool, b: [Tid]bool) : [Tid]bool;

axiom (forall a: [Tid]bool, b: [Tid]bool :: 
  { linear_tid_MapOr(a, b) } 
  (forall x: Tid :: linear_tid_MapOr(a, b)[x] <==> a[x] || b[x]));

axiom (forall a: [Tid]bool, b: [Tid]bool :: 
  { linear_tid_MapImp(a, b) } 
  (forall x: Tid :: linear_tid_MapImp(a, b)[x] <==> a[x] ==> b[x]));

axiom (forall x: Tid :: linear_tid_MapConstBool(true)[x]);

axiom (forall x: Tid :: !linear_tid_MapConstBool(false)[x]);

axiom (forall a: [Tid]int, b: [Tid]int :: 
  { linear_tid_MapEq(a, b) } 
  (forall x: Tid :: linear_tid_MapEq(a, b)[x] <==> a[x] == b[x]));

axiom (forall a: int, x: Tid :: linear_tid_MapConstInt(a)[x] == a);

implementation CommutativityChecker_AtomicAcquireVarLock_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := second_tid][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableVar(second_x) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableVar(second_x)] == nil;



implementation CommutativityChecker_AtomicAcquireVarLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x)] == nil;



implementation GatePreservationChecker_AtomicReleaseVarLock_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_1_AtomicAcquireVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_1_AtomicAcquireVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateSetW_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateSetW_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateSetR_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateSetR_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[first_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;
  ensures true ==> sx.R[first_x] != SHARED;



implementation GatePreservationChecker_AtomicVarStateGetR_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_1_AtomicAcquireVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_1_AtomicAcquireVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_1_AtomicAcquireVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_1_AtomicAcquireVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_1_AtomicAcquireVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_1_AtomicAcquireVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_1_AtomicAcquireVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_1_AtomicAcquireVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_1_AtomicAcquireVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableTid(second_uid) := nil][ShadowableVar(first_x)]
         == nil;



implementation GatePreservationChecker_AtomicReleaseJoinLock_1_AtomicAcquireVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseJoinLock_1_AtomicAcquireVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> ValidTid(first_uid);
  ensures true ==> first_tid != first_uid;
  ensures true ==> shadow.Lock[ShadowableTid(first_uid)] == first_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)
       && thread.HasJoined == old(thread.HasJoined)[second_tid, second_uid := true]
       && second_uid == second_uid
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableTid(second_uid)] == nil
       && old(thread.State)[second_uid] == STOPPED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAcquireVarLock_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && shadow.VC == old(shadow.VC)
       && second_uid == second_uid
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x)]
         == nil
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation GatePreservationChecker_AtomicAllocTid_1_AtomicAcquireVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicAllocTid_1_AtomicAcquireVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  ensures true
     ==> (forall first_t: Tid :: 
      thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);



implementation CommutativityChecker_AtomicAcquireVarLock_1_AtomicStartThread_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_1_AtomicStartThread_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_uid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)[second_uid := RUNNING()]
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_uid][ShadowableVar(first_x)]
         == nil;



implementation GatePreservationChecker_AtomicStartThread_1_AtomicAcquireVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicStartThread_1_AtomicAcquireVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires thread.State[first_uid] == NEW();
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> ValidTid(first_uid);
  ensures true ==> first_tid != first_uid;
  ensures true ==> shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  ensures true ==> thread.State[first_uid] == NEW();



implementation CommutativityChecker_AtomicAcquireVarLock_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableLock(second_l) := second_tid][ShadowableVar(first_x) := first_tid]
       && second_l == second_l
       && old(shadow.Lock)[ShadowableLock(second_l) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableLock(second_l)] == nil;



implementation CommutativityChecker_AtomicAcquireVarLock_1_AtomicChooseLockToRelease_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_1_AtomicChooseLockToRelease_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)[ShadowableVar(first_x) := first_tid]
       && second_l == second_l
       && old(shadow.Lock)[ShadowableVar(first_x)] == nil
       && old(shadow.Lock)[ShadowableLock(second_l)] == second_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableLock(second_l) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableLock(second_l) := nil][ShadowableVar(first_x)] == nil;



implementation GatePreservationChecker_AtomicReleaseChosenLock_1_AtomicAcquireVarLock_1(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseChosenLock_1_AtomicAcquireVarLock_1(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableLock(first_l)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableLock(first_l)] == first_tid;



implementation CommutativityChecker_AtomicReleaseVarLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableVar(first_x)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseVarLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseVarLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseVarLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicThreadStateGetE_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicThreadStateGetE_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableTid(first_tid)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableTid(first_tid)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateSetW_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateSetW_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateGetW_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateGetW_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateSetR_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateSetR_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableVar(first_x)] == first_tid
     && sx.R[first_x] != SHARED);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableVar(first_x)] == first_tid
       && sx.R[first_x] != SHARED);



implementation FailurePreservationChecker_AtomicVarStateGetR_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateGetR_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVCGetSize_1_AtomicReleaseVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCGetSize_1_AtomicReleaseVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVCGetElem_1_AtomicReleaseVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCGetElem_1_AtomicReleaseVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVCSetElemShared_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCSetElemShared_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    sx.R[first_x] == SHARED
     && ValidTid(first_tid)
     && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      sx.R[first_x] == SHARED
       && ValidTid(first_tid)
       && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVCSetElem_1_AtomicReleaseVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCSetElem_1_AtomicReleaseVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
     && ValidTid(first_tid)
     && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
       && ValidTid(first_tid)
       && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVCInit_1_AtomicReleaseVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCInit_1_AtomicReleaseVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
     && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
       && shadow.Lock[first_r] == first_tid);



implementation CommutativityChecker_AtomicReleaseJoinLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableTid(first_uid)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseJoinLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseJoinLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseJoinLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && ValidTid(first_uid)
     && first_tid != first_uid
     && shadow.Lock[ShadowableTid(first_uid)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && ValidTid(first_uid)
       && first_tid != first_uid
       && shadow.Lock[ShadowableTid(first_uid)] == first_tid);



implementation CommutativityChecker_AtomicChooseThreadToJoin_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == STOPPED() && ValidTid(first_uid);
    assume shadow.Lock[ShadowableTid(first_uid)] == nil;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    thread.HasJoined[first_tid, first_uid] := true;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseThreadToJoin_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)
       && shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_tid]
       && thread.HasJoined == old(thread.HasJoined)[first_tid, first_uid := true]
       && first_uid == first_uid
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid)]
         == nil
       && old(thread.State)[first_uid] == STOPPED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicReleaseVarLock_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicAllocTid_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAllocTid_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC == old(shadow.VC)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicReleaseVarLock_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicAllocTid_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicAllocTid_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    thread.State[first_tid] == RUNNING()
     && ValidTid(first_tid)
     && (forall first_t: Tid :: 
      thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      thread.State[first_tid] == RUNNING()
       && ValidTid(first_tid)
       && (forall first_t: Tid :: 
        thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil));



implementation CommutativityChecker_AtomicStartThread_1_AtomicReleaseVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  first_anon0:
    thread.State[first_uid] := RUNNING();
    shadow.Lock[ShadowableTid(first_uid)] := first_uid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicStartThread_1_AtomicReleaseVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires thread.State[first_uid] == NEW();
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_uid]
       && thread.State == old(thread.State)[first_uid := RUNNING()];



implementation GatePreservationChecker_AtomicReleaseVarLock_1_AtomicStartThread_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_1_AtomicStartThread_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicStartThread_1_AtomicReleaseVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicStartThread_1_AtomicReleaseVarLock_1(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && ValidTid(first_uid)
     && first_tid != first_uid
     && shadow.Lock[ShadowableTid(first_uid)] == first_tid
     && thread.State[first_uid] == NEW());
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && ValidTid(first_uid)
       && first_tid != first_uid
       && shadow.Lock[ShadowableTid(first_uid)] == first_tid
       && thread.State[first_uid] == NEW());



implementation CommutativityChecker_AtomicChooseLockToAcquire_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableLock(first_l)] == nil;
    shadow.Lock[ShadowableLock(first_l)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseLockToAcquire_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l) := first_tid]
       && first_l == first_l
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l)] == nil;



implementation GatePreservationChecker_AtomicReleaseVarLock_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicChooseLockToRelease_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableLock(first_l)] == first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseLockToRelease_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)[ShadowableVar(second_x) := nil]
       && first_l == first_l
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l)]
         == first_tid;



implementation CommutativityChecker_AtomicReleaseChosenLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableLock(first_l)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseChosenLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableLock(first_l)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseChosenLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseChosenLock_1_AtomicReleaseVarLock_1(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableLock(first_l)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableLock(first_l)] == first_tid);



implementation GatePreservationChecker_AtomicThreadStateGetE_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_1_AtomicReleaseVarLock_1(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation CommutativityChecker_AtomicThreadStateGetE_1_AtomicVCSetElemShared_1(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_1_AtomicVCSetElemShared_1(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCSetElemShared_1_AtomicThreadStateGetE_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_1_AtomicThreadStateGetE_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation CommutativityChecker_AtomicThreadStateGetE_1_AtomicVCSetElem_1(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_1_AtomicVCSetElem_1(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCSetElem_1_AtomicThreadStateGetE_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_1_AtomicThreadStateGetE_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation CommutativityChecker_AtomicThreadStateGetE_1_AtomicVCInit_1(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_1_AtomicVCInit_1(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[second_r := VC.bottom()][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCInit_1_AtomicThreadStateGetE_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCInit_1_AtomicThreadStateGetE_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation GatePreservationChecker_AtomicThreadStateGetE_1_AtomicReleaseJoinLock_1(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_1_AtomicReleaseJoinLock_1(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_1_AtomicChooseThreadToJoin_1(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_1_AtomicChooseThreadToJoin_1(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_1_AtomicAllocTid_1(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_1_AtomicAllocTid_1(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_1_AtomicStartThread_1(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_1_AtomicStartThread_1(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_1_AtomicChooseLockToAcquire_1(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_1_AtomicChooseLockToAcquire_1(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_1_AtomicReleaseChosenLock_1(first_tid: Tid, second_tid: Tid, second_l: Lock) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_1_AtomicReleaseChosenLock_1(first_tid: Tid, second_tid: Tid, second_l: Lock) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetW_1_AtomicVarStateSetW_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := sx.W[first_x];
    goto second_anon0;

  second_anon0:
    sx.W[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetW_1_AtomicVarStateSetW_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.W == old(sx.W)[second_x := second_e]
       && first_e == old(sx.W)[second_x := second_e][first_x];



implementation CommutativityChecker_AtomicVarStateSetW_1_AtomicVarStateGetW_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    sx.W[first_x] := first_e;
    goto second_anon0;

  second_anon0:
    second_e := sx.W[second_x];
    return;
}



procedure CommutativityChecker_AtomicVarStateSetW_1_AtomicVarStateGetW_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.W == old(sx.W)[first_x := first_e]
       && second_e == old(sx.W)[second_x];



implementation GatePreservationChecker_AtomicVarStateGetW_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_1_AtomicStartThread_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_1_AtomicStartThread_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetR_1_AtomicVarStateSetR_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := sx.R[first_x];
    goto second_anon0;

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetR_1_AtomicVarStateSetR_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)[second_x := second_e]
       && first_e == old(sx.R)[second_x := second_e][first_x];



implementation CommutativityChecker_AtomicVarStateSetR_1_AtomicVarStateGetR_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    sx.R[first_x] := first_e;
    goto second_anon0;

  second_anon0:
    second_e := sx.R[second_x];
    return;
}



procedure CommutativityChecker_AtomicVarStateSetR_1_AtomicVarStateGetR_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[first_x] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)[first_x := first_e]
       && second_e == old(sx.R)[second_x];



implementation GatePreservationChecker_AtomicVarStateGetR_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_1_AtomicStartThread_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_1_AtomicStartThread_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetRShared_1_AtomicVarStateSetR_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    assume sx.R[first_x] == SHARED;
    first_e := SHARED;
    goto second_anon0;

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetRShared_1_AtomicVarStateSetR_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)[second_x := second_e]
       && shadow.Lock == old(shadow.Lock)
       && first_e == SHARED
       && old(sx.R)[second_x := second_e][first_x] == SHARED;



implementation GatePreservationChecker_AtomicVCGetSize_1_AtomicReleaseVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_1_AtomicReleaseVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCGetSize_1_AtomicVCSetElemShared_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_i: int)
{

  first_anon0:
    first_i := VCArrayLen(shadow.VC[first_r]);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetSize_1_AtomicVCSetElemShared_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_i
         == VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r]);



implementation CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCGetSize_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (second_i: int)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_i := VCArrayLen(shadow.VC[second_r]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCGetSize_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_i == VCArrayLen(old(shadow.VC)[second_r]);



implementation CommutativityChecker_AtomicVCGetSize_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_i: int)
{

  first_anon0:
    first_i := VCArrayLen(shadow.VC[first_r]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetSize_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_i
         == VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r]);



implementation CommutativityChecker_AtomicVCSetElem_1_AtomicVCGetSize_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (second_i: int)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_i := VCArrayLen(shadow.VC[second_r]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_1_AtomicVCGetSize_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_i == VCArrayLen(old(shadow.VC)[second_r]);



implementation CommutativityChecker_AtomicVCGetSize_1_AtomicVCInit_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
   returns (first_i: int)
{

  first_anon0:
    first_i := VCArrayLen(shadow.VC[first_r]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCGetSize_1_AtomicVCInit_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_i == VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_r]);



implementation CommutativityChecker_AtomicVCInit_1_AtomicVCGetSize_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
   returns (second_i: int)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_i := VCArrayLen(shadow.VC[second_r]);
    return;
}



procedure CommutativityChecker_AtomicVCInit_1_AtomicVCGetSize_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
   returns (second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_i == VCArrayLen(old(shadow.VC)[second_r]);



implementation GatePreservationChecker_AtomicVCGetSize_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
   returns (first_i: int)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_1_AtomicAllocTid_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_1_AtomicAllocTid_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_1_AtomicStartThread_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
   returns (first_i: int)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_1_AtomicStartThread_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock)
   returns (first_i: int)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_1_AtomicReleaseVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_1_AtomicReleaseVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCGetElem_1_AtomicVCSetElemShared_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_1_AtomicVCSetElemShared_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_e
         == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r], 
          first_i);



implementation CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCGetElem_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCGetElem_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation CommutativityChecker_AtomicVCGetElem_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r], 
          first_i);



implementation CommutativityChecker_AtomicVCSetElem_1_AtomicVCGetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_1_AtomicVCGetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation CommutativityChecker_AtomicVCGetElem_1_AtomicVCInit_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_1_AtomicVCInit_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_e == VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_r], first_i);



implementation CommutativityChecker_AtomicVCInit_1_AtomicVCGetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCInit_1_AtomicVCGetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation GatePreservationChecker_AtomicVCGetElem_1_AtomicReleaseJoinLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_1_AtomicReleaseJoinLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_1_AtomicAllocTid_1(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_1_AtomicAllocTid_1(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_1_AtomicStartThread_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_1_AtomicStartThread_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_1_AtomicReleaseChosenLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_1_AtomicReleaseChosenLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_1_AtomicReleaseVarLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_1_AtomicVarStateSetR_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_1_AtomicVarStateSetR_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCGetElemShared_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCGetElemShared_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_1_AtomicVCSetElemShared_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_1_AtomicVCSetElemShared_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x)], 
          first_tid);



implementation CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCSetElemShared_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCSetElemShared_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCSetElem_1_AtomicVCSetElemShared_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_1_AtomicVCSetElemShared_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCInit_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_1_AtomicVCInit_1(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCInit_1_AtomicVCSetElemShared_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCInit_1_AtomicVCSetElemShared_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r := VC.bottom()];



implementation GatePreservationChecker_AtomicVCSetElemShared_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVCSetElemShared_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_1_AtomicVCSetElemShared_1(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicAllocTid_1_AtomicVCSetElemShared_1(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCSetElemShared_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_1_AtomicAllocTid_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_1_AtomicStartThread_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_1_AtomicStartThread_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_1_AtomicReleaseVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_1_AtomicReleaseVarLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_1_AtomicVarStateSetR_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_1_AtomicVarStateSetR_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCSetElem_1_AtomicVCGetElemShared_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_1_AtomicVCGetElemShared_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x)], 
          first_tid);



implementation CommutativityChecker_AtomicVCSetElem_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCSetElem_1_AtomicVCInit_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_1_AtomicVCInit_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCInit_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCInit_1_AtomicVCSetElem_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r := VC.bottom()];



implementation GatePreservationChecker_AtomicVCSetElem_1_AtomicReleaseJoinLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_1_AtomicReleaseJoinLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_1_AtomicChooseThreadToJoin_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_1_AtomicChooseThreadToJoin_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCSetElem_1_AtomicAllocTid_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_1_AtomicAllocTid_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_1_AtomicVCSetElem_1(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicAllocTid_1_AtomicVCSetElem_1(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCSetElem_1_AtomicAllocTid_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_1_AtomicAllocTid_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_1_AtomicStartThread_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_1_AtomicStartThread_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_1_AtomicChooseLockToAcquire_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_1_AtomicChooseLockToAcquire_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_1_AtomicReleaseChosenLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_1_AtomicReleaseChosenLock_1(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_1_AtomicReleaseVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_1_AtomicReleaseVarLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_1_AtomicVarStateSetR_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_1_AtomicVarStateSetR_1(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCInit_1_AtomicVCGetElemShared_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCInit_1_AtomicVCGetElemShared_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_1_AtomicVCInit_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_r: Shadowable)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_1_AtomicVCInit_1(first_tid: Tid, first_x: Var, second_tid: Tid, second_r: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)], first_tid);



implementation CommutativityChecker_AtomicVCInit_1_AtomicVCInit_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCInit_1_AtomicVCInit_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()][first_r := VC.bottom()];



implementation GatePreservationChecker_AtomicVCInit_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_1_AtomicReleaseJoinLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_1_AtomicChooseThreadToJoin_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCInit_1_AtomicAllocTid_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCInit_1_AtomicAllocTid_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_1_AtomicVCInit_1(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicAllocTid_1_AtomicVCInit_1(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[second_r := VC.bottom()][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCInit_1_AtomicAllocTid_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCInit_1_AtomicAllocTid_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_1_AtomicStartThread_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_1_AtomicStartThread_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_1_AtomicChooseLockToAcquire_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_1_AtomicReleaseChosenLock_1(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := second_tid][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableVar(second_x) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableVar(second_x)] == nil;



implementation CommutativityChecker_AtomicAcquireVarLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x)] == nil;



implementation GatePreservationChecker_AtomicReleaseVarLock_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_10_AtomicAcquireVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_10_AtomicAcquireVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateSetW_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateSetW_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateSetR_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateSetR_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[first_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;
  ensures true ==> sx.R[first_x] != SHARED;



implementation GatePreservationChecker_AtomicVarStateGetR_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_10_AtomicAcquireVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_10_AtomicAcquireVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_10_AtomicAcquireVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_10_AtomicAcquireVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_10_AtomicAcquireVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_10_AtomicAcquireVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_10_AtomicAcquireVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_10_AtomicAcquireVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_10_AtomicAcquireVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableTid(second_uid) := nil][ShadowableVar(first_x)]
         == nil;



implementation GatePreservationChecker_AtomicReleaseJoinLock_10_AtomicAcquireVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseJoinLock_10_AtomicAcquireVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> ValidTid(first_uid);
  ensures true ==> first_tid != first_uid;
  ensures true ==> shadow.Lock[ShadowableTid(first_uid)] == first_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)
       && thread.HasJoined == old(thread.HasJoined)[second_tid, second_uid := true]
       && second_uid == second_uid
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableTid(second_uid)] == nil
       && old(thread.State)[second_uid] == STOPPED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAcquireVarLock_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && shadow.VC == old(shadow.VC)
       && second_uid == second_uid
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x)]
         == nil
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation GatePreservationChecker_AtomicAllocTid_10_AtomicAcquireVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicAllocTid_10_AtomicAcquireVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  ensures true
     ==> (forall first_t: Tid :: 
      thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);



implementation CommutativityChecker_AtomicAcquireVarLock_10_AtomicStartThread_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_10_AtomicStartThread_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_uid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)[second_uid := RUNNING()]
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_uid][ShadowableVar(first_x)]
         == nil;



implementation GatePreservationChecker_AtomicStartThread_10_AtomicAcquireVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicStartThread_10_AtomicAcquireVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires thread.State[first_uid] == NEW();
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> ValidTid(first_uid);
  ensures true ==> first_tid != first_uid;
  ensures true ==> shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  ensures true ==> thread.State[first_uid] == NEW();



implementation CommutativityChecker_AtomicAcquireVarLock_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableLock(second_l) := second_tid][ShadowableVar(first_x) := first_tid]
       && second_l == second_l
       && old(shadow.Lock)[ShadowableLock(second_l) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableLock(second_l)] == nil;



implementation CommutativityChecker_AtomicAcquireVarLock_10_AtomicChooseLockToRelease_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_10_AtomicChooseLockToRelease_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)[ShadowableVar(first_x) := first_tid]
       && second_l == second_l
       && old(shadow.Lock)[ShadowableVar(first_x)] == nil
       && old(shadow.Lock)[ShadowableLock(second_l)] == second_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableLock(second_l) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableLock(second_l) := nil][ShadowableVar(first_x)] == nil;



implementation GatePreservationChecker_AtomicReleaseChosenLock_10_AtomicAcquireVarLock_10(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseChosenLock_10_AtomicAcquireVarLock_10(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableLock(first_l)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableLock(first_l)] == first_tid;



implementation CommutativityChecker_AtomicReleaseVarLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableVar(first_x)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseVarLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseVarLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseVarLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicThreadStateGetE_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicThreadStateGetE_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableTid(first_tid)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableTid(first_tid)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateSetW_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateSetW_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateGetW_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateGetW_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateSetR_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateSetR_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableVar(first_x)] == first_tid
     && sx.R[first_x] != SHARED);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableVar(first_x)] == first_tid
       && sx.R[first_x] != SHARED);



implementation FailurePreservationChecker_AtomicVarStateGetR_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateGetR_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVCGetSize_10_AtomicReleaseVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCGetSize_10_AtomicReleaseVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVCGetElem_10_AtomicReleaseVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCGetElem_10_AtomicReleaseVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVCSetElemShared_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCSetElemShared_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    sx.R[first_x] == SHARED
     && ValidTid(first_tid)
     && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      sx.R[first_x] == SHARED
       && ValidTid(first_tid)
       && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVCSetElem_10_AtomicReleaseVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCSetElem_10_AtomicReleaseVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
     && ValidTid(first_tid)
     && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
       && ValidTid(first_tid)
       && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVCInit_10_AtomicReleaseVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCInit_10_AtomicReleaseVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
     && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
       && shadow.Lock[first_r] == first_tid);



implementation CommutativityChecker_AtomicReleaseJoinLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableTid(first_uid)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseJoinLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseJoinLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseJoinLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && ValidTid(first_uid)
     && first_tid != first_uid
     && shadow.Lock[ShadowableTid(first_uid)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && ValidTid(first_uid)
       && first_tid != first_uid
       && shadow.Lock[ShadowableTid(first_uid)] == first_tid);



implementation CommutativityChecker_AtomicChooseThreadToJoin_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == STOPPED() && ValidTid(first_uid);
    assume shadow.Lock[ShadowableTid(first_uid)] == nil;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    thread.HasJoined[first_tid, first_uid] := true;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseThreadToJoin_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)
       && shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_tid]
       && thread.HasJoined == old(thread.HasJoined)[first_tid, first_uid := true]
       && first_uid == first_uid
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid)]
         == nil
       && old(thread.State)[first_uid] == STOPPED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicReleaseVarLock_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicAllocTid_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAllocTid_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC == old(shadow.VC)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicReleaseVarLock_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicAllocTid_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicAllocTid_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    thread.State[first_tid] == RUNNING()
     && ValidTid(first_tid)
     && (forall first_t: Tid :: 
      thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      thread.State[first_tid] == RUNNING()
       && ValidTid(first_tid)
       && (forall first_t: Tid :: 
        thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil));



implementation CommutativityChecker_AtomicStartThread_10_AtomicReleaseVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  first_anon0:
    thread.State[first_uid] := RUNNING();
    shadow.Lock[ShadowableTid(first_uid)] := first_uid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicStartThread_10_AtomicReleaseVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires thread.State[first_uid] == NEW();
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_uid]
       && thread.State == old(thread.State)[first_uid := RUNNING()];



implementation GatePreservationChecker_AtomicReleaseVarLock_10_AtomicStartThread_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_10_AtomicStartThread_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicStartThread_10_AtomicReleaseVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicStartThread_10_AtomicReleaseVarLock_10(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && ValidTid(first_uid)
     && first_tid != first_uid
     && shadow.Lock[ShadowableTid(first_uid)] == first_tid
     && thread.State[first_uid] == NEW());
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && ValidTid(first_uid)
       && first_tid != first_uid
       && shadow.Lock[ShadowableTid(first_uid)] == first_tid
       && thread.State[first_uid] == NEW());



implementation CommutativityChecker_AtomicChooseLockToAcquire_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableLock(first_l)] == nil;
    shadow.Lock[ShadowableLock(first_l)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseLockToAcquire_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l) := first_tid]
       && first_l == first_l
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l)] == nil;



implementation GatePreservationChecker_AtomicReleaseVarLock_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicChooseLockToRelease_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableLock(first_l)] == first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseLockToRelease_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)[ShadowableVar(second_x) := nil]
       && first_l == first_l
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l)]
         == first_tid;



implementation CommutativityChecker_AtomicReleaseChosenLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableLock(first_l)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseChosenLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableLock(first_l)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseChosenLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseChosenLock_10_AtomicReleaseVarLock_10(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableLock(first_l)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableLock(first_l)] == first_tid);



implementation GatePreservationChecker_AtomicThreadStateGetE_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_10_AtomicReleaseVarLock_10(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation CommutativityChecker_AtomicThreadStateGetE_10_AtomicVCSetElemShared_10(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_10_AtomicVCSetElemShared_10(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCSetElemShared_10_AtomicThreadStateGetE_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_10_AtomicThreadStateGetE_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation CommutativityChecker_AtomicThreadStateGetE_10_AtomicVCSetElem_10(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_10_AtomicVCSetElem_10(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCSetElem_10_AtomicThreadStateGetE_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_10_AtomicThreadStateGetE_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation CommutativityChecker_AtomicThreadStateGetE_10_AtomicVCInit_10(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_10_AtomicVCInit_10(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[second_r := VC.bottom()][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCInit_10_AtomicThreadStateGetE_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCInit_10_AtomicThreadStateGetE_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation GatePreservationChecker_AtomicThreadStateGetE_10_AtomicReleaseJoinLock_10(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_10_AtomicReleaseJoinLock_10(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_10_AtomicChooseThreadToJoin_10(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_10_AtomicChooseThreadToJoin_10(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_10_AtomicAllocTid_10(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_10_AtomicAllocTid_10(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_10_AtomicStartThread_10(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_10_AtomicStartThread_10(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_10_AtomicChooseLockToAcquire_10(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_10_AtomicChooseLockToAcquire_10(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_10_AtomicReleaseChosenLock_10(first_tid: Tid, second_tid: Tid, second_l: Lock) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_10_AtomicReleaseChosenLock_10(first_tid: Tid, second_tid: Tid, second_l: Lock) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetW_10_AtomicVarStateSetW_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := sx.W[first_x];
    goto second_anon0;

  second_anon0:
    sx.W[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetW_10_AtomicVarStateSetW_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.W == old(sx.W)[second_x := second_e]
       && first_e == old(sx.W)[second_x := second_e][first_x];



implementation CommutativityChecker_AtomicVarStateSetW_10_AtomicVarStateGetW_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    sx.W[first_x] := first_e;
    goto second_anon0;

  second_anon0:
    second_e := sx.W[second_x];
    return;
}



procedure CommutativityChecker_AtomicVarStateSetW_10_AtomicVarStateGetW_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.W == old(sx.W)[first_x := first_e]
       && second_e == old(sx.W)[second_x];



implementation GatePreservationChecker_AtomicVarStateGetW_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_10_AtomicStartThread_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_10_AtomicStartThread_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetR_10_AtomicVarStateSetR_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := sx.R[first_x];
    goto second_anon0;

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetR_10_AtomicVarStateSetR_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)[second_x := second_e]
       && first_e == old(sx.R)[second_x := second_e][first_x];



implementation CommutativityChecker_AtomicVarStateSetR_10_AtomicVarStateGetR_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    sx.R[first_x] := first_e;
    goto second_anon0;

  second_anon0:
    second_e := sx.R[second_x];
    return;
}



procedure CommutativityChecker_AtomicVarStateSetR_10_AtomicVarStateGetR_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[first_x] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)[first_x := first_e]
       && second_e == old(sx.R)[second_x];



implementation GatePreservationChecker_AtomicVarStateGetR_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_10_AtomicStartThread_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_10_AtomicStartThread_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetRShared_10_AtomicVarStateSetR_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    assume sx.R[first_x] == SHARED;
    first_e := SHARED;
    goto second_anon0;

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetRShared_10_AtomicVarStateSetR_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)[second_x := second_e]
       && shadow.Lock == old(shadow.Lock)
       && first_e == SHARED
       && old(sx.R)[second_x := second_e][first_x] == SHARED;



implementation GatePreservationChecker_AtomicVCGetSize_10_AtomicReleaseVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_10_AtomicReleaseVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCGetSize_10_AtomicVCSetElemShared_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_i: int)
{

  first_anon0:
    first_i := VCArrayLen(shadow.VC[first_r]);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetSize_10_AtomicVCSetElemShared_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_i
         == VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r]);



implementation CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCGetSize_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (second_i: int)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_i := VCArrayLen(shadow.VC[second_r]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCGetSize_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_i == VCArrayLen(old(shadow.VC)[second_r]);



implementation CommutativityChecker_AtomicVCGetSize_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_i: int)
{

  first_anon0:
    first_i := VCArrayLen(shadow.VC[first_r]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetSize_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_i
         == VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r]);



implementation CommutativityChecker_AtomicVCSetElem_10_AtomicVCGetSize_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (second_i: int)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_i := VCArrayLen(shadow.VC[second_r]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_10_AtomicVCGetSize_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_i == VCArrayLen(old(shadow.VC)[second_r]);



implementation CommutativityChecker_AtomicVCGetSize_10_AtomicVCInit_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
   returns (first_i: int)
{

  first_anon0:
    first_i := VCArrayLen(shadow.VC[first_r]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCGetSize_10_AtomicVCInit_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_i == VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_r]);



implementation CommutativityChecker_AtomicVCInit_10_AtomicVCGetSize_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
   returns (second_i: int)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_i := VCArrayLen(shadow.VC[second_r]);
    return;
}



procedure CommutativityChecker_AtomicVCInit_10_AtomicVCGetSize_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
   returns (second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_i == VCArrayLen(old(shadow.VC)[second_r]);



implementation GatePreservationChecker_AtomicVCGetSize_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
   returns (first_i: int)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_10_AtomicAllocTid_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_10_AtomicAllocTid_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_10_AtomicStartThread_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
   returns (first_i: int)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_10_AtomicStartThread_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid)
   returns (first_i: int, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetSize_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock)
   returns (first_i: int)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetSize_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock)
   returns (first_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_10_AtomicReleaseVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_10_AtomicReleaseVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCGetElem_10_AtomicVCSetElemShared_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_10_AtomicVCSetElemShared_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_e
         == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r], 
          first_i);



implementation CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCGetElem_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCGetElem_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation CommutativityChecker_AtomicVCGetElem_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r], 
          first_i);



implementation CommutativityChecker_AtomicVCSetElem_10_AtomicVCGetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_10_AtomicVCGetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation CommutativityChecker_AtomicVCGetElem_10_AtomicVCInit_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_10_AtomicVCInit_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_e == VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_r], first_i);



implementation CommutativityChecker_AtomicVCInit_10_AtomicVCGetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCInit_10_AtomicVCGetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation GatePreservationChecker_AtomicVCGetElem_10_AtomicReleaseJoinLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_10_AtomicReleaseJoinLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_10_AtomicAllocTid_10(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_10_AtomicAllocTid_10(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_10_AtomicStartThread_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_10_AtomicStartThread_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_10_AtomicReleaseChosenLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_10_AtomicReleaseChosenLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_10_AtomicReleaseVarLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_10_AtomicVarStateSetR_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_10_AtomicVarStateSetR_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCGetElemShared_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCGetElemShared_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_10_AtomicVCSetElemShared_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_10_AtomicVCSetElemShared_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x)], 
          first_tid);



implementation CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCSetElemShared_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCSetElemShared_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCSetElem_10_AtomicVCSetElemShared_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_10_AtomicVCSetElemShared_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCInit_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_10_AtomicVCInit_10(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCInit_10_AtomicVCSetElemShared_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCInit_10_AtomicVCSetElemShared_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r := VC.bottom()];



implementation GatePreservationChecker_AtomicVCSetElemShared_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVCSetElemShared_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_10_AtomicVCSetElemShared_10(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicAllocTid_10_AtomicVCSetElemShared_10(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCSetElemShared_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_10_AtomicAllocTid_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_10_AtomicStartThread_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_10_AtomicStartThread_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_10_AtomicReleaseVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_10_AtomicReleaseVarLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_10_AtomicVarStateSetR_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_10_AtomicVarStateSetR_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCSetElem_10_AtomicVCGetElemShared_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_10_AtomicVCGetElemShared_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x)], 
          first_tid);



implementation CommutativityChecker_AtomicVCSetElem_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCSetElem_10_AtomicVCInit_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_10_AtomicVCInit_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCInit_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCInit_10_AtomicVCSetElem_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r := VC.bottom()];



implementation GatePreservationChecker_AtomicVCSetElem_10_AtomicReleaseJoinLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_10_AtomicReleaseJoinLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_10_AtomicChooseThreadToJoin_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_10_AtomicChooseThreadToJoin_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCSetElem_10_AtomicAllocTid_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_10_AtomicAllocTid_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_10_AtomicVCSetElem_10(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicAllocTid_10_AtomicVCSetElem_10(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCSetElem_10_AtomicAllocTid_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_10_AtomicAllocTid_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_10_AtomicStartThread_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_10_AtomicStartThread_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_10_AtomicChooseLockToAcquire_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_10_AtomicChooseLockToAcquire_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_10_AtomicReleaseChosenLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_10_AtomicReleaseChosenLock_10(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_10_AtomicReleaseVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_10_AtomicReleaseVarLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_10_AtomicVarStateSetR_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_10_AtomicVarStateSetR_10(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCInit_10_AtomicVCGetElemShared_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCInit_10_AtomicVCGetElemShared_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_10_AtomicVCInit_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_r: Shadowable)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_10_AtomicVCInit_10(first_tid: Tid, first_x: Var, second_tid: Tid, second_r: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)], first_tid);



implementation CommutativityChecker_AtomicVCInit_10_AtomicVCInit_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCInit_10_AtomicVCInit_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()][first_r := VC.bottom()];



implementation GatePreservationChecker_AtomicVCInit_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_10_AtomicReleaseJoinLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_10_AtomicChooseThreadToJoin_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCInit_10_AtomicAllocTid_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCInit_10_AtomicAllocTid_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_10_AtomicVCInit_10(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicAllocTid_10_AtomicVCInit_10(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[second_r := VC.bottom()][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCInit_10_AtomicAllocTid_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCInit_10_AtomicAllocTid_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_10_AtomicStartThread_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_10_AtomicStartThread_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_10_AtomicChooseLockToAcquire_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_10_AtomicReleaseChosenLock_10(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := second_tid][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableVar(second_x) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableVar(second_x)] == nil;



implementation CommutativityChecker_AtomicAcquireVarLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x)] == nil;



implementation GatePreservationChecker_AtomicReleaseVarLock_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_11_AtomicAcquireVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_11_AtomicAcquireVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateSetW_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateSetW_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateSetR_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateSetR_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[first_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;
  ensures true ==> sx.R[first_x] != SHARED;



implementation GatePreservationChecker_AtomicVarStateGetR_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_11_AtomicAcquireVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_11_AtomicAcquireVarLock_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_11_AtomicAcquireVarLock_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVC.Leq_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation GatePreservationChecker_AtomicVC.Join_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicAcquireVarLock_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicAcquireVarLock_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableTid(second_uid) := nil][ShadowableVar(first_x)]
         == nil;



implementation GatePreservationChecker_AtomicReleaseJoinLock_11_AtomicAcquireVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseJoinLock_11_AtomicAcquireVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> ValidTid(first_uid);
  ensures true ==> first_tid != first_uid;
  ensures true ==> shadow.Lock[ShadowableTid(first_uid)] == first_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)
       && thread.HasJoined == old(thread.HasJoined)[second_tid, second_uid := true]
       && second_uid == second_uid
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableTid(second_uid)] == nil
       && old(thread.State)[second_uid] == STOPPED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAcquireVarLock_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && shadow.VC == old(shadow.VC)
       && second_uid == second_uid
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x)]
         == nil
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation GatePreservationChecker_AtomicAllocTid_11_AtomicAcquireVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicAllocTid_11_AtomicAcquireVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  ensures true
     ==> (forall first_t: Tid :: 
      thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);



implementation CommutativityChecker_AtomicAcquireVarLock_11_AtomicStartThread_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_11_AtomicStartThread_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_uid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)[second_uid := RUNNING()]
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_uid][ShadowableVar(first_x)]
         == nil;



implementation GatePreservationChecker_AtomicStartThread_11_AtomicAcquireVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicStartThread_11_AtomicAcquireVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires thread.State[first_uid] == NEW();
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> ValidTid(first_uid);
  ensures true ==> first_tid != first_uid;
  ensures true ==> shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  ensures true ==> thread.State[first_uid] == NEW();



implementation CommutativityChecker_AtomicAcquireVarLock_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableLock(second_l) := second_tid][ShadowableVar(first_x) := first_tid]
       && second_l == second_l
       && old(shadow.Lock)[ShadowableLock(second_l) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableLock(second_l)] == nil;



implementation CommutativityChecker_AtomicAcquireVarLock_11_AtomicChooseLockToRelease_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_11_AtomicChooseLockToRelease_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)[ShadowableVar(first_x) := first_tid]
       && second_l == second_l
       && old(shadow.Lock)[ShadowableVar(first_x)] == nil
       && old(shadow.Lock)[ShadowableLock(second_l)] == second_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableLock(second_l) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableLock(second_l) := nil][ShadowableVar(first_x)] == nil;



implementation GatePreservationChecker_AtomicReleaseChosenLock_11_AtomicAcquireVarLock_11(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseChosenLock_11_AtomicAcquireVarLock_11(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableLock(first_l)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableLock(first_l)] == first_tid;



implementation CommutativityChecker_AtomicReleaseVarLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableVar(first_x)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseVarLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseVarLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseVarLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicThreadStateGetE_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicThreadStateGetE_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableTid(first_tid)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableTid(first_tid)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateSetW_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateSetW_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateGetW_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateGetW_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateSetR_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateSetR_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableVar(first_x)] == first_tid
     && sx.R[first_x] != SHARED);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableVar(first_x)] == first_tid
       && sx.R[first_x] != SHARED);



implementation FailurePreservationChecker_AtomicVarStateGetR_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateGetR_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVCGetElem_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCGetElem_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVCSetElemShared_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCSetElemShared_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    sx.R[first_x] == SHARED
     && ValidTid(first_tid)
     && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      sx.R[first_x] == SHARED
       && ValidTid(first_tid)
       && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVCSetElem_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCSetElem_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
     && ValidTid(first_tid)
     && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
       && ValidTid(first_tid)
       && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVCInit_11_AtomicReleaseVarLock_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCInit_11_AtomicReleaseVarLock_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
     && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
       && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVC.Leq_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVC.Leq_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && (is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED)
     && !is#ShadowableVar(first_v2));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && (is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED)
       && !is#ShadowableVar(first_v2));



implementation FailurePreservationChecker_AtomicVC.Copy_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation FailurePreservationChecker_AtomicVC.Join_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation FailurePreservationChecker_AtomicVC.Inc_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation CommutativityChecker_AtomicReleaseJoinLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableTid(first_uid)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseJoinLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseJoinLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseJoinLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && ValidTid(first_uid)
     && first_tid != first_uid
     && shadow.Lock[ShadowableTid(first_uid)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && ValidTid(first_uid)
       && first_tid != first_uid
       && shadow.Lock[ShadowableTid(first_uid)] == first_tid);



implementation CommutativityChecker_AtomicChooseThreadToJoin_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == STOPPED() && ValidTid(first_uid);
    assume shadow.Lock[ShadowableTid(first_uid)] == nil;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    thread.HasJoined[first_tid, first_uid] := true;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseThreadToJoin_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)
       && shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_tid]
       && thread.HasJoined == old(thread.HasJoined)[first_tid, first_uid := true]
       && first_uid == first_uid
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid)]
         == nil
       && old(thread.State)[first_uid] == STOPPED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicReleaseVarLock_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicAllocTid_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAllocTid_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC == old(shadow.VC)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicReleaseVarLock_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicAllocTid_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicAllocTid_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    thread.State[first_tid] == RUNNING()
     && ValidTid(first_tid)
     && (forall first_t: Tid :: 
      thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      thread.State[first_tid] == RUNNING()
       && ValidTid(first_tid)
       && (forall first_t: Tid :: 
        thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil));



implementation CommutativityChecker_AtomicStartThread_11_AtomicReleaseVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  first_anon0:
    thread.State[first_uid] := RUNNING();
    shadow.Lock[ShadowableTid(first_uid)] := first_uid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicStartThread_11_AtomicReleaseVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires thread.State[first_uid] == NEW();
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_uid]
       && thread.State == old(thread.State)[first_uid := RUNNING()];



implementation GatePreservationChecker_AtomicReleaseVarLock_11_AtomicStartThread_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_11_AtomicStartThread_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicStartThread_11_AtomicReleaseVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicStartThread_11_AtomicReleaseVarLock_11(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && ValidTid(first_uid)
     && first_tid != first_uid
     && shadow.Lock[ShadowableTid(first_uid)] == first_tid
     && thread.State[first_uid] == NEW());
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && ValidTid(first_uid)
       && first_tid != first_uid
       && shadow.Lock[ShadowableTid(first_uid)] == first_tid
       && thread.State[first_uid] == NEW());



implementation CommutativityChecker_AtomicChooseLockToAcquire_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableLock(first_l)] == nil;
    shadow.Lock[ShadowableLock(first_l)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseLockToAcquire_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l) := first_tid]
       && first_l == first_l
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l)] == nil;



implementation GatePreservationChecker_AtomicReleaseVarLock_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicChooseLockToRelease_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableLock(first_l)] == first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseLockToRelease_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)[ShadowableVar(second_x) := nil]
       && first_l == first_l
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l)]
         == first_tid;



implementation CommutativityChecker_AtomicReleaseChosenLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableLock(first_l)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseChosenLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableLock(first_l)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseChosenLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseChosenLock_11_AtomicReleaseVarLock_11(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableLock(first_l)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableLock(first_l)] == first_tid);



implementation GatePreservationChecker_AtomicThreadStateGetE_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_11_AtomicReleaseVarLock_11(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation CommutativityChecker_AtomicThreadStateGetE_11_AtomicVCSetElemShared_11(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_11_AtomicVCSetElemShared_11(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicThreadStateGetE_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicThreadStateGetE_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation CommutativityChecker_AtomicThreadStateGetE_11_AtomicVCSetElem_11(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_11_AtomicVCSetElem_11(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicThreadStateGetE_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicThreadStateGetE_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation CommutativityChecker_AtomicThreadStateGetE_11_AtomicVCInit_11(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_11_AtomicVCInit_11(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[second_r := VC.bottom()][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCInit_11_AtomicThreadStateGetE_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicThreadStateGetE_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation CommutativityChecker_AtomicThreadStateGetE_11_AtomicVC.Copy_11(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_e: Epoch)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_11_AtomicVC.Copy_11(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew]
           && first_e
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableTid(first_tid)][first_tid]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]]
         && first_e
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableTid(first_tid)][first_tid]);



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicThreadStateGetE_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_e: Epoch)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicThreadStateGetE_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_Vnew]
           && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1], first_j)
                 == VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2], first_j))
           && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[first_v1]), 
              VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := old(shadow.VC)[first_v2]]
         && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid]);



implementation CommutativityChecker_AtomicThreadStateGetE_11_AtomicVC.Join_11(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_e: Epoch)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_11_AtomicVC.Join_11(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew]
         && first_e
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableTid(first_tid)][first_tid]
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation CommutativityChecker_AtomicVC.Join_11_AtomicThreadStateGetE_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_e: Epoch)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicThreadStateGetE_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_vcNew]
         && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid]
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1], first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v2], first_j)))
         && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[first_v1]), VCArrayLen(old(shadow.VC)[first_v2]))
         && VCRepOk(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation CommutativityChecker_AtomicThreadStateGetE_11_AtomicVC.Inc_11(first_tid: Tid, second_tid: Tid, second_v: Shadowable, second_i: int)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_11_AtomicVC.Inc_11(first_tid: Tid, second_tid: Tid, second_v: Shadowable, second_i: int)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]]
       && first_e
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicThreadStateGetE_11(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicThreadStateGetE_11(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v := old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i])]]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation GatePreservationChecker_AtomicThreadStateGetE_11_AtomicReleaseJoinLock_11(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_11_AtomicReleaseJoinLock_11(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_11_AtomicChooseThreadToJoin_11(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_11_AtomicChooseThreadToJoin_11(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_11_AtomicAllocTid_11(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_11_AtomicAllocTid_11(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_11_AtomicStartThread_11(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_11_AtomicStartThread_11(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_11_AtomicChooseLockToAcquire_11(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_11_AtomicChooseLockToAcquire_11(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_11_AtomicReleaseChosenLock_11(first_tid: Tid, second_tid: Tid, second_l: Lock) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_11_AtomicReleaseChosenLock_11(first_tid: Tid, second_tid: Tid, second_l: Lock) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetW_11_AtomicVarStateSetW_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := sx.W[first_x];
    goto second_anon0;

  second_anon0:
    sx.W[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetW_11_AtomicVarStateSetW_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.W == old(sx.W)[second_x := second_e]
       && first_e == old(sx.W)[second_x := second_e][first_x];



implementation CommutativityChecker_AtomicVarStateSetW_11_AtomicVarStateGetW_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    sx.W[first_x] := first_e;
    goto second_anon0;

  second_anon0:
    second_e := sx.W[second_x];
    return;
}



procedure CommutativityChecker_AtomicVarStateSetW_11_AtomicVarStateGetW_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.W == old(sx.W)[first_x := first_e]
       && second_e == old(sx.W)[second_x];



implementation GatePreservationChecker_AtomicVarStateGetW_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_11_AtomicStartThread_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_11_AtomicStartThread_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetR_11_AtomicVarStateSetR_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := sx.R[first_x];
    goto second_anon0;

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetR_11_AtomicVarStateSetR_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)[second_x := second_e]
       && first_e == old(sx.R)[second_x := second_e][first_x];



implementation CommutativityChecker_AtomicVarStateSetR_11_AtomicVarStateGetR_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    sx.R[first_x] := first_e;
    goto second_anon0;

  second_anon0:
    second_e := sx.R[second_x];
    return;
}



procedure CommutativityChecker_AtomicVarStateSetR_11_AtomicVarStateGetR_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[first_x] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)[first_x := first_e]
       && second_e == old(sx.R)[second_x];



implementation GatePreservationChecker_AtomicVarStateGetR_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_11_AtomicStartThread_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_11_AtomicStartThread_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetRShared_11_AtomicVarStateSetR_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    assume sx.R[first_x] == SHARED;
    first_e := SHARED;
    goto second_anon0;

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetRShared_11_AtomicVarStateSetR_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)[second_x := second_e]
       && shadow.Lock == old(shadow.Lock)
       && first_e == SHARED
       && old(sx.R)[second_x := second_e][first_x] == SHARED;



implementation GatePreservationChecker_AtomicVCGetElem_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCGetElem_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_e
         == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r], 
          first_i);



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation CommutativityChecker_AtomicVCGetElem_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r], 
          first_i);



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation CommutativityChecker_AtomicVCGetElem_11_AtomicVCInit_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_11_AtomicVCInit_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_e == VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_r], first_i);



implementation CommutativityChecker_AtomicVCInit_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation CommutativityChecker_AtomicVCGetElem_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew]
           && first_e
             == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r], first_i)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]]
         && first_e
           == VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r], first_i));



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_Vnew]
           && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i)
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1], first_j)
                 == VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2], first_j))
           && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[first_v1]), 
              VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := old(shadow.VC)[first_v2]]
         && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i));



implementation CommutativityChecker_AtomicVCGetElem_11_AtomicVC.Join_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_11_AtomicVC.Join_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew]
         && first_e
           == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r], first_i)
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation CommutativityChecker_AtomicVC.Join_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_vcNew]
         && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i)
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1], first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v2], first_j)))
         && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[first_v1]), VCArrayLen(old(shadow.VC)[first_v2]))
         && VCRepOk(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation CommutativityChecker_AtomicVCGetElem_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]]
       && first_e
         == VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r], 
          first_i);



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicVCGetElem_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v := old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i])]]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation GatePreservationChecker_AtomicVCGetElem_11_AtomicReleaseJoinLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_11_AtomicReleaseJoinLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_11_AtomicAllocTid_11(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_11_AtomicAllocTid_11(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_11_AtomicStartThread_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_11_AtomicStartThread_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_11_AtomicReleaseChosenLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_11_AtomicReleaseChosenLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_11_AtomicReleaseVarLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_11_AtomicVarStateSetR_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_11_AtomicVarStateSetR_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicVCGetElemShared_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicVCGetElemShared_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_11_AtomicVCSetElemShared_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_11_AtomicVCSetElemShared_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x)], 
          first_tid);



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicVCInit_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicVCInit_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCInit_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r := VC.bottom()];



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && (second_res
         <==> (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j && f(second_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
              VCArrayGet(old(shadow.VC)[second_v2], second_j))));



implementation CommutativityChecker_AtomicVC.Leq_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_res: bool)
{

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && (first_res
         <==> (forall first_j: int :: 
          { f(first_j) } 
          0 <= first_j && f(first_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v1], 
                first_j), 
              VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v2], 
                first_j))));



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        sx.R == old(sx.R)
           && shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
                first_tid + 1))]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
              first_tid + 1))]);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
              max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                second_tid + 1))][first_v1 := #tmp_0_first_Vnew]
           && sx.R == old(sx.R)
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                    max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                      second_tid + 1))][first_v1 := #tmp_0_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                    max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                      second_tid + 1))][first_v1 := #tmp_0_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v1]), 
              VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v1 := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v2]]
         && sx.R == old(sx.R));



implementation FailurePreservationChecker_AtomicVC.Copy_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicVC.Join_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicVC.Join_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
              first_tid + 1))]
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation CommutativityChecker_AtomicVC.Join_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v1 := #tmp_0_first_vcNew]
         && sx.R == old(sx.R)
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v1 := #tmp_0_first_vcNew][first_v1], 
                first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                    max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                      second_tid + 1))][first_v1], 
                  first_j), 
                VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                    max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                      second_tid + 1))][first_v1 := #tmp_0_first_vcNew][first_v2], 
                  first_j)))
         && VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
              max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                second_tid + 1))][first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_v1]), 
            VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_v2]))
         && VCRepOk(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation FailurePreservationChecker_AtomicVC.Join_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x) := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x) := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x) := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_v := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_v]), 
            first_i + 1))][first_v := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_v := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_v]), 
            first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
              max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                second_tid + 1))][first_v], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v]), 
              first_i + 1))][first_v][first_i])]]
       && sx.R == old(sx.R);



implementation FailurePreservationChecker_AtomicVC.Inc_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_11_AtomicVCSetElemShared_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation GatePreservationChecker_AtomicVCSetElemShared_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVCSetElemShared_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_11_AtomicVCSetElemShared_11(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicAllocTid_11_AtomicVCSetElemShared_11(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCSetElemShared_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_11_AtomicAllocTid_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_11_AtomicStartThread_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_11_AtomicStartThread_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_11_AtomicVarStateSetR_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_11_AtomicVarStateSetR_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicVCGetElemShared_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicVCGetElemShared_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x)], 
          first_tid);



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicVCInit_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicVCInit_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCInit_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r := VC.bottom()];



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && (second_res
         <==> (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j && f(second_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
              VCArrayGet(old(shadow.VC)[second_v2], second_j))));



implementation CommutativityChecker_AtomicVC.Leq_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_res: bool)
{

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && (first_res
         <==> (forall first_j: int :: 
          { f(first_j) } 
          0 <= first_j && f(first_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v1], 
                first_j), 
              VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v2], 
                first_j))));



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        sx.R == old(sx.R)
           && shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r][first_i := first_e]][first_r], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r][first_i := first_e]][first_r]), 
                first_i + 1))]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r][first_i := first_e]][first_r], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r][first_i := first_e]][first_r]), 
              first_i + 1))]);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
              max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                second_i + 1))][first_v1 := #tmp_0_first_Vnew]
           && sx.R == old(sx.R)
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                    max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                      second_i + 1))][first_v1 := #tmp_0_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                    max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                      second_i + 1))][first_v1 := #tmp_0_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v1 := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v2]]
         && sx.R == old(sx.R));



implementation FailurePreservationChecker_AtomicVC.Copy_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicVC.Join_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicVC.Join_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r][first_i := first_e]][first_r], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r][first_i := first_e]][first_r]), 
              first_i + 1))]
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation CommutativityChecker_AtomicVC.Join_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v1 := #tmp_0_first_vcNew]
         && sx.R == old(sx.R)
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v1 := #tmp_0_first_vcNew][first_v1], 
                first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                    max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                      second_i + 1))][first_v1], 
                  first_j), 
                VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                    max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                      second_i + 1))][first_v1 := #tmp_0_first_vcNew][first_v2], 
                  first_j)))
         && VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
              max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                second_i + 1))][first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_v1]), 
            VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_v2]))
         && VCRepOk(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation FailurePreservationChecker_AtomicVC.Join_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_v := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_v]), 
            first_i + 1))][first_v := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_v := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_v]), 
            first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
              max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                second_i + 1))][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v]), 
              first_i + 1))][first_v][first_i])]]
       && sx.R == old(sx.R);



implementation FailurePreservationChecker_AtomicVC.Inc_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_11_AtomicVCSetElem_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation GatePreservationChecker_AtomicVCSetElem_11_AtomicReleaseJoinLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_11_AtomicReleaseJoinLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_11_AtomicChooseThreadToJoin_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_11_AtomicChooseThreadToJoin_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCSetElem_11_AtomicAllocTid_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_11_AtomicAllocTid_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_11_AtomicVCSetElem_11(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicAllocTid_11_AtomicVCSetElem_11(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCSetElem_11_AtomicAllocTid_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_11_AtomicAllocTid_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_11_AtomicStartThread_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_11_AtomicStartThread_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_11_AtomicChooseLockToAcquire_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_11_AtomicChooseLockToAcquire_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_11_AtomicReleaseChosenLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_11_AtomicReleaseChosenLock_11(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_11_AtomicReleaseVarLock_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_11_AtomicReleaseVarLock_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_11_AtomicVarStateSetR_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_11_AtomicVarStateSetR_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCInit_11_AtomicVCGetElemShared_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicVCGetElemShared_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_11_AtomicVCInit_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_r: Shadowable)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_11_AtomicVCInit_11(first_tid: Tid, first_x: Var, second_tid: Tid, second_r: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)], first_tid);



implementation CommutativityChecker_AtomicVCInit_11_AtomicVCInit_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicVCInit_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()][first_r := VC.bottom()];



implementation CommutativityChecker_AtomicVCInit_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && (second_res
         <==> (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j && f(second_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
              VCArrayGet(old(shadow.VC)[second_v2], second_j))));



implementation CommutativityChecker_AtomicVC.Leq_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_res: bool)
{

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && (first_res
         <==> (forall first_j: int :: 
          { f(first_j) } 
          0 <= first_j && f(first_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1], first_j), 
              VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v2], first_j))));



implementation CommutativityChecker_AtomicVCInit_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        sx.R == old(sx.R)
           && shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r := VC.bottom()]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r := VC.bottom()]);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_Vnew]
           && sx.R == old(sx.R)
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_r := VC.bottom()][first_v1 := old(shadow.VC)[second_r := VC.bottom()][first_v2]]
         && sx.R == old(sx.R));



implementation FailurePreservationChecker_AtomicVC.Copy_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation CommutativityChecker_AtomicVCInit_11_AtomicVC.Join_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicVC.Join_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r := VC.bottom()]
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation CommutativityChecker_AtomicVC.Join_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_vcNew]
         && sx.R == old(sx.R)
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_vcNew][first_v1], 
                first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_vcNew][first_v2], 
                  first_j)))
         && VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v1]), 
            VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v2]))
         && VCRepOk(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation FailurePreservationChecker_AtomicVC.Join_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_11_AtomicVCInit_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation CommutativityChecker_AtomicVCInit_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r := VC.bottom()];



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicVCInit_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicVCInit_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicVCInit_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicVCInit_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := VC.bottom()][first_v := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v]), first_i + 1))][first_v := old(shadow.VC)[second_r := VC.bottom()][first_v := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_r := VC.bottom()][first_v := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v]), first_i + 1))][first_v][first_i])]]
       && sx.R == old(sx.R);



implementation FailurePreservationChecker_AtomicVC.Inc_11_AtomicVCInit_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_11_AtomicVCInit_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation GatePreservationChecker_AtomicVCInit_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_11_AtomicReleaseJoinLock_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCInit_11_AtomicAllocTid_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCInit_11_AtomicAllocTid_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_11_AtomicVCInit_11(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicAllocTid_11_AtomicVCInit_11(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[second_r := VC.bottom()][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCInit_11_AtomicAllocTid_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCInit_11_AtomicAllocTid_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_11_AtomicStartThread_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_11_AtomicStartThread_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_11_AtomicReleaseChosenLock_11(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVC.Leq_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_11_AtomicVarStateSetR_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_res: bool)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_11_AtomicVarStateSetR_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation CommutativityChecker_AtomicVC.Leq_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_res: bool)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && sx.R == old(sx.R)
           && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew]
           && (first_res
             <==> (forall first_j: int :: 
              { f(first_j) } 
              0 <= first_j && f(first_j)
                 ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1], first_j), 
                  VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v2], first_j))))
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && sx.R == old(sx.R)
         && shadow.VC == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]]
         && (first_res
           <==> (forall first_j: int :: 
            { f(first_j) } 
            0 <= first_j && f(first_j)
               ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v2], first_j)))));



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_Vnew]
           && sx.R == old(sx.R)
           && (second_res
             <==> (forall second_j: int :: 
              { f(second_j) } 
              0 <= second_j && f(second_j)
                 ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                  VCArrayGet(old(shadow.VC)[second_v2], second_j))))
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1], first_j)
                 == VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2], first_j))
           && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[first_v1]), 
              VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := old(shadow.VC)[first_v2]]
         && sx.R == old(sx.R)
         && (second_res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v2], second_j)))));



implementation CommutativityChecker_AtomicVC.Leq_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_res: bool)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && sx.R == old(sx.R)
         && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew]
         && (first_res
           <==> (forall first_j: int :: 
            { f(first_j) } 
            0 <= first_j && f(first_j)
               ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v2], first_j))))
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation CommutativityChecker_AtomicVC.Join_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_vcNew]
         && sx.R == old(sx.R)
         && (second_res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v2], second_j))))
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1], first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v2], first_j)))
         && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[first_v1]), VCArrayLen(old(shadow.VC)[first_v2]))
         && VCRepOk(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation CommutativityChecker_AtomicVC.Leq_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_res: bool)
{

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]]
       && (first_res
         <==> (forall first_j: int :: 
          { f(first_j) } 
          0 <= first_j && f(first_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1], 
                first_j), 
              VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v2], 
                first_j))));



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicVC.Leq_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v := old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i])]]
       && sx.R == old(sx.R)
       && (second_res
         <==> (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j && f(second_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
              VCArrayGet(old(shadow.VC)[second_v2], second_j))));



implementation GatePreservationChecker_AtomicVC.Leq_11_AtomicReleaseJoinLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_res: bool)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_11_AtomicReleaseJoinLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_11_AtomicAllocTid_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_11_AtomicAllocTid_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_11_AtomicStartThread_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_res: bool)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_11_AtomicStartThread_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_11_AtomicReleaseChosenLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_res: bool)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_11_AtomicReleaseChosenLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicVCGetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicVCGetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_Vnew]
           && sx.R == old(sx.R)
           && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid)
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1], first_j)
                 == VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2], first_j))
           && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[first_v1]), 
              VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := old(shadow.VC)[first_v2]]
         && sx.R == old(sx.R)
         && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid));



implementation CommutativityChecker_AtomicVCGetElemShared_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        sx.R == old(sx.R)
           && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew]
           && shadow.Lock == old(shadow.Lock)
           && first_e
             == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x)], 
              first_tid)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        sx.R == old(sx.R)
         && shadow.VC == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]]
         && shadow.Lock == old(shadow.Lock)
         && first_e
           == VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x)], 
            first_tid));



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC, #tmp_1_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_Vnew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_Vnew][first_v2]))
           && VCRepOk(#tmp_1_first_Vnew)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (exists #tmp_0_second_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v2]]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (exists #tmp_1_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_Vnew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_Vnew][first_v2]))
           && VCRepOk(#tmp_1_first_Vnew))
       || (shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v2]]);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation FailurePreservationChecker_AtomicVC.Copy_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC, #tmp_1_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_Vnew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_Vnew][first_v2]))
           && VCRepOk(#tmp_1_first_Vnew)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
                 == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                  VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
           && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]))
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v2]]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
                 == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                  VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
           && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation CommutativityChecker_AtomicVC.Join_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC, #tmp_1_first_vcNew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_vcNew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_vcNew][first_v1], 
                  first_j)
                 == EpochMax(VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1], first_j), 
                  VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_vcNew][first_v2], 
                    first_j)))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_vcNew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v2]))
           && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_vcNew][first_v1])
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (exists #tmp_1_first_vcNew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_vcNew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_vcNew][first_v1], 
                  first_j)
                 == EpochMax(VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1], first_j), 
                  VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_vcNew][first_v2], 
                    first_j)))
           && VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_vcNew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v2]))
           && VCRepOk(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_vcNew][first_v1]));



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation FailurePreservationChecker_AtomicVC.Join_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_Vnew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                      max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                      max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v2]]);



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v]), 
                first_i + 1))][first_v := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v]), 
                first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v], 
                max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v]), 
                  first_i + 1))][first_v][first_i])]]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v]), 
              first_i + 1))][first_v := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v]), 
              first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v]), 
                first_i + 1))][first_v][first_i])]]);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation FailurePreservationChecker_AtomicVC.Inc_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_11_AtomicVC.Copy_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicReleaseJoinLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicReleaseJoinLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Copy_11_AtomicAllocTid_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_11_AtomicAllocTid_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
           && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_Vnew]
           && thread.State == old(thread.State)[second_uid := NEW()]
           && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
           && second_uid == second_uid
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1], first_j)
                 == VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2], first_j))
           && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[first_v1]), 
              VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew)
           && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
           && old(thread.State)[second_uid] == UNUSED()
           && ValidTid(second_uid)
           && second_tid != second_uid)
       || (
        shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
         && shadow.VC == old(shadow.VC)[first_v1 := old(shadow.VC)[first_v2]]
         && thread.State == old(thread.State)[second_uid := NEW()]
         && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
         && second_uid == second_uid
         && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
         && old(thread.State)[second_uid] == UNUSED()
         && ValidTid(second_uid)
         && second_tid != second_uid);



implementation CommutativityChecker_AtomicAllocTid_11_AtomicVC.Copy_11(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_uid: Tid)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicAllocTid_11_AtomicVC.Copy_11(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        thread.State == old(thread.State)[first_uid := NEW()]
           && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
           && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
           && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew]
           && first_uid == first_uid
           && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableTid(first_uid)])
           && old(thread.State)[first_uid] == UNUSED()
           && ValidTid(first_uid)
           && first_tid != first_uid
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        thread.State == old(thread.State)[first_uid := NEW()]
         && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
         && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
         && shadow.VC == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]]
         && first_uid == first_uid
         && VCRepOk(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableTid(first_uid)])
         && old(thread.State)[first_uid] == UNUSED()
         && ValidTid(first_uid)
         && first_tid != first_uid);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicAllocTid_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicAllocTid_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicStartThread_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicStartThread_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation GatePreservationChecker_AtomicVC.Copy_11_AtomicReleaseChosenLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_11_AtomicReleaseChosenLock_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Join_11_AtomicVCGetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicVCGetElemShared_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_vcNew]
         && sx.R == old(sx.R)
         && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid)
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1], first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v2], first_j)))
         && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[first_v1]), VCArrayLen(old(shadow.VC)[first_v2]))
         && VCRepOk(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation CommutativityChecker_AtomicVC.Join_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC, #tmp_1_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_vcNew]
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_vcNew][first_v1], 
                first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_vcNew][first_v2], 
                  first_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1]), 
            VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_vcNew][first_v1])
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation CommutativityChecker_AtomicVC.Join_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_vcNew]
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_vcNew][first_v1], 
                first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                      max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1], 
                  first_j), 
                VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                      max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_vcNew][first_v2], 
                  first_j)))
         && VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1]), 
            VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v2]))
         && VCRepOk(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Join_11_AtomicAllocTid_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVC.Join_11_AtomicAllocTid_11(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
         && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_vcNew]
         && thread.State == old(thread.State)[second_uid := NEW()]
         && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
         && second_uid == second_uid
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1], first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v2], first_j)))
         && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[first_v1]), VCArrayLen(old(shadow.VC)[first_v2]))
         && VCRepOk(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
         && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
         && old(thread.State)[second_uid] == UNUSED()
         && ValidTid(second_uid)
         && second_tid != second_uid);



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicReleaseVarLock_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicVCGetElemShared_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicVCGetElemShared_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v := old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i])]]
       && sx.R == old(sx.R)
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x)], 
          first_tid);



implementation FailurePreservationChecker_AtomicVC.Copy_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicVC.Join_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v]), 
              first_i + 1))][first_v := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v]), 
              first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v]), 
                first_i + 1))][first_v][first_i])]]
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation FailurePreservationChecker_AtomicVC.Join_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v := VCArraySetLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v]), 
            first_i + 1))][first_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v := VCArraySetLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v]), 
            first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v := VCArraySetLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v]), 
              first_i + 1))][first_v][first_i])]];



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation FailurePreservationChecker_AtomicVC.Inc_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_11_AtomicVC.Inc_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicReleaseJoinLock_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicReleaseJoinLock_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicChooseThreadToJoin_11(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_11_AtomicAllocTid_11(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_11_AtomicAllocTid_11(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC
         == old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v := old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i])]]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_11_AtomicVC.Inc_11(first_tid: Tid, second_tid: Tid, second_v: Shadowable, second_i: int)
   returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicAllocTid_11_AtomicVC.Inc_11(first_tid: Tid, second_tid: Tid, second_v: Shadowable, second_i: int)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]]
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicAllocTid_11(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicAllocTid_11(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicStartThread_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicStartThread_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicChooseLockToAcquire_11(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation GatePreservationChecker_AtomicVC.Inc_11_AtomicReleaseChosenLock_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_11_AtomicReleaseChosenLock_11(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation NonBlockingChecker_AtomicVC.Copy_11(second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
{

  L:
    assert true;
    return;
}



procedure NonBlockingChecker_AtomicVC.Copy_11(second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable);
  requires true;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



implementation CommutativityChecker_AtomicAcquireVarLock_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := second_tid][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableVar(second_x) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableVar(second_x)] == nil;



implementation CommutativityChecker_AtomicAcquireVarLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x)] == nil;



implementation GatePreservationChecker_AtomicReleaseVarLock_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_20_AtomicAcquireVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_20_AtomicAcquireVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateSetW_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateSetW_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateSetR_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateSetR_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[first_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;
  ensures true ==> sx.R[first_x] != SHARED;



implementation GatePreservationChecker_AtomicVarStateGetR_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_20_AtomicAcquireVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_20_AtomicAcquireVarLock_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_20_AtomicAcquireVarLock_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVC.Leq_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation GatePreservationChecker_AtomicVC.Join_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicAcquireVarLock_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicAcquireVarLock_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableTid(second_uid) := nil][ShadowableVar(first_x)]
         == nil;



implementation GatePreservationChecker_AtomicReleaseJoinLock_20_AtomicAcquireVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseJoinLock_20_AtomicAcquireVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> ValidTid(first_uid);
  ensures true ==> first_tid != first_uid;
  ensures true ==> shadow.Lock[ShadowableTid(first_uid)] == first_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)
       && thread.HasJoined == old(thread.HasJoined)[second_tid, second_uid := true]
       && second_uid == second_uid
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableTid(second_uid)] == nil
       && old(thread.State)[second_uid] == STOPPED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAcquireVarLock_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && shadow.VC == old(shadow.VC)
       && second_uid == second_uid
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_tid][ShadowableVar(first_x)]
         == nil
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation GatePreservationChecker_AtomicAllocTid_20_AtomicAcquireVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicAllocTid_20_AtomicAcquireVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  ensures true
     ==> (forall first_t: Tid :: 
      thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);



implementation CommutativityChecker_AtomicAcquireVarLock_20_AtomicStartThread_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_20_AtomicStartThread_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableTid(second_uid) := second_uid][ShadowableVar(first_x) := first_tid]
       && thread.State == old(thread.State)[second_uid := RUNNING()]
       && old(shadow.Lock)[ShadowableTid(second_uid) := second_uid][ShadowableVar(first_x)]
         == nil;



implementation GatePreservationChecker_AtomicStartThread_20_AtomicAcquireVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicStartThread_20_AtomicAcquireVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires thread.State[first_uid] == NEW();
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> ValidTid(first_uid);
  ensures true ==> first_tid != first_uid;
  ensures true ==> shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  ensures true ==> thread.State[first_uid] == NEW();



implementation CommutativityChecker_AtomicAcquireVarLock_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableLock(second_l) := second_tid][ShadowableVar(first_x) := first_tid]
       && second_l == second_l
       && old(shadow.Lock)[ShadowableLock(second_l) := second_tid][ShadowableVar(first_x)]
         == nil
       && old(shadow.Lock)[ShadowableLock(second_l)] == nil;



implementation CommutativityChecker_AtomicAcquireVarLock_20_AtomicChooseLockToRelease_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == second_tid;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_20_AtomicChooseLockToRelease_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)[ShadowableVar(first_x) := first_tid]
       && second_l == second_l
       && old(shadow.Lock)[ShadowableVar(first_x)] == nil
       && old(shadow.Lock)[ShadowableLock(second_l)] == second_tid;



implementation CommutativityChecker_AtomicAcquireVarLock_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableVar(first_x)] == nil;
    shadow.Lock[ShadowableVar(first_x)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAcquireVarLock_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableLock(second_l) := nil][ShadowableVar(first_x) := first_tid]
       && old(shadow.Lock)[ShadowableLock(second_l) := nil][ShadowableVar(first_x)] == nil;



implementation GatePreservationChecker_AtomicReleaseChosenLock_20_AtomicAcquireVarLock_20(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  second_anon0:
    assume shadow.Lock[ShadowableVar(second_x)] == nil;
    shadow.Lock[ShadowableVar(second_x)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseChosenLock_20_AtomicAcquireVarLock_20(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableLock(first_l)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableLock(first_l)] == first_tid;



implementation CommutativityChecker_AtomicReleaseVarLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableVar(first_x)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseVarLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableVar(first_x) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseVarLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseVarLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicThreadStateGetE_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicThreadStateGetE_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableTid(first_tid)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableTid(first_tid)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateSetW_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateSetW_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateGetW_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateGetW_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVarStateSetR_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateSetR_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableVar(first_x)] == first_tid
     && sx.R[first_x] != SHARED);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableVar(first_x)] == first_tid
       && sx.R[first_x] != SHARED);



implementation FailurePreservationChecker_AtomicVarStateGetR_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVarStateGetR_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVCGetElem_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCGetElem_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> !(ValidTid(first_tid) && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVCSetElemShared_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCSetElemShared_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    sx.R[first_x] == SHARED
     && ValidTid(first_tid)
     && shadow.Lock[ShadowableVar(first_x)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      sx.R[first_x] == SHARED
       && ValidTid(first_tid)
       && shadow.Lock[ShadowableVar(first_x)] == first_tid);



implementation FailurePreservationChecker_AtomicVCSetElem_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCSetElem_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
     && ValidTid(first_tid)
     && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
       && ValidTid(first_tid)
       && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVCInit_20_AtomicReleaseVarLock_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVCInit_20_AtomicReleaseVarLock_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
     && shadow.Lock[first_r] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && (is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED)
       && shadow.Lock[first_r] == first_tid);



implementation FailurePreservationChecker_AtomicVC.Leq_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVC.Leq_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && (is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED)
     && !is#ShadowableVar(first_v2));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && (is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED)
       && !is#ShadowableVar(first_v2));



implementation FailurePreservationChecker_AtomicVC.Copy_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation FailurePreservationChecker_AtomicVC.Join_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation FailurePreservationChecker_AtomicVC.Inc_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation CommutativityChecker_AtomicReleaseJoinLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableTid(first_uid)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseJoinLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseJoinLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseJoinLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && ValidTid(first_uid)
     && first_tid != first_uid
     && shadow.Lock[ShadowableTid(first_uid)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && ValidTid(first_uid)
       && first_tid != first_uid
       && shadow.Lock[ShadowableTid(first_uid)] == first_tid);



implementation CommutativityChecker_AtomicChooseThreadToJoin_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == STOPPED() && ValidTid(first_uid);
    assume shadow.Lock[ShadowableTid(first_uid)] == nil;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    thread.HasJoined[first_tid, first_uid] := true;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseThreadToJoin_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)
       && shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_tid]
       && thread.HasJoined == old(thread.HasJoined)[first_tid, first_uid := true]
       && first_uid == first_uid
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid)]
         == nil
       && old(thread.State)[first_uid] == STOPPED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicReleaseVarLock_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicAllocTid_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicAllocTid_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC == old(shadow.VC)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicReleaseVarLock_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicAllocTid_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicAllocTid_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    thread.State[first_tid] == RUNNING()
     && ValidTid(first_tid)
     && (forall first_t: Tid :: 
      thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      thread.State[first_tid] == RUNNING()
       && ValidTid(first_tid)
       && (forall first_t: Tid :: 
        thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil));



implementation CommutativityChecker_AtomicStartThread_20_AtomicReleaseVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  first_anon0:
    thread.State[first_uid] := RUNNING();
    shadow.Lock[ShadowableTid(first_uid)] := first_uid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicStartThread_20_AtomicReleaseVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(first_uid);
  requires first_tid != first_uid;
  requires shadow.Lock[ShadowableTid(first_uid)] == first_tid;
  requires thread.State[first_uid] == NEW();
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableTid(first_uid) := first_uid]
       && thread.State == old(thread.State)[first_uid := RUNNING()];



implementation GatePreservationChecker_AtomicReleaseVarLock_20_AtomicStartThread_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_20_AtomicStartThread_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicStartThread_20_AtomicReleaseVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicStartThread_20_AtomicReleaseVarLock_20(first_tid: Tid, first_uid: Tid, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && ValidTid(first_uid)
     && first_tid != first_uid
     && shadow.Lock[ShadowableTid(first_uid)] == first_tid
     && thread.State[first_uid] == NEW());
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && ValidTid(first_uid)
       && first_tid != first_uid
       && shadow.Lock[ShadowableTid(first_uid)] == first_tid
       && thread.State[first_uid] == NEW());



implementation CommutativityChecker_AtomicChooseLockToAcquire_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableLock(first_l)] == nil;
    shadow.Lock[ShadowableLock(first_l)] := first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseLockToAcquire_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
         == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l) := first_tid]
       && first_l == first_l
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l)] == nil;



implementation GatePreservationChecker_AtomicReleaseVarLock_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_x: Var, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicChooseLockToRelease_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock)
{

  first_anon0:
    assume shadow.Lock[ShadowableLock(first_l)] == first_tid;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicChooseLockToRelease_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)[ShadowableVar(second_x) := nil]
       && first_l == first_l
       && old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l)]
         == first_tid;



implementation CommutativityChecker_AtomicReleaseChosenLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  first_anon0:
    shadow.Lock[ShadowableLock(first_l)] := nil;
    goto second_anon0;

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure CommutativityChecker_AtomicReleaseChosenLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableLock(first_l)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock
       == old(shadow.Lock)[ShadowableVar(second_x) := nil][ShadowableLock(first_l) := nil];



implementation GatePreservationChecker_AtomicReleaseVarLock_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicReleaseVarLock_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation FailurePreservationChecker_AtomicReleaseChosenLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure FailurePreservationChecker_AtomicReleaseChosenLock_20_AtomicReleaseVarLock_20(first_tid: Tid, first_l: Lock, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(ValidTid(first_tid) && shadow.Lock[ShadowableLock(first_l)] == first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(ValidTid(first_tid) && shadow.Lock[ShadowableLock(first_l)] == first_tid);



implementation GatePreservationChecker_AtomicThreadStateGetE_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_20_AtomicReleaseVarLock_20(first_tid: Tid, second_tid: Tid, second_x: Var) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation CommutativityChecker_AtomicThreadStateGetE_20_AtomicVCSetElemShared_20(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_20_AtomicVCSetElemShared_20(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicThreadStateGetE_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicThreadStateGetE_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation CommutativityChecker_AtomicThreadStateGetE_20_AtomicVCSetElem_20(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_20_AtomicVCSetElem_20(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicThreadStateGetE_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicThreadStateGetE_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation CommutativityChecker_AtomicThreadStateGetE_20_AtomicVCInit_20(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_20_AtomicVCInit_20(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_e
         == old(shadow.VC)[second_r := VC.bottom()][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVCInit_20_AtomicThreadStateGetE_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicThreadStateGetE_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation CommutativityChecker_AtomicThreadStateGetE_20_AtomicVC.Copy_20(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_e: Epoch)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_20_AtomicVC.Copy_20(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew]
           && first_e
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableTid(first_tid)][first_tid]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]]
         && first_e
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableTid(first_tid)][first_tid]);



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicThreadStateGetE_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_e: Epoch)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicThreadStateGetE_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_Vnew]
           && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1], first_j)
                 == VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2], first_j))
           && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[first_v1]), 
              VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := old(shadow.VC)[first_v2]]
         && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid]);



implementation CommutativityChecker_AtomicThreadStateGetE_20_AtomicVC.Join_20(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_e: Epoch)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_20_AtomicVC.Join_20(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew]
         && first_e
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableTid(first_tid)][first_tid]
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation CommutativityChecker_AtomicVC.Join_20_AtomicThreadStateGetE_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_e: Epoch)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicThreadStateGetE_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_vcNew]
         && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid]
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1], first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v2], first_j)))
         && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[first_v1]), VCArrayLen(old(shadow.VC)[first_v2]))
         && VCRepOk(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation CommutativityChecker_AtomicThreadStateGetE_20_AtomicVC.Inc_20(first_tid: Tid, second_tid: Tid, second_v: Shadowable, second_i: int)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := shadow.VC[ShadowableTid(first_tid)][first_tid];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicThreadStateGetE_20_AtomicVC.Inc_20(first_tid: Tid, second_tid: Tid, second_v: Shadowable, second_i: int)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]]
       && first_e
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableTid(first_tid)][first_tid];



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicThreadStateGetE_20(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    second_e := shadow.VC[ShadowableTid(second_tid)][second_tid];
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicThreadStateGetE_20(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v := old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i])]]
       && second_e == old(shadow.VC)[ShadowableTid(second_tid)][second_tid];



implementation GatePreservationChecker_AtomicThreadStateGetE_20_AtomicReleaseJoinLock_20(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_20_AtomicReleaseJoinLock_20(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_20_AtomicChooseThreadToJoin_20(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_20_AtomicChooseThreadToJoin_20(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_20_AtomicAllocTid_20(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_20_AtomicAllocTid_20(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_20_AtomicStartThread_20(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_20_AtomicStartThread_20(first_tid: Tid, second_tid: Tid, second_uid: Tid) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_20_AtomicChooseLockToAcquire_20(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_20_AtomicChooseLockToAcquire_20(first_tid: Tid, second_tid: Tid) returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicThreadStateGetE_20_AtomicReleaseChosenLock_20(first_tid: Tid, second_tid: Tid, second_l: Lock) returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicThreadStateGetE_20_AtomicReleaseChosenLock_20(first_tid: Tid, second_tid: Tid, second_l: Lock) returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetW_20_AtomicVarStateSetW_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := sx.W[first_x];
    goto second_anon0;

  second_anon0:
    sx.W[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetW_20_AtomicVarStateSetW_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.W == old(sx.W)[second_x := second_e]
       && first_e == old(sx.W)[second_x := second_e][first_x];



implementation CommutativityChecker_AtomicVarStateSetW_20_AtomicVarStateGetW_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    sx.W[first_x] := first_e;
    goto second_anon0;

  second_anon0:
    second_e := sx.W[second_x];
    return;
}



procedure CommutativityChecker_AtomicVarStateSetW_20_AtomicVarStateGetW_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.W == old(sx.W)[first_x := first_e]
       && second_e == old(sx.W)[second_x];



implementation GatePreservationChecker_AtomicVarStateGetW_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_20_AtomicStartThread_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_20_AtomicStartThread_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetW_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetW_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetR_20_AtomicVarStateSetR_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := sx.R[first_x];
    goto second_anon0;

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetR_20_AtomicVarStateSetR_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)[second_x := second_e]
       && first_e == old(sx.R)[second_x := second_e][first_x];



implementation CommutativityChecker_AtomicVarStateSetR_20_AtomicVarStateGetR_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    sx.R[first_x] := first_e;
    goto second_anon0;

  second_anon0:
    second_e := sx.R[second_x];
    return;
}



procedure CommutativityChecker_AtomicVarStateSetR_20_AtomicVarStateGetR_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[first_x] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)[first_x := first_e]
       && second_e == old(sx.R)[second_x];



implementation GatePreservationChecker_AtomicVarStateGetR_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_20_AtomicStartThread_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_20_AtomicStartThread_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_x: Var, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVarStateGetR_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVarStateGetR_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVarStateGetRShared_20_AtomicVarStateSetR_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    assume sx.R[first_x] == SHARED;
    first_e := SHARED;
    goto second_anon0;

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure CommutativityChecker_AtomicVarStateGetRShared_20_AtomicVarStateSetR_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)[second_x := second_e]
       && shadow.Lock == old(shadow.Lock)
       && first_e == SHARED
       && old(sx.R)[second_x := second_e][first_x] == SHARED;



implementation GatePreservationChecker_AtomicVCGetElem_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCGetElem_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_e
         == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r], 
          first_i);



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation CommutativityChecker_AtomicVCGetElem_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r], 
          first_i);



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation CommutativityChecker_AtomicVCGetElem_20_AtomicVCInit_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_20_AtomicVCInit_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_e == VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_r], first_i);



implementation CommutativityChecker_AtomicVCInit_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation CommutativityChecker_AtomicVCGetElem_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew]
           && first_e
             == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r], first_i)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]]
         && first_e
           == VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r], first_i));



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_Vnew]
           && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i)
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1], first_j)
                 == VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2], first_j))
           && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[first_v1]), 
              VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := old(shadow.VC)[first_v2]]
         && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i));



implementation CommutativityChecker_AtomicVCGetElem_20_AtomicVC.Join_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_20_AtomicVC.Join_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew]
         && first_e
           == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r], first_i)
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation CommutativityChecker_AtomicVC.Join_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_vcNew]
         && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i)
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1], first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v2], first_j)))
         && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[first_v1]), VCArrayLen(old(shadow.VC)[first_v2]))
         && VCRepOk(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation CommutativityChecker_AtomicVCGetElem_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[first_r], first_i);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVCGetElem_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]]
       && first_e
         == VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r], 
          first_i);



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[second_r], second_i);
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicVCGetElem_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v := old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i])]]
       && second_e == VCArrayGet(old(shadow.VC)[second_r], second_i);



implementation GatePreservationChecker_AtomicVCGetElem_20_AtomicReleaseJoinLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_20_AtomicReleaseJoinLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_20_AtomicAllocTid_20(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_20_AtomicAllocTid_20(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_20_AtomicStartThread_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_20_AtomicStartThread_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_r: Shadowable, first_i: int, second_tid: Tid)
   returns (first_e: Epoch, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCGetElem_20_AtomicReleaseChosenLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_e: Epoch)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCGetElem_20_AtomicReleaseChosenLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_20_AtomicReleaseVarLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_20_AtomicVarStateSetR_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_20_AtomicVarStateSetR_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicVCGetElemShared_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicVCGetElemShared_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_20_AtomicVCSetElemShared_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_20_AtomicVCSetElemShared_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x)], 
          first_tid);



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][ShadowableVar(first_x) := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_r := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicVCInit_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicVCInit_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x) := old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation CommutativityChecker_AtomicVCInit_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_r := VC.bottom()];



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && (second_res
         <==> (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j && f(second_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
              VCArrayGet(old(shadow.VC)[second_v2], second_j))));



implementation CommutativityChecker_AtomicVC.Leq_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_res: bool)
{

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && (first_res
         <==> (forall first_j: int :: 
          { f(first_j) } 
          0 <= first_j && f(first_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v1], 
                first_j), 
              VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v2], 
                first_j))));



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        sx.R == old(sx.R)
           && shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
                first_tid + 1))]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
              first_tid + 1))]);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
              max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                second_tid + 1))][first_v1 := #tmp_0_first_Vnew]
           && sx.R == old(sx.R)
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                    max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                      second_tid + 1))][first_v1 := #tmp_0_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                    max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                      second_tid + 1))][first_v1 := #tmp_0_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v1]), 
              VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v1 := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v2]]
         && sx.R == old(sx.R));



implementation FailurePreservationChecker_AtomicVC.Copy_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicVC.Join_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicVC.Join_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x) := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
              first_tid + 1))]
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation CommutativityChecker_AtomicVC.Join_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v1 := #tmp_0_first_vcNew]
         && sx.R == old(sx.R)
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v1 := #tmp_0_first_vcNew][first_v1], 
                first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                    max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                      second_tid + 1))][first_v1], 
                  first_j), 
                VCArrayGet(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                    max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                      second_tid + 1))][first_v1 := #tmp_0_first_vcNew][first_v2], 
                  first_j)))
         && VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
              max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                second_tid + 1))][first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_v1]), 
            VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_v2]))
         && VCRepOk(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation FailurePreservationChecker_AtomicVC.Join_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_x: Var, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x) := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x) := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x) := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))];



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_v := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_v]), 
            first_i + 1))][first_v := old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][first_v := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                  second_tid + 1))][first_v]), 
            first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
              second_tid + 1))][first_v := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
              max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                second_tid + 1))][first_v], 
            max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
                  max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
                    second_tid + 1))][first_v]), 
              first_i + 1))][first_v][first_i])]]
       && sx.R == old(sx.R);



implementation FailurePreservationChecker_AtomicVC.Inc_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_20_AtomicVCSetElemShared_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation GatePreservationChecker_AtomicVCSetElemShared_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation CommutativityChecker_AtomicVCSetElemShared_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[ShadowableVar(first_x)][first_tid] := first_e;
    shadow.VC[ShadowableVar(first_x)] := VCArraySetLen(shadow.VC[ShadowableVar(first_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(first_x)]), first_tid + 1));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElemShared_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(first_x) := old(shadow.VC)[ShadowableVar(first_x)][first_tid := first_e]][ShadowableVar(first_x)]), 
            first_tid + 1))]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_20_AtomicVCSetElemShared_20(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[ShadowableVar(second_x)][second_tid] := second_e;
    shadow.VC[ShadowableVar(second_x)] := VCArraySetLen(shadow.VC[ShadowableVar(second_x)], 
      max(VCArrayLen(shadow.VC[ShadowableVar(second_x)]), second_tid + 1));
    return;
}



procedure CommutativityChecker_AtomicAllocTid_20_AtomicVCSetElemShared_20(first_tid: Tid, second_tid: Tid, second_x: Var, second_e: Epoch)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC
         == old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x) := VCArraySetLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)], 
          max(VCArrayLen(old(shadow.VC)[ShadowableVar(second_x) := old(shadow.VC)[ShadowableVar(second_x)][second_tid := second_e]][ShadowableVar(second_x)]), 
            second_tid + 1))][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCSetElemShared_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_20_AtomicAllocTid_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_20_AtomicStartThread_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_20_AtomicStartThread_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElemShared_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElemShared_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_x: Var, first_e: Epoch, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableVar(first_x)] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> sx.R[first_x] == SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableVar(first_x)] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_20_AtomicVarStateSetR_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_20_AtomicVarStateSetR_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicVCGetElemShared_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicVCGetElemShared_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][ShadowableVar(first_x)], 
          first_tid);



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_r := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicVCInit_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicVCInit_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_r := old(shadow.VC)[second_r := VC.bottom()][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation CommutativityChecker_AtomicVCInit_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_r := VC.bottom()];



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && (second_res
         <==> (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j && f(second_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
              VCArrayGet(old(shadow.VC)[second_v2], second_j))));



implementation CommutativityChecker_AtomicVC.Leq_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_res: bool)
{

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && (first_res
         <==> (forall first_j: int :: 
          { f(first_j) } 
          0 <= first_j && f(first_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v1], 
                first_j), 
              VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v2], 
                first_j))));



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        sx.R == old(sx.R)
           && shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r][first_i := first_e]][first_r], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r][first_i := first_e]][first_r]), 
                first_i + 1))]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r][first_i := first_e]][first_r], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r][first_i := first_e]][first_r]), 
              first_i + 1))]);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
              max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                second_i + 1))][first_v1 := #tmp_0_first_Vnew]
           && sx.R == old(sx.R)
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                    max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                      second_i + 1))][first_v1 := #tmp_0_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                    max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                      second_i + 1))][first_v1 := #tmp_0_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v1 := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v2]]
         && sx.R == old(sx.R));



implementation FailurePreservationChecker_AtomicVC.Copy_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicVC.Join_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicVC.Join_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r][first_i := first_e]][first_r], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r][first_i := first_e]][first_r]), 
              first_i + 1))]
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation CommutativityChecker_AtomicVC.Join_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v1 := #tmp_0_first_vcNew]
         && sx.R == old(sx.R)
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v1 := #tmp_0_first_vcNew][first_v1], 
                first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                    max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                      second_i + 1))][first_v1], 
                  first_j), 
                VCArrayGet(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                    max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                      second_i + 1))][first_v1 := #tmp_0_first_vcNew][first_v2], 
                  first_j)))
         && VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
              max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                second_i + 1))][first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_v1]), 
            VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_v2]))
         && VCRepOk(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation FailurePreservationChecker_AtomicVC.Join_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r][first_i := first_e]][first_r]), 
            first_i + 1))];



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_v := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_v]), 
            first_i + 1))][first_v := old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][first_v := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                  second_i + 1))][first_v]), 
            first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
              second_i + 1))][first_v := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
              max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                second_i + 1))][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
                  max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
                    second_i + 1))][first_v]), 
              first_i + 1))][first_v][first_i])]]
       && sx.R == old(sx.R);



implementation FailurePreservationChecker_AtomicVC.Inc_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
{

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_20_AtomicVCSetElem_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation GatePreservationChecker_AtomicVCSetElem_20_AtomicReleaseJoinLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_20_AtomicReleaseJoinLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_20_AtomicChooseThreadToJoin_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_20_AtomicChooseThreadToJoin_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCSetElem_20_AtomicAllocTid_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[first_r][first_i] := first_e;
    shadow.VC[first_r] := VCArraySetLen(shadow.VC[first_r], max(VCArrayLen(shadow.VC[first_r]), first_i + 1));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCSetElem_20_AtomicAllocTid_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC
         == old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r := VCArraySetLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r], 
          max(VCArrayLen(old(shadow.VC)[first_r := old(shadow.VC)[first_r][first_i := first_e]][first_r]), 
            first_i + 1))]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_20_AtomicVCSetElem_20(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r][second_i] := second_e;
    shadow.VC[second_r] := VCArraySetLen(shadow.VC[second_r], max(VCArrayLen(shadow.VC[second_r]), second_i + 1));
    return;
}



procedure CommutativityChecker_AtomicAllocTid_20_AtomicVCSetElem_20(first_tid: Tid, 
    second_tid: Tid, 
    second_r: Shadowable, 
    second_i: int, 
    second_e: Epoch)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC
         == old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r := VCArraySetLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r], 
          max(VCArrayLen(old(shadow.VC)[second_r := old(shadow.VC)[second_r][second_i := second_e]][second_r]), 
            second_i + 1))][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCSetElem_20_AtomicAllocTid_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_20_AtomicAllocTid_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_20_AtomicStartThread_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_20_AtomicStartThread_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_20_AtomicChooseLockToAcquire_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_20_AtomicChooseLockToAcquire_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCSetElem_20_AtomicReleaseChosenLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCSetElem_20_AtomicReleaseChosenLock_20(first_tid: Tid, 
    first_r: Shadowable, 
    first_i: int, 
    first_e: Epoch, 
    second_tid: Tid, 
    second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_20_AtomicReleaseVarLock_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_20_AtomicReleaseVarLock_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_20_AtomicVarStateSetR_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_20_AtomicVarStateSetR_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCInit_20_AtomicVCGetElemShared_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicVCGetElemShared_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_20_AtomicVCInit_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_r: Shadowable)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_20_AtomicVCInit_20(first_tid: Tid, first_x: Var, second_tid: Tid, second_r: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][ShadowableVar(first_x)], first_tid);



implementation CommutativityChecker_AtomicVCInit_20_AtomicVCInit_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicVCInit_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()][first_r := VC.bottom()];



implementation CommutativityChecker_AtomicVCInit_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && (second_res
         <==> (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j && f(second_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
              VCArrayGet(old(shadow.VC)[second_v2], second_j))));



implementation CommutativityChecker_AtomicVC.Leq_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_res: bool)
{

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && (first_res
         <==> (forall first_j: int :: 
          { f(first_j) } 
          0 <= first_j && f(first_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1], first_j), 
              VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v2], first_j))));



implementation CommutativityChecker_AtomicVCInit_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        sx.R == old(sx.R)
           && shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_r := VC.bottom()]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_r := VC.bottom()]);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_Vnew]
           && sx.R == old(sx.R)
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_r := VC.bottom()][first_v1 := old(shadow.VC)[second_r := VC.bottom()][first_v2]]
         && sx.R == old(sx.R));



implementation FailurePreservationChecker_AtomicVC.Copy_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation CommutativityChecker_AtomicVCInit_20_AtomicVC.Join_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicVC.Join_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      sx.R == old(sx.R)
         && shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_r := VC.bottom()]
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation CommutativityChecker_AtomicVC.Join_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_vcNew]
         && sx.R == old(sx.R)
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_vcNew][first_v1], 
                first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_vcNew][first_v2], 
                  first_j)))
         && VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v1]), 
            VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v2]))
         && VCRepOk(old(shadow.VC)[second_r := VC.bottom()][first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation FailurePreservationChecker_AtomicVC.Join_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_20_AtomicVCInit_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation CommutativityChecker_AtomicVCInit_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_r: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_r := VC.bottom()];



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicVCInit_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicVCInit_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicVCInit_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicVCInit_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_r := VC.bottom()][first_v := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v]), first_i + 1))][first_v := old(shadow.VC)[second_r := VC.bottom()][first_v := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_r := VC.bottom()][first_v := VCArraySetLen(old(shadow.VC)[second_r := VC.bottom()][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_r := VC.bottom()][first_v]), first_i + 1))][first_v][first_i])]]
       && sx.R == old(sx.R);



implementation FailurePreservationChecker_AtomicVC.Inc_20_AtomicVCInit_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable)
{

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_20_AtomicVCInit_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_r: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation GatePreservationChecker_AtomicVCInit_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_20_AtomicReleaseJoinLock_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation CommutativityChecker_AtomicVCInit_20_AtomicAllocTid_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[first_r] := VC.bottom();
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVCInit_20_AtomicAllocTid_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC == old(shadow.VC)[first_r := VC.bottom()]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_20_AtomicVCInit_20(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_r] := VC.bottom();
    return;
}



procedure CommutativityChecker_AtomicAllocTid_20_AtomicVCInit_20(first_tid: Tid, second_tid: Tid, second_r: Shadowable) returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires is#ShadowableVar(second_r) ==> sx.R[x#ShadowableVar(second_r)] != SHARED;
  requires shadow.Lock[second_r] == second_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC == old(shadow.VC)[second_r := VC.bottom()]
       && sx.R == old(sx.R)
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[second_r := VC.bottom()][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVCInit_20_AtomicAllocTid_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVCInit_20_AtomicAllocTid_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_20_AtomicStartThread_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_20_AtomicStartThread_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid) returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVCInit_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVCInit_20_AtomicReleaseChosenLock_20(first_tid: Tid, first_r: Shadowable, second_tid: Tid, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  requires shadow.Lock[first_r] == first_tid;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> is#ShadowableVar(first_r) ==> sx.R[x#ShadowableVar(first_r)] != SHARED;
  ensures true ==> shadow.Lock[first_r] == first_tid;



implementation GatePreservationChecker_AtomicVC.Leq_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_20_AtomicVarStateSetR_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_res: bool)
{

  second_anon0:
    sx.R[second_x] := second_e;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_20_AtomicVarStateSetR_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var, 
    second_e: Epoch)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires sx.R[second_x] != SHARED;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation CommutativityChecker_AtomicVC.Leq_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_res: bool)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && sx.R == old(sx.R)
           && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew]
           && (first_res
             <==> (forall first_j: int :: 
              { f(first_j) } 
              0 <= first_j && f(first_j)
                 ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1], first_j), 
                  VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v2], first_j))))
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && sx.R == old(sx.R)
         && shadow.VC == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]]
         && (first_res
           <==> (forall first_j: int :: 
            { f(first_j) } 
            0 <= first_j && f(first_j)
               ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v2], first_j)))));



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_Vnew]
           && sx.R == old(sx.R)
           && (second_res
             <==> (forall second_j: int :: 
              { f(second_j) } 
              0 <= second_j && f(second_j)
                 ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                  VCArrayGet(old(shadow.VC)[second_v2], second_j))))
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1], first_j)
                 == VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2], first_j))
           && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[first_v1]), 
              VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := old(shadow.VC)[first_v2]]
         && sx.R == old(sx.R)
         && (second_res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v2], second_j)))));



implementation CommutativityChecker_AtomicVC.Leq_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_res: bool)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && sx.R == old(sx.R)
         && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew]
         && (first_res
           <==> (forall first_j: int :: 
            { f(first_j) } 
            0 <= first_j && f(first_j)
               ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v2], first_j))))
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation CommutativityChecker_AtomicVC.Join_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_vcNew]
         && sx.R == old(sx.R)
         && (second_res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v2], second_j))))
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1], first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v2], first_j)))
         && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[first_v1]), VCArrayLen(old(shadow.VC)[first_v2]))
         && VCRepOk(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation CommutativityChecker_AtomicVC.Leq_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_res: bool)
{

  first_anon0:
    first_res := (forall first_j: int :: 
      { f(first_j) } 
      0 <= first_j && f(first_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[first_v1], first_j), 
          VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVC.Leq_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]]
       && (first_res
         <==> (forall first_j: int :: 
          { f(first_j) } 
          0 <= first_j && f(first_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1], 
                first_j), 
              VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v2], 
                first_j))));



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    second_res := (forall second_j: int :: 
      { f(second_j) } 
      0 <= second_j && f(second_j)
         ==> EpochLeq(VCArrayGet(shadow.VC[second_v1], second_j), 
          VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicVC.Leq_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (second_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires is#ShadowableVar(second_v1) ==> sx.R[x#ShadowableVar(second_v1)] == SHARED;
  requires !is#ShadowableVar(second_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v := old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i])]]
       && sx.R == old(sx.R)
       && (second_res
         <==> (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j && f(second_j)
             ==> EpochLeq(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
              VCArrayGet(old(shadow.VC)[second_v2], second_j))));



implementation GatePreservationChecker_AtomicVC.Leq_20_AtomicReleaseJoinLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_res: bool)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_20_AtomicReleaseJoinLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_20_AtomicAllocTid_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_20_AtomicAllocTid_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_20_AtomicStartThread_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_res: bool)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_20_AtomicStartThread_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (first_res: bool, second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Leq_20_AtomicReleaseChosenLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_res: bool)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Leq_20_AtomicReleaseChosenLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_l: Lock)
   returns (first_res: bool);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires is#ShadowableVar(first_v1) ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  requires !is#ShadowableVar(first_v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true
     ==> 
    is#ShadowableVar(first_v1)
     ==> sx.R[x#ShadowableVar(first_v1)] == SHARED;
  ensures true ==> !is#ShadowableVar(first_v2);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicVCGetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicVCGetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_Vnew]
           && sx.R == old(sx.R)
           && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid)
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1], first_j)
                 == VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2], first_j))
           && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[first_v1]), 
              VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (
        shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := old(shadow.VC)[first_v2]]
         && sx.R == old(sx.R)
         && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid));



implementation CommutativityChecker_AtomicVCGetElemShared_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        sx.R == old(sx.R)
           && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew]
           && shadow.Lock == old(shadow.Lock)
           && first_e
             == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableVar(first_x)], 
              first_tid)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        sx.R == old(sx.R)
         && shadow.VC == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]]
         && shadow.Lock == old(shadow.Lock)
         && first_e
           == VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableVar(first_x)], 
            first_tid));



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC, #tmp_1_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_Vnew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_Vnew][first_v2]))
           && VCRepOk(#tmp_1_first_Vnew)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (exists #tmp_0_second_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v2]]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (exists #tmp_1_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_Vnew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_Vnew][first_v2]))
           && VCRepOk(#tmp_1_first_Vnew))
       || (shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v2]]);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation FailurePreservationChecker_AtomicVC.Copy_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC, #tmp_1_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_Vnew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_Vnew][first_v2]))
           && VCRepOk(#tmp_1_first_Vnew)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
                 == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                  VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
           && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]))
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v2]]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
                 == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                  VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
           && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation CommutativityChecker_AtomicVC.Join_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC, #tmp_1_first_vcNew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_vcNew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_vcNew][first_v1], 
                  first_j)
                 == EpochMax(VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1], first_j), 
                  VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_vcNew][first_v2], 
                    first_j)))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_vcNew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v2]))
           && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v1 := #tmp_1_first_vcNew][first_v1])
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (exists #tmp_1_first_vcNew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_vcNew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_vcNew][first_v1], 
                  first_j)
                 == EpochMax(VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1], first_j), 
                  VCArrayGet(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_vcNew][first_v2], 
                    first_j)))
           && VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_vcNew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v2]))
           && VCRepOk(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v1 := #tmp_1_first_vcNew][first_v1]));



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation FailurePreservationChecker_AtomicVC.Join_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_Vnew]
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                      max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_Vnew][first_v1], 
                  first_j)
                 == VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                      max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_Vnew][first_v2], 
                  first_j))
           && VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1]), 
              VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew))
       || (shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v2]]);



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)
           && shadow.VC
             == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v]), 
                first_i + 1))][first_v := old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v]), 
                first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v], 
                max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][first_v]), 
                  first_i + 1))][first_v][first_i])]]
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v]), 
              first_i + 1))][first_v := old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v]), 
              first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][first_v]), 
                first_i + 1))][first_v][first_i])]]);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation FailurePreservationChecker_AtomicVC.Inc_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_20_AtomicVC.Copy_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicReleaseJoinLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicReleaseJoinLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Copy_20_AtomicAllocTid_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid)
{
  var first_Vnew: VC;
  var first_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    goto first_anon3_Then, first_anon3_Else;

  first_anon3_Else:
    shadow.VC[first_v1] := shadow.VC[first_v2];
    goto second_anon0;

  first_anon3_Then:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_Vnew;
    assume VCRepOk(first_Vnew);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), VCArrayLen(shadow.VC[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == VCArrayGet(shadow.VC[first_v2], first_j));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVC.Copy_20_AtomicAllocTid_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_Vnew: VC :: 
        shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
           && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_Vnew]
           && thread.State == old(thread.State)[second_uid := NEW()]
           && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
           && second_uid == second_uid
           && (forall first_j: int :: 
            0 <= first_j
               ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1], first_j)
                 == VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2], first_j))
           && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v1])
             == max(VCArrayLen(old(shadow.VC)[first_v1]), 
              VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_Vnew][first_v2]))
           && VCRepOk(#tmp_0_first_Vnew)
           && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
           && old(thread.State)[second_uid] == UNUSED()
           && ValidTid(second_uid)
           && second_tid != second_uid)
       || (
        shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
         && shadow.VC == old(shadow.VC)[first_v1 := old(shadow.VC)[first_v2]]
         && thread.State == old(thread.State)[second_uid := NEW()]
         && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
         && second_uid == second_uid
         && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
         && old(thread.State)[second_uid] == UNUSED()
         && ValidTid(second_uid)
         && second_tid != second_uid);



implementation CommutativityChecker_AtomicAllocTid_20_AtomicVC.Copy_20(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_uid: Tid)
{
  var second_Vnew: VC;
  var second_shadow.VC.old: [Shadowable]VC;

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    goto second_anon3_Then, second_anon3_Else;

  second_anon3_Else:
    shadow.VC[second_v1] := shadow.VC[second_v2];
    return;

  second_anon3_Then:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_Vnew;
    assume VCRepOk(second_Vnew);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), VCArrayLen(shadow.VC[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == VCArrayGet(shadow.VC[second_v2], second_j));
    return;
}



procedure CommutativityChecker_AtomicAllocTid_20_AtomicVC.Copy_20(first_tid: Tid, second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_Vnew: VC :: 
        thread.State == old(thread.State)[first_uid := NEW()]
           && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
           && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
           && shadow.VC == old(shadow.VC)[second_v1 := #tmp_0_second_Vnew]
           && first_uid == first_uid
           && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][ShadowableTid(first_uid)])
           && old(thread.State)[first_uid] == UNUSED()
           && ValidTid(first_uid)
           && first_tid != first_uid
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1], second_j)
                 == VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2], second_j))
           && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v1])
             == max(VCArrayLen(old(shadow.VC)[second_v1]), 
              VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_Vnew][second_v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        thread.State == old(thread.State)[first_uid := NEW()]
         && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
         && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
         && shadow.VC == old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]]
         && first_uid == first_uid
         && VCRepOk(old(shadow.VC)[second_v1 := old(shadow.VC)[second_v2]][ShadowableTid(first_uid)])
         && old(thread.State)[first_uid] == UNUSED()
         && ValidTid(first_uid)
         && first_tid != first_uid);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicAllocTid_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicAllocTid_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicStartThread_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicStartThread_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation GatePreservationChecker_AtomicVC.Copy_20_AtomicReleaseChosenLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Copy_20_AtomicReleaseChosenLock_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires first_v1 != first_v2;
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires VCRepOk(shadow.VC[first_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> first_v1 != first_v2;
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);
  ensures true ==> VCRepOk(shadow.VC[first_v1]);



implementation CommutativityChecker_AtomicVC.Join_20_AtomicVCGetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicVCGetElemShared_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_vcNew]
         && sx.R == old(sx.R)
         && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid)
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1], first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v2], first_j)))
         && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[first_v1]), VCArrayLen(old(shadow.VC)[first_v2]))
         && VCRepOk(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation CommutativityChecker_AtomicVC.Join_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC, #tmp_1_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_vcNew]
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_vcNew][first_v1], 
                first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_vcNew][first_v2], 
                  first_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1]), 
            VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v1 := #tmp_1_first_vcNew][first_v1])
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation CommutativityChecker_AtomicVC.Join_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_vcNew]
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_vcNew][first_v1], 
                first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                      max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1], 
                  first_j), 
                VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                      max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_vcNew][first_v2], 
                  first_j)))
         && VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1]), 
            VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v2]))
         && VCRepOk(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v1 := #tmp_0_first_vcNew][first_v1]));



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Join_20_AtomicAllocTid_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid)
{
  var first_shadow.VC.old: [Shadowable]VC;
  var first_vcNew: VC;

  first_anon0:
    first_shadow.VC.old := shadow.VC;
    shadow.VC[first_v1] := first_vcNew;
    assume VCRepOk(shadow.VC[first_v1]);
    assume VCArrayLen(shadow.VC[first_v1])
       == max(VCArrayLen(first_shadow.VC.old[first_v1]), 
        VCArrayLen(first_shadow.VC.old[first_v2]));
    assume (forall first_j: int :: 
      0 <= first_j
         ==> VCArrayGet(shadow.VC[first_v1], first_j)
           == EpochMax(VCArrayGet(first_shadow.VC.old[first_v1], first_j), 
            VCArrayGet(shadow.VC[first_v2], first_j)));
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVC.Join_20_AtomicAllocTid_20(first_tid: Tid, first_v1: Shadowable, first_v2: Shadowable, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_first_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
         && shadow.VC == old(shadow.VC)[first_v1 := #tmp_0_first_vcNew]
         && thread.State == old(thread.State)[second_uid := NEW()]
         && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
         && second_uid == second_uid
         && (forall first_j: int :: 
          0 <= first_j
             ==> VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1], first_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[first_v1], first_j), 
                VCArrayGet(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v2], first_j)))
         && VCArrayLen(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
           == max(VCArrayLen(old(shadow.VC)[first_v1]), VCArrayLen(old(shadow.VC)[first_v2]))
         && VCRepOk(old(shadow.VC)[first_v1 := #tmp_0_first_vcNew][first_v1])
         && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
         && old(thread.State)[second_uid] == UNUSED()
         && ValidTid(second_uid)
         && second_tid != second_uid);



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
{

  second_anon0:
    shadow.Lock[ShadowableVar(second_x)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicReleaseVarLock_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableVar(second_x)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicVCGetElemShared_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    second_e := VCArrayGet(shadow.VC[ShadowableVar(second_x)], second_tid);
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicVCGetElemShared_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_x: Var)
   returns (second_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires sx.R[second_x] == SHARED;
  requires ValidTid(second_tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v := old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i])]]
       && sx.R == old(sx.R)
       && second_e == VCArrayGet(old(shadow.VC)[ShadowableVar(second_x)], second_tid);



implementation CommutativityChecker_AtomicVCGetElemShared_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_e: Epoch)
{

  first_anon0:
    first_e := VCArrayGet(shadow.VC[ShadowableVar(first_x)], first_tid);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVCGetElemShared_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_x: Var, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
   returns (first_e: Epoch);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires sx.R[first_x] == SHARED;
  requires ValidTid(first_tid);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> sx.R == old(sx.R)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]]
       && shadow.Lock == old(shadow.Lock)
       && first_e
         == VCArrayGet(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableVar(first_x)], 
          first_tid);



implementation FailurePreservationChecker_AtomicVC.Copy_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure FailurePreservationChecker_AtomicVC.Copy_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && first_v1 != first_v2
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2])
     && VCRepOk(shadow.VC[first_v1]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && first_v1 != first_v2
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2])
       && VCRepOk(shadow.VC[first_v1]));



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable)
{
  var second_shadow.VC.old: [Shadowable]VC;
  var second_vcNew: VC;

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    second_shadow.VC.old := shadow.VC;
    shadow.VC[second_v1] := second_vcNew;
    assume VCRepOk(shadow.VC[second_v1]);
    assume VCArrayLen(shadow.VC[second_v1])
       == max(VCArrayLen(second_shadow.VC.old[second_v1]), 
        VCArrayLen(second_shadow.VC.old[second_v2]));
    assume (forall second_j: int :: 
      0 <= second_j
         ==> VCArrayGet(shadow.VC[second_v1], second_j)
           == EpochMax(VCArrayGet(second_shadow.VC.old[second_v1], second_j), 
            VCArrayGet(shadow.VC[second_v2], second_j)));
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicVC.Join_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v1: Shadowable, 
    second_v2: Shadowable);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> (exists #tmp_0_second_vcNew: VC :: 
      shadow.Lock == old(shadow.Lock)
         && shadow.VC
           == old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v]), 
              first_i + 1))][first_v := old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v]), 
              first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v := VCArraySetLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v], 
              max(VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][first_v]), 
                first_i + 1))][first_v][first_i])]]
         && (forall second_j: int :: 
          0 <= second_j
             ==> VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1], second_j)
               == EpochMax(VCArrayGet(old(shadow.VC)[second_v1], second_j), 
                VCArrayGet(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v2], second_j)))
         && VCArrayLen(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1])
           == max(VCArrayLen(old(shadow.VC)[second_v1]), VCArrayLen(old(shadow.VC)[second_v2]))
         && VCRepOk(old(shadow.VC)[second_v1 := #tmp_0_second_vcNew][second_v1]));



implementation GatePreservationChecker_AtomicVC.Join_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure GatePreservationChecker_AtomicVC.Join_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v1] == first_tid;
  requires shadow.Lock[first_v2] == first_tid;
  requires !is#ShadowableVar(first_v1);
  requires !is#ShadowableVar(first_v2);
  requires VCRepOk(shadow.VC[first_v2]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v1] == first_tid;
  ensures true ==> shadow.Lock[first_v2] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v1);
  ensures true ==> !is#ShadowableVar(first_v2);
  ensures true ==> VCRepOk(shadow.VC[first_v2]);



implementation FailurePreservationChecker_AtomicVC.Join_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure FailurePreservationChecker_AtomicVC.Join_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v1: Shadowable, 
    first_v2: Shadowable, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v1] == first_tid
     && shadow.Lock[first_v2] == first_tid
     && !is#ShadowableVar(first_v1)
     && !is#ShadowableVar(first_v2)
     && VCRepOk(shadow.VC[first_v2]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v1] == first_tid
       && shadow.Lock[first_v2] == first_tid
       && !is#ShadowableVar(first_v1)
       && !is#ShadowableVar(first_v2)
       && VCRepOk(shadow.VC[first_v2]));



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v := VCArraySetLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v]), 
            first_i + 1))][first_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v := VCArraySetLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v], 
          max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v]), 
            first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v := VCArraySetLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
              max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v], 
            max(VCArrayLen(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                  max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
                    max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][first_v]), 
              first_i + 1))][first_v][first_i])]];



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation FailurePreservationChecker_AtomicVC.Inc_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int)
{

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure FailurePreservationChecker_AtomicVC.Inc_20_AtomicVC.Inc_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_v: Shadowable, 
    second_i: int);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires !(
    ValidTid(first_tid)
     && shadow.Lock[ShadowableTid(first_tid)] == first_tid
     && shadow.Lock[first_v] == first_tid
     && !is#ShadowableVar(first_v)
     && first_i >= 0
     && VCRepOk(shadow.VC[first_v]));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> !(
      ValidTid(first_tid)
       && shadow.Lock[ShadowableTid(first_tid)] == first_tid
       && shadow.Lock[first_v] == first_tid
       && !is#ShadowableVar(first_v)
       && first_i >= 0
       && VCRepOk(shadow.VC[first_v]));



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicReleaseJoinLock_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    shadow.Lock[ShadowableTid(second_uid)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicReleaseJoinLock_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == STOPPED() && ValidTid(second_uid);
    assume shadow.Lock[ShadowableTid(second_uid)] == nil;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    thread.HasJoined[second_tid, second_uid] := true;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicChooseThreadToJoin_20(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation CommutativityChecker_AtomicVC.Inc_20_AtomicAllocTid_20(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid)
{

  first_anon0:
    shadow.VC[first_v] := VCArraySetLen(shadow.VC[first_v], max(VCArrayLen(shadow.VC[first_v]), first_i + 1));
    shadow.VC[first_v] := shadow.VC[first_v][first_i := EpochInc(shadow.VC[first_v][first_i])];
    goto second_anon0;

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure CommutativityChecker_AtomicVC.Inc_20_AtomicAllocTid_20(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> shadow.Lock == old(shadow.Lock)[ShadowableTid(second_uid) := second_tid]
       && shadow.VC
         == old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v := old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i := EpochInc(old(shadow.VC)[first_v := VCArraySetLen(old(shadow.VC)[first_v], max(VCArrayLen(old(shadow.VC)[first_v]), first_i + 1))][first_v][first_i])]]
       && thread.State == old(thread.State)[second_uid := NEW()]
       && thread.ForkedBy == old(thread.ForkedBy)[second_uid := second_tid]
       && second_uid == second_uid
       && VCRepOk(old(shadow.VC)[ShadowableTid(second_uid)])
       && old(thread.State)[second_uid] == UNUSED()
       && ValidTid(second_uid)
       && second_tid != second_uid;



implementation CommutativityChecker_AtomicAllocTid_20_AtomicVC.Inc_20(first_tid: Tid, second_tid: Tid, second_v: Shadowable, second_i: int)
   returns (first_uid: Tid)
{

  first_anon0:
    assume first_tid != first_uid;
    assume thread.State[first_uid] == UNUSED() && ValidTid(first_uid);
    thread.State[first_uid] := NEW();
    thread.ForkedBy[first_uid] := first_tid;
    shadow.Lock[ShadowableTid(first_uid)] := first_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(first_uid)]);
    goto second_anon0;

  second_anon0:
    shadow.VC[second_v] := VCArraySetLen(shadow.VC[second_v], max(VCArrayLen(shadow.VC[second_v]), second_i + 1));
    shadow.VC[second_v] := shadow.VC[second_v][second_i := EpochInc(shadow.VC[second_v][second_i])];
    return;
}



procedure CommutativityChecker_AtomicAllocTid_20_AtomicVC.Inc_20(first_tid: Tid, second_tid: Tid, second_v: Shadowable, second_i: int)
   returns (first_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[first_tid] == RUNNING() && ValidTid(first_tid);
  requires (forall first_t: Tid :: 
    thread.State[first_t] == UNUSED() ==> shadow.Lock[ShadowableTid(first_t)] == nil);
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v] == second_tid;
  requires !is#ShadowableVar(second_v);
  requires second_i >= 0;
  requires VCRepOk(shadow.VC[second_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true
     ==> thread.State == old(thread.State)[first_uid := NEW()]
       && shadow.Lock == old(shadow.Lock)[ShadowableTid(first_uid) := first_tid]
       && thread.ForkedBy == old(thread.ForkedBy)[first_uid := first_tid]
       && shadow.VC
         == old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]]
       && first_uid == first_uid
       && VCRepOk(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v := old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
          max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i := EpochInc(old(shadow.VC)[second_v := VCArraySetLen(old(shadow.VC)[second_v], 
            max(VCArrayLen(old(shadow.VC)[second_v]), second_i + 1))][second_v][second_i])]][ShadowableTid(first_uid)])
       && old(thread.State)[first_uid] == UNUSED()
       && ValidTid(first_uid)
       && first_tid != first_uid;



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicAllocTid_20(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid)
{

  second_anon0:
    assume second_tid != second_uid;
    assume thread.State[second_uid] == UNUSED() && ValidTid(second_uid);
    thread.State[second_uid] := NEW();
    thread.ForkedBy[second_uid] := second_tid;
    shadow.Lock[ShadowableTid(second_uid)] := second_tid;
    assume VCRepOk(shadow.VC[ShadowableTid(second_uid)]);
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicAllocTid_20(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires thread.State[second_tid] == RUNNING() && ValidTid(second_tid);
  requires (forall second_t: Tid :: 
    thread.State[second_t] == UNUSED()
       ==> shadow.Lock[ShadowableTid(second_t)] == nil);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicStartThread_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid)
{

  second_anon0:
    thread.State[second_uid] := RUNNING();
    shadow.Lock[ShadowableTid(second_uid)] := second_uid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicStartThread_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_uid: Tid);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(second_uid);
  requires second_tid != second_uid;
  requires shadow.Lock[ShadowableTid(second_uid)] == second_tid;
  requires thread.State[second_uid] == NEW();
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_l: Lock)
{

  second_anon0:
    assume shadow.Lock[ShadowableLock(second_l)] == nil;
    shadow.Lock[ShadowableLock(second_l)] := second_tid;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicChooseLockToAcquire_20(first_tid: Tid, first_v: Shadowable, first_i: int, second_tid: Tid)
   returns (second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation GatePreservationChecker_AtomicVC.Inc_20_AtomicReleaseChosenLock_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock)
{

  second_anon0:
    shadow.Lock[ShadowableLock(second_l)] := nil;
    return;
}



procedure GatePreservationChecker_AtomicVC.Inc_20_AtomicReleaseChosenLock_20(first_tid: Tid, 
    first_v: Shadowable, 
    first_i: int, 
    second_tid: Tid, 
    second_l: Lock);
  requires (exists partition_tid: [Tid]int :: 
    linear_tid_MapImp(TidCollector(first_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
         == linear_tid_MapConstBool(true)
       && linear_tid_MapImp(TidCollector(second_tid), 
          linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
         == linear_tid_MapConstBool(true));
  requires ValidTid(second_tid);
  requires shadow.Lock[ShadowableLock(second_l)] == second_tid;
  requires ValidTid(first_tid);
  requires shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  requires shadow.Lock[first_v] == first_tid;
  requires !is#ShadowableVar(first_v);
  requires first_i >= 0;
  requires VCRepOk(shadow.VC[first_v]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures true ==> ValidTid(first_tid);
  ensures true ==> shadow.Lock[ShadowableTid(first_tid)] == first_tid;
  ensures true ==> shadow.Lock[first_v] == first_tid;
  ensures true ==> !is#ShadowableVar(first_v);
  ensures true ==> first_i >= 0;
  ensures true ==> VCRepOk(shadow.VC[first_v]);



implementation NonBlockingChecker_AtomicVC.Copy_20(second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable)
{

  L:
    assert true;
    return;
}



procedure NonBlockingChecker_AtomicVC.Copy_20(second_tid: Tid, second_v1: Shadowable, second_v2: Shadowable);
  requires true;
  requires ValidTid(second_tid);
  requires second_v1 != second_v2;
  requires shadow.Lock[ShadowableTid(second_tid)] == second_tid;
  requires shadow.Lock[second_v1] == second_tid;
  requires shadow.Lock[second_v2] == second_tid;
  requires !is#ShadowableVar(second_v1);
  requires !is#ShadowableVar(second_v2);
  requires VCRepOk(shadow.VC[second_v2]);
  requires VCRepOk(shadow.VC[second_v1]);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure {:inline 1} skip_dummy_Yield10(tid: Tid);



implementation {:inline 1} skip_dummy_Yield10(tid: Tid)
{

  _init:
    return;
}



procedure {:inline 1} skip_dummy_Yield20(tid: Tid);



implementation {:inline 1} skip_dummy_Yield20(tid: Tid)
{

  _init:
    return;
}



procedure {:inline 1} skip_dummy_Yield30(tid: Tid);



implementation {:inline 1} skip_dummy_Yield30(tid: Tid)
{

  _init:
    return;
}



procedure {:inline 1} skip_dummy_Driver(tid: Tid) returns (ok: bool);



implementation {:inline 1} skip_dummy_Driver(tid: Tid) returns (ok: bool)
{

  _init:
    return;
}



procedure AcquireVarLock_0(tid: Tid, x: Var);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure ReleaseVarLock_0(tid: Tid, x: Var);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure ThreadStateGetE_0(tid: Tid) returns (e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VarStateSetW_0(tid: Tid, x: Var, e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VarStateGetW_0(tid: Tid, x: Var) returns (e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VarStateGetWNoLock_0(tid: Tid, x: Var) returns (e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VarStateSetR_0(tid: Tid, x: Var, e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VarStateGetRNoLock_0(tid: Tid, x: Var) returns (e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VarStateGetR_0(tid: Tid, x: Var) returns (e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VarStateGetRShared_0(tid: Tid, x: Var) returns (e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VCGetSize_0(tid: Tid, r: Shadowable) returns (i: int);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VCGetElem_0(tid: Tid, r: Shadowable, i: int) returns (e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VCGetElemShared_0(tid: Tid, x: Var) returns (e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VCSetElemShared_0(tid: Tid, x: Var, e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VCSetElem_0(tid: Tid, r: Shadowable, i: int, e: Epoch);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VCInit_0(tid: Tid, r: Shadowable);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure Yield10_0(tid: Tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VC.Leq_0(tid: Tid, v1: Shadowable, v2: Shadowable) returns (res: bool);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VC.Copy_0(tid: Tid, v1: Shadowable, v2: Shadowable);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VC.Join_0(tid: Tid, v1: Shadowable, v2: Shadowable);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure VC.Inc_0(tid: Tid, v: Shadowable, i: int);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure Yield20_0(tid: Tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure Fork_0(tid: Tid, uid: Tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure Join_0(tid: Tid, uid: Tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure Acquire_0(tid: Tid, l: Lock);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure Release_0(tid: Tid, l: Lock);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure Write_0(tid: Tid, x: Var) returns (ok: bool);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure Read_0(tid: Tid, x: Var) returns (ok: bool);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure Yield30_0(tid: Tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure Driver_0(tid: Tid) returns (ok: bool);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure ReleaseJoinLock_0(tid: Tid, uid: Tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure ChooseThreadToJoin_0(tid: Tid) returns (uid: Tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure AllocTid_0(tid: Tid) returns (uid: Tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure StartThread_0(tid: Tid, uid: Tid);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure ChooseLockToAcquire_0(tid: Tid) returns (l: Lock);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure ChooseLockToRelease_0(tid: Tid) returns (l: Lock);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



procedure ReleaseChosenLock_0(tid: Tid, l: Lock);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



implementation Yield10_0(tid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    yield;
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon01, CallToYieldProc;

  anon05:
    return;

  anon01:
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon05, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation VC.Leq_0(tid: Tid, v1: Shadowable, v2: Shadowable) returns (res: bool)
{
  var vc1: VC;
  var vc2: VC;
  var len1: int;
  var len2: int;
  var e1: Epoch;
  var e2: Epoch;
  var i: int;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield10(tid);
    call len1 := VCGetSize(tid, v1);
    call len2 := VCGetSize(tid, v1);
    i := 0;
    while (i < max(len1, len2))
      invariant 0 <= i;
      invariant (forall j: int :: 
        { f(j) } 
        0 <= j && j < i && f(j)
           ==> EpochLeq(VCArrayGet(shadow.VC[v1], j), VCArrayGet(shadow.VC[v2], j)));
    {
        call e1 := VCGetElem(tid, v1, i);
        call e2 := VCGetElem(tid, v2, i);
        if (!EpochLeq(e1, e2))
        {
            assert f(i);
            res := false;
            call Yield10(tid);
            return;
        }

        i := i + 1;
    }

    res := true;
    call Yield10(tid);
    return;
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon5_LoopHead:
    assume linear_tid_available
       == linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false));
    assume shadow.VC == og_global_old_shadow.VC;
    assume shadow.Lock == og_global_old_shadow.Lock;
    assume sx.W == og_global_old_sx.W;
    assume sx.R == og_global_old_sx.R;
    assume thread.State == og_global_old_thread.State;
    assume thread.ForkedBy == og_global_old_thread.ForkedBy;
    assume thread.HasJoined == og_global_old_thread.HasJoined;
    assume pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon5_LoopDone, anon5_LoopBody;

  anon5_LoopBody:
    assume {:partition} i < max(len1, len2);
    goto anon5_LoopBody1, CallToYieldProc;

  anon6_Else:
    assume {:partition} EpochLeq(e1, e2);
    goto anon3;

  anon3:
    i := i + 1;
    goto anon31, CallToYieldProc;

  anon6_Then:
    assume {:partition} !EpochLeq(e1, e2);
    res := false;
    goto anon6_Then2, CallToYieldProc;

  anon5_LoopDone:
    assume {:partition} max(len1, len2) <= i;
    goto anon4;

  anon4:
    res := true;
    goto anon41, CallToYieldProc;

  anon013:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon5_LoopHead;

  anon08:
    call len2 := VCGetSize_0(tid, v1);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    i := 0;
    goto anon013, CallToYieldProc;

  anon04:
    call len1 := VCGetSize_0(tid, v1);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield10_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  anon5_LoopBody5:
    call e2 := VCGetElem_0(tid, v2, i);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon6_Then, anon6_Else;

  anon5_LoopBody1:
    call e1 := VCGetElem_0(tid, v1, i);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon5_LoopBody5, CallToYieldProc;

  anon31:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon5_LoopHead;

  anon6_Then6:
    return;

  anon6_Then2:
    call Yield10_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon6_Then6, CallToYieldProc;

  anon45:
    return;

  anon41:
    call Yield10_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon45, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation VC.Copy_0(tid: Tid, v1: Shadowable, v2: Shadowable)
{
  var len1: int;
  var len2: int;
  var e1: Epoch;
  var e2: Epoch;
  var i: int;
  var oldVC: [Shadowable][Tid]Epoch;
  var oldLock: [Shadowable]Tid;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield10(tid);
    call oldLock, oldVC := GhostRead();
    call len1 := VCGetSize(tid, v1);
    call len2 := VCGetSize(tid, v2);
    i := 0;
    while (i < max(len1, len2))
      invariant (forall s: Shadowable :: s != v1 ==> shadow.VC[s] == oldVC[s]);
      invariant (forall s: Shadowable :: oldLock[s] == tid ==> shadow.Lock[s] == tid);
      invariant VCRepOk(shadow.VC[v1]);
      invariant i >= 0;
      invariant i <= max(len1, len2);
      invariant VCArrayLen(shadow.VC[v1]) == max(len1, i);
      invariant (forall j: int :: 
        0 <= j && j < i ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
      invariant (forall j: int :: 
        max(len1, len2) <= j
           ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    {
        call e2 := VCGetElem(tid, v2, i);
        call VCSetElem(tid, v1, i, e2);
        i := i + 1;
    }

    call Yield10(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon3_LoopHead:
    assume linear_tid_available
       == linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false));
    assume shadow.VC == og_global_old_shadow.VC;
    assume shadow.Lock == og_global_old_shadow.Lock;
    assume sx.W == og_global_old_sx.W;
    assume sx.R == og_global_old_sx.R;
    assume thread.State == og_global_old_thread.State;
    assume thread.ForkedBy == og_global_old_thread.ForkedBy;
    assume thread.HasJoined == og_global_old_thread.HasJoined;
    assume pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon3_LoopDone, anon3_LoopBody;

  anon3_LoopBody:
    assume {:partition} i < max(len1, len2);
    goto anon3_LoopBody1, CallToYieldProc;

  anon3_LoopDone:
    assume {:partition} max(len1, len2) <= i;
    goto anon2;

  anon2:
    goto anon20, CallToYieldProc;

  anon014:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon3_LoopHead;

  anon09:
    call len2 := VCGetSize_0(tid, v2);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    i := 0;
    goto anon014, CallToYieldProc;

  anon05:
    call len1 := VCGetSize_0(tid, v1);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon09, CallToYieldProc;

  anon00:
    call Yield10_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon05, CallToYieldProc;

  anon3_LoopBody10:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon3_LoopHead;

  anon3_LoopBody5:
    call VCSetElem_0(tid, v1, i, e2);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    i := i + 1;
    goto anon3_LoopBody10, CallToYieldProc;

  anon3_LoopBody1:
    call e2 := VCGetElem_0(tid, v2, i);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon3_LoopBody5, CallToYieldProc;

  anon24:
    return;

  anon20:
    call Yield10_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon24, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation VC.Join_0(tid: Tid, v1: Shadowable, v2: Shadowable)
{
  var len1: int;
  var len2: int;
  var e1: Epoch;
  var e2: Epoch;
  var i: int;
  var oldVC: [Shadowable][Tid]Epoch;
  var oldLock: [Shadowable]Tid;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield10(tid);
    call oldLock, oldVC := GhostRead();
    call len1 := VCGetSize(tid, v1);
    call len2 := VCGetSize(tid, v2);
    i := 0;
    while (i < max(len1, len2))
      invariant (forall s: Shadowable :: s != v1 ==> shadow.VC[s] == oldVC[s]);
      invariant (forall s: Shadowable :: oldLock[s] == tid ==> shadow.Lock[s] == tid);
      invariant VCRepOk(shadow.VC[v1]);
      invariant i >= 0;
      invariant i <= max(len1, len2);
      invariant VCArrayLen(shadow.VC[v1]) == max(len1, i);
      invariant (forall j: int :: 
        0 <= j && i <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(oldVC[v1], j));
      invariant (forall j: int :: 
        0 <= j && j < i
           ==> VCArrayGet(shadow.VC[v1], j)
             == EpochMax(VCArrayGet(oldVC[v1], j), VCArrayGet(shadow.VC[v2], j)));
    {
        call e1 := VCGetElem(tid, v1, i);
        call e2 := VCGetElem(tid, v2, i);
        call VCSetElem(tid, v1, i, EpochMax(e1, e2));
        i := i + 1;
    }

    call Yield10(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon3_LoopHead:
    assume linear_tid_available
       == linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false));
    assume shadow.VC == og_global_old_shadow.VC;
    assume shadow.Lock == og_global_old_shadow.Lock;
    assume sx.W == og_global_old_sx.W;
    assume sx.R == og_global_old_sx.R;
    assume thread.State == og_global_old_thread.State;
    assume thread.ForkedBy == og_global_old_thread.ForkedBy;
    assume thread.HasJoined == og_global_old_thread.HasJoined;
    assume pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon3_LoopDone, anon3_LoopBody;

  anon3_LoopBody:
    assume {:partition} i < max(len1, len2);
    goto anon3_LoopBody1, CallToYieldProc;

  anon3_LoopDone:
    assume {:partition} max(len1, len2) <= i;
    goto anon2;

  anon2:
    goto anon20, CallToYieldProc;

  anon014:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon3_LoopHead;

  anon09:
    call len2 := VCGetSize_0(tid, v2);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    i := 0;
    goto anon014, CallToYieldProc;

  anon05:
    call len1 := VCGetSize_0(tid, v1);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon09, CallToYieldProc;

  anon00:
    call Yield10_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon05, CallToYieldProc;

  anon3_LoopBody14:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon3_LoopHead;

  anon3_LoopBody9:
    call VCSetElem_0(tid, v1, i, EpochMax(e1, e2));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    i := i + 1;
    goto anon3_LoopBody14, CallToYieldProc;

  anon3_LoopBody5:
    call e2 := VCGetElem_0(tid, v2, i);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon3_LoopBody9, CallToYieldProc;

  anon3_LoopBody1:
    call e1 := VCGetElem_0(tid, v1, i);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon3_LoopBody5, CallToYieldProc;

  anon24:
    return;

  anon20:
    call Yield10_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon24, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation VC.Inc_0(tid: Tid, v: Shadowable, i: int)
{
  var e: Epoch;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield10(tid);
    call e := VCGetElem(tid, v, i);
    call VCSetElem(tid, v, i, EpochInc(e));
    call Yield10(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon016:
    return;

  anon012:
    call Yield10_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon016, CallToYieldProc;

  anon08:
    call VCSetElem_0(tid, v, i, EpochInc(e));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon012, CallToYieldProc;

  anon04:
    call e := VCGetElem_0(tid, v, i);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield10_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Yield20_0(tid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    yield;
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon01, CallToYieldProc;

  anon05:
    return;

  anon01:
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon05, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Fork_0(tid: Tid, uid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Join(tid, ShadowableTid(uid), ShadowableTid(tid));
    call VC.Inc(tid, ShadowableTid(tid), tid);
    call Yield20(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon016:
    return;

  anon012:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon016, CallToYieldProc;

  anon08:
    call VC.Inc_0(tid, ShadowableTid(tid), tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon012, CallToYieldProc;

  anon04:
    call VC.Join_0(tid, ShadowableTid(uid), ShadowableTid(tid));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Join_0(tid: Tid, uid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Join(tid, ShadowableTid(tid), ShadowableTid(uid));
    call Yield20(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon012:
    return;

  anon08:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon012, CallToYieldProc;

  anon04:
    call VC.Join_0(tid, ShadowableTid(tid), ShadowableTid(uid));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Acquire_0(tid: Tid, l: Lock)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Join(tid, ShadowableTid(tid), ShadowableLock(l));
    call Yield20(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon012:
    return;

  anon08:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon012, CallToYieldProc;

  anon04:
    call VC.Join_0(tid, ShadowableTid(tid), ShadowableLock(l));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Release_0(tid: Tid, l: Lock)
{
  var sm: Shadowable;
  var st: Shadowable;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Copy(tid, ShadowableLock(l), ShadowableTid(tid));
    call VC.Inc(tid, ShadowableTid(tid), tid);
    call Yield20(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon016:
    return;

  anon012:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon016, CallToYieldProc;

  anon08:
    call VC.Inc_0(tid, ShadowableTid(tid), tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon012, CallToYieldProc;

  anon04:
    call VC.Copy_0(tid, ShadowableLock(l), ShadowableTid(tid));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Write_0(tid: Tid, x: Var) returns (ok: bool)
{
  var e: Epoch;
  var w: Epoch;
  var vw: Epoch;
  var r: Epoch;
  var vr: Epoch;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call e := ThreadStateGetE(tid);
    call w := VarStateGetWNoLock(tid, x);
    if (w == e)
    {
        ok := true;
        call Yield20(tid);
        return;
    }

    call Yield20(tid);
    call AcquireVarLock(tid, x);
    call w := VarStateGetW(tid, x);
    call vw := VCGetElem(tid, ShadowableTid(tid), tid#epoch(w));
    if (!EpochLeq(w, vw))
    {
        call ReleaseVarLock(tid, x);
        ok := false;
        call Yield20(tid);
        return;
    }

    call r := VarStateGetR(tid, x);
    if (r != SHARED)
    {
        call vr := VCGetElem(tid, ShadowableTid(tid), tid#epoch(r));
        if (!EpochLeq(r, vr))
        {
            call ReleaseVarLock(tid, x);
            ok := false;
            call Yield20(tid);
            return;
        }

        call VarStateSetW(tid, x, e);
    }
    else
    {
        call ok := VC.Leq(tid, ShadowableVar(x), ShadowableTid(tid));
        if (!ok)
        {
            call ReleaseVarLock(tid, x);
            ok := false;
            call Yield20(tid);
            return;
        }

        call VarStateSetW(tid, x, e);
    }

    call ReleaseVarLock(tid, x);
    ok := true;
    call Yield20(tid);
    return;
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon12_Else:
    assume {:partition} w != e;
    goto anon2;

  anon2:
    goto anon20, CallToYieldProc;

  anon13_Else:
    assume {:partition} EpochLeq(w, vw);
    goto anon4;

  anon4:
    goto anon40, CallToYieldProc;

  anon14_Else:
    assume {:partition} r == SHARED;
    goto anon14_Else1, CallToYieldProc;

  anon16_Else:
    assume {:partition} ok;
    goto anon10;

  anon10:
    goto anon100, CallToYieldProc;

  anon11:
    goto anon110, CallToYieldProc;

  anon16_Then:
    assume {:partition} !ok;
    goto anon16_Then1, CallToYieldProc;

  anon14_Then:
    assume {:partition} r != SHARED;
    goto anon14_Then1, CallToYieldProc;

  anon15_Else:
    assume {:partition} EpochLeq(r, vr);
    goto anon7;

  anon7:
    goto anon70, CallToYieldProc;

  anon15_Then:
    assume {:partition} !EpochLeq(r, vr);
    goto anon15_Then1, CallToYieldProc;

  anon13_Then:
    assume {:partition} !EpochLeq(w, vw);
    goto anon13_Then1, CallToYieldProc;

  anon12_Then:
    assume {:partition} w == e;
    ok := true;
    goto anon12_Then2, CallToYieldProc;

  anon08:
    call w := VarStateGetWNoLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon12_Then, anon12_Else;

  anon04:
    call e := ThreadStateGetE_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  anon212:
    call vw := VCGetElem_0(tid, ShadowableTid(tid), tid#epoch(w));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then, anon13_Else;

  anon28:
    call w := VarStateGetW_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon212, CallToYieldProc;

  anon24:
    call AcquireVarLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon28, CallToYieldProc;

  anon20:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon24, CallToYieldProc;

  anon40:
    call r := VarStateGetR_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then, anon14_Else;

  anon14_Else1:
    call ok := VC.Leq_0(tid, ShadowableVar(x), ShadowableTid(tid));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Then, anon16_Else;

  anon100:
    call VarStateSetW_0(tid, x, e);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon11;

  anon119:
    return;

  anon115:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon119, CallToYieldProc;

  anon110:
    call ReleaseVarLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon115, CallToYieldProc;

  anon16_Then10:
    return;

  anon16_Then6:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Then10, CallToYieldProc;

  anon16_Then1:
    call ReleaseVarLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon16_Then6, CallToYieldProc;

  anon14_Then1:
    call vr := VCGetElem_0(tid, ShadowableTid(tid), tid#epoch(r));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then, anon15_Else;

  anon70:
    call VarStateSetW_0(tid, x, e);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon11;

  anon15_Then10:
    return;

  anon15_Then6:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then10, CallToYieldProc;

  anon15_Then1:
    call ReleaseVarLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon15_Then6, CallToYieldProc;

  anon13_Then10:
    return;

  anon13_Then6:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then10, CallToYieldProc;

  anon13_Then1:
    call ReleaseVarLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon13_Then6, CallToYieldProc;

  anon12_Then6:
    return;

  anon12_Then2:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon12_Then6, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Read_0(tid: Tid, x: Var) returns (ok: bool)
{
  var e: Epoch;
  var w: Epoch;
  var vw: Epoch;
  var r: Epoch;
  var vr: Epoch;
  var xVC: VC;
  var stVC: VC;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call e := ThreadStateGetE(tid);
    if (*)
    {
        call r := VarStateGetRNoLock(tid, x);
        assume r != SHARED;
        if (r == e)
        {
            ok := true;
            call Yield20(tid);
            return;
        }
    }
    else
    {
        call r := VarStateGetRShared(tid, x);
        assume r == SHARED;
        call vw := VCGetElemShared(tid, x);
        if (vw == e)
        {
            ok := true;
            call Yield20(tid);
            return;
        }
    }

    call Yield20(tid);
    call AcquireVarLock(tid, x);
    call w := VarStateGetW(tid, x);
    call vw := VCGetElem(tid, ShadowableTid(tid), tid#epoch(w));
    if (!EpochLeq(w, vw))
    {
        call ReleaseVarLock(tid, x);
        ok := false;
        call Yield20(tid);
        return;
    }

    call r := VarStateGetR(tid, x);
    if (r != SHARED)
    {
        call vr := VCGetElem(tid, ShadowableTid(tid), tid#epoch(r));
        if (EpochLeq(r, vr))
        {
            assert tid#epoch(e) >= 0;
            call VarStateSetR(tid, x, e);
            call ReleaseVarLock(tid, x);
            ok := true;
            call Yield20(tid);
            return;
        }
        else
        {
            call VCInit(tid, ShadowableVar(x));
            call VCSetElem(tid, ShadowableVar(x), tid#epoch(r), r);
            call VCSetElem(tid, ShadowableVar(x), tid, e);
            call VarStateSetR(tid, x, SHARED);
            call ReleaseVarLock(tid, x);
            ok := true;
            call Yield20(tid);
            return;
        }
    }
    else
    {
        call VCSetElemShared(tid, x, e);
        call ReleaseVarLock(tid, x);
        ok := true;
        call Yield20(tid);
        return;
    }
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon12_Else:
    goto anon12_Else0, CallToYieldProc;

  anon14_Else:
    assume {:partition} vw != e;
    goto anon5;

  anon5:
    goto anon50, CallToYieldProc;

  anon15_Else:
    assume {:partition} EpochLeq(w, vw);
    goto anon7;

  anon7:
    goto anon70, CallToYieldProc;

  anon16_Else:
    assume {:partition} r == SHARED;
    goto anon16_Else1, CallToYieldProc;

  anon16_Then:
    assume {:partition} r != SHARED;
    goto anon16_Then1, CallToYieldProc;

  anon17_Else:
    assume {:partition} !EpochLeq(r, vr);
    goto anon17_Else1, CallToYieldProc;

  anon17_Then:
    assume {:partition} EpochLeq(r, vr);
    goto anon17_Then1, CallToYieldProc;

  anon15_Then:
    assume {:partition} !EpochLeq(w, vw);
    goto anon15_Then1, CallToYieldProc;

  anon14_Then:
    assume {:partition} vw == e;
    ok := true;
    goto anon14_Then2, CallToYieldProc;

  anon12_Then:
    goto anon12_Then0, CallToYieldProc;

  anon13_Else:
    assume {:partition} r != e;
    goto anon5;

  anon13_Then:
    assume {:partition} r == e;
    ok := true;
    goto anon13_Then2, CallToYieldProc;

  anon04:
    call e := ThreadStateGetE_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon12_Then, anon12_Else;

  anon00:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  anon12_Else5:
    call vw := VCGetElemShared_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then, anon14_Else;

  anon12_Else0:
    call r := VarStateGetRShared_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume r == SHARED;
    goto anon12_Else5, CallToYieldProc;

  anon512:
    call vw := VCGetElem_0(tid, ShadowableTid(tid), tid#epoch(w));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then, anon15_Else;

  anon58:
    call w := VarStateGetW_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon512, CallToYieldProc;

  anon54:
    call AcquireVarLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon58, CallToYieldProc;

  anon50:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon54, CallToYieldProc;

  anon70:
    call r := VarStateGetR_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Then, anon16_Else;

  anon16_Else14:
    return;

  anon16_Else10:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Else14, CallToYieldProc;

  anon16_Else5:
    call ReleaseVarLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon16_Else10, CallToYieldProc;

  anon16_Else1:
    call VCSetElemShared_0(tid, x, e);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Else5, CallToYieldProc;

  anon16_Then1:
    call vr := VCGetElem_0(tid, ShadowableTid(tid), tid#epoch(r));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Then, anon17_Else;

  anon17_Else26:
    return;

  anon17_Else22:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Else26, CallToYieldProc;

  anon17_Else17:
    call ReleaseVarLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon17_Else22, CallToYieldProc;

  anon17_Else13:
    call VarStateSetR_0(tid, x, SHARED);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Else17, CallToYieldProc;

  anon17_Else9:
    call VCSetElem_0(tid, ShadowableVar(x), tid, e);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Else13, CallToYieldProc;

  anon17_Else5:
    call VCSetElem_0(tid, ShadowableVar(x), tid#epoch(r), r);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Else9, CallToYieldProc;

  anon17_Else1:
    call VCInit_0(tid, ShadowableVar(x));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Else5, CallToYieldProc;

  anon17_Then14:
    return;

  anon17_Then10:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Then14, CallToYieldProc;

  anon17_Then5:
    call ReleaseVarLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon17_Then10, CallToYieldProc;

  anon17_Then1:
    call VarStateSetR_0(tid, x, e);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Then5, CallToYieldProc;

  anon15_Then10:
    return;

  anon15_Then6:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then10, CallToYieldProc;

  anon15_Then1:
    call ReleaseVarLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon15_Then6, CallToYieldProc;

  anon14_Then6:
    return;

  anon14_Then2:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then6, CallToYieldProc;

  anon12_Then0:
    call r := VarStateGetRNoLock_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume r != SHARED;
    goto anon13_Then, anon13_Else;

  anon13_Then6:
    return;

  anon13_Then2:
    call Yield20_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then6, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Yield30_0(tid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    yield;
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert thread.State[tid] == RUNNING();
    assert (forall t: Tid :: 
      old(shadow.Lock)[ShadowableTid(t)] == tid
         ==> thread.State[t] == old(thread.State)[t]);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon01, CallToYieldProc;

  anon05:
    return;

  anon01:
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon05, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Driver_0(tid: Tid) returns (ok: bool)
{
  var x: Var;
  var l: Lock;
  var uid: Tid;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield30(tid);
    ok := true;
    while (ok)
      invariant ValidTid(tid);
      invariant shadow.Lock[ShadowableTid(tid)] == tid;
      invariant thread.State[tid] == RUNNING();
      invariant (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
      invariant VarsRepOk(sx.W, sx.R);
      invariant (forall t: Tid :: 
        thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    {
        if (*)
        {
            havoc x;
            call ok := Write(tid, x);
        }
        else if (*)
        {
            havoc x;
            call ok := Read(tid, x);
        }
        else if (*)
        {
            assert shadow.Lock[ShadowableTid(tid)] == tid;
            call l := ChooseLockToAcquire(tid);
            call Yield30(tid);
            call Acquire(tid, l);
        }
        else if (*)
        {
            call l := ChooseLockToRelease(tid);
            call Yield30(tid);
            call Release(tid, l);
            call Yield30(tid);
            call ReleaseChosenLock(tid, l);
            call Yield30(tid);
        }
        else if (*)
        {
            call uid := AllocTid(tid);
            assert shadow.Lock[ShadowableTid(tid)] == tid;
            assert shadow.Lock[ShadowableTid(uid)] == tid;
            assert (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
            assert tid != uid;
            assert ValidTid(tid);
            assert ValidTid(uid);
            call Yield30(tid);
            assert ValidTid(tid);
            assert ValidTid(uid);
            call Fork(tid, uid);
            call Yield30(tid);
            call StartThread(tid, uid);
            call Yield30(tid);
        }
        else
        {
            call Yield30(tid);
            call uid := ChooseThreadToJoin(tid);
            call Yield30(tid);
            call Join(tid, uid);
            call Yield30(tid);
            call ReleaseJoinLock(tid, uid);
            call Yield30(tid);
        }

        call Yield30(tid);
        assert shadow.Lock[ShadowableTid(tid)] == tid;
    }

    yield;
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon10_LoopHead:
    assume linear_tid_available
       == linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false));
    assume shadow.VC == og_global_old_shadow.VC;
    assume shadow.Lock == og_global_old_shadow.Lock;
    assume sx.W == og_global_old_sx.W;
    assume sx.R == og_global_old_sx.R;
    assume thread.State == og_global_old_thread.State;
    assume thread.ForkedBy == og_global_old_thread.ForkedBy;
    assume thread.HasJoined == og_global_old_thread.HasJoined;
    assume pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon10_LoopDone, anon10_LoopBody;

  anon10_LoopBody:
    assume {:partition} ok;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    goto anon12_Then, anon12_Else;

  anon12_Else:
    goto anon13_Then, anon13_Else;

  anon13_Else:
    goto anon14_Then, anon14_Else;

  anon14_Else:
    goto anon15_Then, anon15_Else;

  anon15_Else:
    goto anon15_Else0, CallToYieldProc;

  anon8:
    goto anon80, CallToYieldProc;

  anon15_Then:
    goto anon15_Then0, CallToYieldProc;

  anon14_Then:
    goto anon14_Then0, CallToYieldProc;

  anon13_Then:
    goto anon13_Then0, CallToYieldProc;

  anon12_Then:
    havoc x;
    goto anon12_Then1, CallToYieldProc;

  anon11_Then:
    havoc x;
    goto anon11_Then1, CallToYieldProc;

  anon10_LoopDone:
    assume {:partition} !ok;
    goto anon9;

  anon9:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon91, CallToYieldProc;

  anon05:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon10_LoopHead;

  anon00:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon05, CallToYieldProc;

  anon15_Else24:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon15_Else20:
    call ReleaseJoinLock_0(tid, uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else24, CallToYieldProc;

  anon15_Else16:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else20, CallToYieldProc;

  anon15_Else12:
    call Join_0(tid, uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else16, CallToYieldProc;

  anon15_Else8:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else12, CallToYieldProc;

  anon15_Else4:
    call uid := ChooseThreadToJoin_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else8, CallToYieldProc;

  anon15_Else0:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else4, CallToYieldProc;

  anon84:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon10_LoopHead;

  anon80:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon84, CallToYieldProc;

  anon15_Then20:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon15_Then16:
    call StartThread_0(tid, uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then20, CallToYieldProc;

  anon15_Then12:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then16, CallToYieldProc;

  anon15_Then8:
    call Fork_0(tid, uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then12, CallToYieldProc;

  anon15_Then4:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then8, CallToYieldProc;

  anon15_Then0:
    call uid := AllocTid_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then4, CallToYieldProc;

  anon14_Then20:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon14_Then16:
    call ReleaseChosenLock_0(tid, l);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then20, CallToYieldProc;

  anon14_Then12:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then16, CallToYieldProc;

  anon14_Then8:
    call Release_0(tid, l);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then12, CallToYieldProc;

  anon14_Then4:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then8, CallToYieldProc;

  anon14_Then0:
    call l := ChooseLockToRelease_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then4, CallToYieldProc;

  anon13_Then8:
    call Acquire_0(tid, l);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon13_Then4:
    call Yield30_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then8, CallToYieldProc;

  anon13_Then0:
    call l := ChooseLockToAcquire_0(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then4, CallToYieldProc;

  anon12_Then1:
    call ok := Read_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon11_Then1:
    call ok := Write_0(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon95:
    return;

  anon91:
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon95, CallToYieldProc;

  CallToYieldProc:
    call og_yield_0(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



procedure {:inline 1} Impl_YieldChecker_Yield10_0(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



procedure {:inline 1} Impl_YieldChecker_Yield20_0(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



procedure {:inline 1} Impl_YieldChecker_Yield30_0(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



procedure {:inline 1} Impl_YieldChecker_Driver_0(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



implementation {:inline 1} Impl_YieldChecker_Yield10_0(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var tid: Tid;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume false;
    return;
}



implementation {:inline 1} Impl_YieldChecker_Yield20_0(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var tid: Tid;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume false;
    return;
}



implementation {:inline 1} Impl_YieldChecker_Yield30_0(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var tid: Tid;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume false;
    return;
}



implementation {:inline 1} Impl_YieldChecker_Driver_0(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var x: Var;
  var l: Lock;
  var uid: Tid;
  var tid: Tid;
  var ok: bool;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume false;
    return;
}



procedure {:inline 1} og_yield_0(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



implementation {:inline 1} og_yield_0(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{

  enter:
    goto L_0, L_1, L_2, L_3;

  L_0:
    call Impl_YieldChecker_Yield10_0(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;

  L_1:
    call Impl_YieldChecker_Yield20_0(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;

  L_2:
    call Impl_YieldChecker_Yield30_0(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;

  L_3:
    call Impl_YieldChecker_Driver_0(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;
}



procedure Yield10_10(tid: Tid);
  requires ValidTid(tid);
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTPreserved(tid, 
    old(shadow.Lock), 
    old(shadow.VC), 
    old(sx.W), 
    old(sx.R), 
    shadow.Lock, 
    shadow.VC, 
    sx.W, 
    sx.R);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);



procedure VC.Leq_10(tid: Tid, v1: Shadowable, v2: Shadowable) returns (res: bool);
  requires ValidTid(tid);
  requires shadow.Lock[v1] == tid;
  requires shadow.Lock[v2] == tid;
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  requires is#ShadowableVar(v1) ==> sx.R[x#ShadowableVar(v1)] == SHARED;
  requires !is#ShadowableVar(v2);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTPreserved(tid, 
    old(shadow.Lock), 
    old(shadow.VC), 
    old(sx.W), 
    old(sx.R), 
    shadow.Lock, 
    shadow.VC, 
    sx.W, 
    sx.R);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);



procedure VC.Copy_10(tid: Tid, v1: Shadowable, v2: Shadowable);
  requires ValidTid(tid);
  requires v1 != v2;
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[v1] == tid;
  requires shadow.Lock[v2] == tid;
  requires !is#ShadowableVar(v1);
  requires !is#ShadowableVar(v2);
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures (forall s: Shadowable :: 
    s != v1 && old(shadow.Lock)[s] == tid ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure VC.Join_10(tid: Tid, v1: Shadowable, v2: Shadowable);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[v1] == tid;
  requires shadow.Lock[v2] == tid;
  requires !is#ShadowableVar(v1);
  requires !is#ShadowableVar(v2);
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures (forall s: Shadowable :: 
    s != v1 && old(shadow.Lock)[s] == tid ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure VC.Inc_10(tid: Tid, v: Shadowable, i: int);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[v] == tid;
  requires !is#ShadowableVar(v);
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  requires VCRepOk(shadow.VC[v]);
  requires i >= 0;
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures VCRepOk(shadow.VC[v]);
  ensures (forall s: Shadowable :: 
    s != v && old(shadow.Lock)[s] == tid ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure Yield20_10(tid: Tid);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTPreserved(tid, 
    old(shadow.Lock), 
    old(shadow.VC), 
    old(sx.W), 
    old(sx.R), 
    shadow.Lock, 
    shadow.VC, 
    sx.W, 
    sx.R);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);



procedure Fork_10(tid: Tid, uid: Tid);
  requires ValidTid(tid);
  requires ValidTid(uid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[ShadowableTid(uid)] == tid;
  requires tid != uid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures (forall s: Shadowable :: 
    s != ShadowableTid(tid) && s != ShadowableTid(uid)
       ==> 
      old(shadow.Lock)[s] == tid
       ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure Join_10(tid: Tid, uid: Tid);
  requires ValidTid(tid);
  requires ValidTid(uid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[ShadowableTid(uid)] == tid;
  requires tid != uid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures (forall s: Shadowable :: 
    s != ShadowableTid(tid) && old(shadow.Lock)[s] == tid
       ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure Acquire_10(tid: Tid, l: Lock);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[ShadowableLock(l)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures (forall s: Shadowable :: 
    s != ShadowableTid(tid) && old(shadow.Lock)[s] == tid
       ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure Release_10(tid: Tid, l: Lock);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[ShadowableLock(l)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures (forall s: Shadowable :: 
    s != ShadowableTid(tid) && s != ShadowableLock(l) && old(shadow.Lock)[s] == tid
       ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure Write_10(tid: Tid, x: Var) returns (ok: bool);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);



procedure Read_10(tid: Tid, x: Var) returns (ok: bool);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);



procedure Yield30_10(tid: Tid);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);



procedure Driver_10(tid: Tid) returns (ok: bool);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
  requires VarsRepOk(sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



implementation Yield10_10(tid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    yield;
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    goto anon05, CallToYieldProc;

  anon017:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_ok;
    return;

  anon05:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assume FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assume FTRepOk(shadow.VC, sx.W, sx.R);
    goto anon017, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation VC.Leq_10(tid: Tid, v1: Shadowable, v2: Shadowable) returns (res: bool)
{
  var vc1: VC;
  var vc2: VC;
  var len1: int;
  var len2: int;
  var e1: Epoch;
  var e2: Epoch;
  var i: int;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var og_old_res: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield10(tid);
    call len1 := VCGetSize(tid, v1);
    call len2 := VCGetSize(tid, v1);
    i := 0;
    while (i < max(len1, len2))
      invariant 0 <= i;
      invariant (forall j: int :: 
        { f(j) } 
        0 <= j && j < i && f(j)
           ==> EpochLeq(VCArrayGet(shadow.VC[v1], j), VCArrayGet(shadow.VC[v2], j)));
    {
        call e1 := VCGetElem(tid, v1, i);
        call e2 := VCGetElem(tid, v2, i);
        if (!EpochLeq(e1, e2))
        {
            assert f(i);
            res := false;
            call Yield10(tid);
            return;
        }

        i := i + 1;
    }

    res := true;
    call Yield10(tid);
    return;
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_res := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, res;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon5_LoopHead:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert 0 <= i;
    assert (forall j: int :: 
      { f(j) } 
      0 <= j && j < i && f(j)
         ==> EpochLeq(VCArrayGet(shadow.VC[v1], j), VCArrayGet(shadow.VC[v2], j)));
    goto anon5_LoopDone, anon5_LoopBody;

  anon5_LoopBody:
    assume {:partition} i < max(len1, len2);
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v1] == tid;
    // injected gate >>>
    call e1 := AtomicVCGetElem_10(tid, v1, i);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v2] == tid;
    // injected gate >>>
    call e2 := AtomicVCGetElem_10(tid, v2, i);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon6_Then, anon6_Else;

  anon6_Else:
    assume {:partition} EpochLeq(e1, e2);
    goto anon3;

  anon3:
    i := i + 1;
    goto anon5_LoopHead;

  anon6_Then:
    assume {:partition} !EpochLeq(e1, e2);
    assert f(i);
    res := false;
    goto anon6_Then3, CallToYieldProc;

  anon5_LoopDone:
    assume {:partition} max(len1, len2) <= i;
    goto anon4;

  anon4:
    res := true;
    goto anon41, CallToYieldProc;

  anon00:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                VCArrayGet(og_global_old_shadow.VC[v2], second_j)))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res <==> og_old_res);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                VCArrayGet(og_global_old_shadow.VC[v2], second_j)))));
    call Yield10_10(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[v1] == tid
         && shadow.Lock[v2] == tid
         && shadow.Lock[ShadowableTid(tid)] == tid
         && (is#ShadowableVar(v1) ==> sx.R[x#ShadowableVar(v1)] == SHARED)
         && !is#ShadowableVar(v2));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_res := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, res;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v1] == tid;
    // injected gate >>>
    call len1 := AtomicVCGetSize_10(tid, v1);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v1] == tid;
    // injected gate >>>
    call len2 := AtomicVCGetSize_10(tid, v1);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    i := 0;
    goto anon5_LoopHead;

  anon6_Then11:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                VCArrayGet(og_global_old_shadow.VC[v2], second_j)))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res <==> og_old_res);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                VCArrayGet(og_global_old_shadow.VC[v2], second_j)))));
    assert og_ok;
    return;

  anon6_Then3:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                VCArrayGet(og_global_old_shadow.VC[v2], second_j)))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res <==> og_old_res);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                VCArrayGet(og_global_old_shadow.VC[v2], second_j)))));
    call Yield10_10(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[v1] == tid
         && shadow.Lock[v2] == tid
         && shadow.Lock[ShadowableTid(tid)] == tid
         && (is#ShadowableVar(v1) ==> sx.R[x#ShadowableVar(v1)] == SHARED)
         && !is#ShadowableVar(v2));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_res := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, res;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon6_Then11, CallToYieldProc;

  anon49:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                VCArrayGet(og_global_old_shadow.VC[v2], second_j)))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res <==> og_old_res);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                VCArrayGet(og_global_old_shadow.VC[v2], second_j)))));
    assert og_ok;
    return;

  anon41:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                VCArrayGet(og_global_old_shadow.VC[v2], second_j)))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res <==> og_old_res);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (res
           <==> (forall second_j: int :: 
            { f(second_j) } 
            0 <= second_j && f(second_j)
               ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                VCArrayGet(og_global_old_shadow.VC[v2], second_j)))));
    call Yield10_10(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[v1] == tid
         && shadow.Lock[v2] == tid
         && shadow.Lock[ShadowableTid(tid)] == tid
         && (is#ShadowableVar(v1) ==> sx.R[x#ShadowableVar(v1)] == SHARED)
         && !is#ShadowableVar(v2));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_res := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, res;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon49, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation VC.Copy_10(tid: Tid, v1: Shadowable, v2: Shadowable)
{
  var len1: int;
  var len2: int;
  var e1: Epoch;
  var e2: Epoch;
  var i: int;
  var oldVC: [Shadowable][Tid]Epoch;
  var oldLock: [Shadowable]Tid;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield10(tid);
    call oldLock, oldVC := GhostRead();
    call len1 := VCGetSize(tid, v1);
    call len2 := VCGetSize(tid, v2);
    i := 0;
    while (i < max(len1, len2))
      invariant (forall s: Shadowable :: s != v1 ==> shadow.VC[s] == oldVC[s]);
      invariant (forall s: Shadowable :: oldLock[s] == tid ==> shadow.Lock[s] == tid);
      invariant VCRepOk(shadow.VC[v1]);
      invariant i >= 0;
      invariant i <= max(len1, len2);
      invariant VCArrayLen(shadow.VC[v1]) == max(len1, i);
      invariant (forall j: int :: 
        0 <= j && j < i ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
      invariant (forall j: int :: 
        max(len1, len2) <= j
           ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    {
        call e2 := VCGetElem(tid, v2, i);
        call VCSetElem(tid, v1, i, e2);
        i := i + 1;
    }

    call Yield10(tid);
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon3_LoopHead:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert (forall s: Shadowable :: s != v1 ==> shadow.VC[s] == oldVC[s]);
    assert (forall s: Shadowable :: oldLock[s] == tid ==> shadow.Lock[s] == tid);
    assert VCRepOk(shadow.VC[v1]);
    assert i >= 0;
    assert i <= max(len1, len2);
    assert VCArrayLen(shadow.VC[v1]) == max(len1, i);
    assert (forall j: int :: 
      0 <= j && j < i ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    assert (forall j: int :: 
      max(len1, len2) <= j
         ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(shadow.VC[v2], j));
    goto anon3_LoopDone, anon3_LoopBody;

  anon3_LoopBody:
    assume {:partition} i < max(len1, len2);
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v2] == tid;
    // injected gate >>>
    call e2 := AtomicVCGetElem_10(tid, v2, i);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert is#ShadowableVar(v1) ==> sx.R[x#ShadowableVar(v1)] != SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[v1] == tid;
    // injected gate >>>
    call AtomicVCSetElem_10(tid, v1, i, e2);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    i := i + 1;
    goto anon3_LoopHead;

  anon3_LoopDone:
    assume {:partition} max(len1, len2) <= i;
    goto anon2;

  anon2:
    goto anon20, CallToYieldProc;

  anon00:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (exists #tmp_0_second_Vnew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1], second_j)
                 == VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2], second_j))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), 
              VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.VC == og_global_old_shadow.VC[v1 := og_global_old_shadow.VC[v2]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (exists #tmp_0_second_Vnew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1], second_j)
                 == VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2], second_j))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), 
              VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.VC == og_global_old_shadow.VC[v1 := og_global_old_shadow.VC[v2]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    call Yield10_10(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && v1 != v2
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[v1] == tid
         && shadow.Lock[v2] == tid
         && !is#ShadowableVar(v1)
         && !is#ShadowableVar(v2)
         && VCRepOk(shadow.VC[v2])
         && VCRepOk(shadow.VC[v1]));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    call oldLock, oldVC := GhostRead();
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v1] == tid;
    // injected gate >>>
    call len1 := AtomicVCGetSize_10(tid, v1);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v2] == tid;
    // injected gate >>>
    call len2 := AtomicVCGetSize_10(tid, v2);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    i := 0;
    goto anon3_LoopHead;

  anon28:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (exists #tmp_0_second_Vnew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1], second_j)
                 == VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2], second_j))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), 
              VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.VC == og_global_old_shadow.VC[v1 := og_global_old_shadow.VC[v2]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (exists #tmp_0_second_Vnew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1], second_j)
                 == VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2], second_j))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), 
              VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.VC == og_global_old_shadow.VC[v1 := og_global_old_shadow.VC[v2]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_ok;
    return;

  anon20:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (exists #tmp_0_second_Vnew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1], second_j)
                 == VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2], second_j))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), 
              VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.VC == og_global_old_shadow.VC[v1 := og_global_old_shadow.VC[v2]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (exists #tmp_0_second_Vnew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1], second_j)
                 == VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2], second_j))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), 
              VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_Vnew][v2]))
           && VCRepOk(#tmp_0_second_Vnew))
       || (
        shadow.VC == og_global_old_shadow.VC[v1 := og_global_old_shadow.VC[v2]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    call Yield10_10(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && v1 != v2
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[v1] == tid
         && shadow.Lock[v2] == tid
         && !is#ShadowableVar(v1)
         && !is#ShadowableVar(v2)
         && VCRepOk(shadow.VC[v2])
         && VCRepOk(shadow.VC[v1]));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon28, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation VC.Join_10(tid: Tid, v1: Shadowable, v2: Shadowable)
{
  var len1: int;
  var len2: int;
  var e1: Epoch;
  var e2: Epoch;
  var i: int;
  var oldVC: [Shadowable][Tid]Epoch;
  var oldLock: [Shadowable]Tid;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield10(tid);
    call oldLock, oldVC := GhostRead();
    call len1 := VCGetSize(tid, v1);
    call len2 := VCGetSize(tid, v2);
    i := 0;
    while (i < max(len1, len2))
      invariant (forall s: Shadowable :: s != v1 ==> shadow.VC[s] == oldVC[s]);
      invariant (forall s: Shadowable :: oldLock[s] == tid ==> shadow.Lock[s] == tid);
      invariant VCRepOk(shadow.VC[v1]);
      invariant i >= 0;
      invariant i <= max(len1, len2);
      invariant VCArrayLen(shadow.VC[v1]) == max(len1, i);
      invariant (forall j: int :: 
        0 <= j && i <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(oldVC[v1], j));
      invariant (forall j: int :: 
        0 <= j && j < i
           ==> VCArrayGet(shadow.VC[v1], j)
             == EpochMax(VCArrayGet(oldVC[v1], j), VCArrayGet(shadow.VC[v2], j)));
    {
        call e1 := VCGetElem(tid, v1, i);
        call e2 := VCGetElem(tid, v2, i);
        call VCSetElem(tid, v1, i, EpochMax(e1, e2));
        i := i + 1;
    }

    call Yield10(tid);
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon3_LoopHead:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert (forall s: Shadowable :: s != v1 ==> shadow.VC[s] == oldVC[s]);
    assert (forall s: Shadowable :: oldLock[s] == tid ==> shadow.Lock[s] == tid);
    assert VCRepOk(shadow.VC[v1]);
    assert i >= 0;
    assert i <= max(len1, len2);
    assert VCArrayLen(shadow.VC[v1]) == max(len1, i);
    assert (forall j: int :: 
      0 <= j && i <= j ==> VCArrayGet(shadow.VC[v1], j) == VCArrayGet(oldVC[v1], j));
    assert (forall j: int :: 
      0 <= j && j < i
         ==> VCArrayGet(shadow.VC[v1], j)
           == EpochMax(VCArrayGet(oldVC[v1], j), VCArrayGet(shadow.VC[v2], j)));
    goto anon3_LoopDone, anon3_LoopBody;

  anon3_LoopBody:
    assume {:partition} i < max(len1, len2);
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v1] == tid;
    // injected gate >>>
    call e1 := AtomicVCGetElem_10(tid, v1, i);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v2] == tid;
    // injected gate >>>
    call e2 := AtomicVCGetElem_10(tid, v2, i);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert is#ShadowableVar(v1) ==> sx.R[x#ShadowableVar(v1)] != SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[v1] == tid;
    // injected gate >>>
    call AtomicVCSetElem_10(tid, v1, i, EpochMax(e1, e2));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    i := i + 1;
    goto anon3_LoopHead;

  anon3_LoopDone:
    assume {:partition} max(len1, len2) <= i;
    goto anon2;

  anon2:
    goto anon20, CallToYieldProc;

  anon00:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1], second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v2], second_j)))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), VCArrayLen(og_global_old_shadow.VC[v2]))
           && VCRepOk(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1]));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1], second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v2], second_j)))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), VCArrayLen(og_global_old_shadow.VC[v2]))
           && VCRepOk(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1]));
    call Yield10_10(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[v1] == tid
         && shadow.Lock[v2] == tid
         && !is#ShadowableVar(v1)
         && !is#ShadowableVar(v2)
         && VCRepOk(shadow.VC[v2]));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    call oldLock, oldVC := GhostRead();
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v1] == tid;
    // injected gate >>>
    call len1 := AtomicVCGetSize_10(tid, v1);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v2] == tid;
    // injected gate >>>
    call len2 := AtomicVCGetSize_10(tid, v2);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    i := 0;
    goto anon3_LoopHead;

  anon28:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1], second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v2], second_j)))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), VCArrayLen(og_global_old_shadow.VC[v2]))
           && VCRepOk(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1]));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1], second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v2], second_j)))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), VCArrayLen(og_global_old_shadow.VC[v2]))
           && VCRepOk(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1]));
    assert og_ok;
    return;

  anon20:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1], second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v2], second_j)))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), VCArrayLen(og_global_old_shadow.VC[v2]))
           && VCRepOk(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1]));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1], second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[v1], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v2], second_j)))
           && VCArrayLen(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1])
             == max(VCArrayLen(og_global_old_shadow.VC[v1]), VCArrayLen(og_global_old_shadow.VC[v2]))
           && VCRepOk(og_global_old_shadow.VC[v1 := #tmp_0_second_vcNew][v1]));
    call Yield10_10(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[v1] == tid
         && shadow.Lock[v2] == tid
         && !is#ShadowableVar(v1)
         && !is#ShadowableVar(v2)
         && VCRepOk(shadow.VC[v2]));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon28, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation VC.Inc_10(tid: Tid, v: Shadowable, i: int)
{
  var e: Epoch;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield10(tid);
    call e := VCGetElem(tid, v, i);
    call VCSetElem(tid, v, i, EpochInc(e));
    call Yield10(tid);
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon029:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC
           == og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v := og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i := EpochInc(og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i])]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC
           == og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v := og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i := EpochInc(og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i])]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_ok;
    return;

  anon021:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC
           == og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v := og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i := EpochInc(og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i])]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC
           == og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v := og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i := EpochInc(og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i])]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    call Yield10_10(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[v] == tid
         && !is#ShadowableVar(v)
         && i >= 0
         && VCRepOk(shadow.VC[v]));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon029, CallToYieldProc;

  anon00:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC
           == og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v := og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i := EpochInc(og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i])]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC
           == og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v := og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i := EpochInc(og_global_old_shadow.VC[v := VCArraySetLen(og_global_old_shadow.VC[v], max(VCArrayLen(og_global_old_shadow.VC[v]), i + 1))][v][i])]]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    call Yield10_10(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[v] == tid
         && !is#ShadowableVar(v)
         && i >= 0
         && VCRepOk(shadow.VC[v]));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[v] == tid;
    // injected gate >>>
    call e := AtomicVCGetElem_10(tid, v, i);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert is#ShadowableVar(v) ==> sx.R[x#ShadowableVar(v)] != SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[v] == tid;
    // injected gate >>>
    call AtomicVCSetElem_10(tid, v, i, EpochInc(e));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon021, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Yield20_10(tid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    yield;
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    goto anon05, CallToYieldProc;

  anon013:
    return;

  anon05:
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assume FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assume FTRepOk(shadow.VC, sx.W, sx.R);
    goto anon013, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Fork_10(tid: Tid, uid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Join(tid, ShadowableTid(uid), ShadowableTid(tid));
    call VC.Inc(tid, ShadowableTid(tid), tid);
    call Yield20(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon016:
    return;

  anon012:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon016, CallToYieldProc;

  anon08:
    call VC.Inc_10(tid, ShadowableTid(tid), tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon012, CallToYieldProc;

  anon04:
    call VC.Join_10(tid, ShadowableTid(uid), ShadowableTid(tid));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Join_10(tid: Tid, uid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Join(tid, ShadowableTid(tid), ShadowableTid(uid));
    call Yield20(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon012:
    return;

  anon08:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon012, CallToYieldProc;

  anon04:
    call VC.Join_10(tid, ShadowableTid(tid), ShadowableTid(uid));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Acquire_10(tid: Tid, l: Lock)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Join(tid, ShadowableTid(tid), ShadowableLock(l));
    call Yield20(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon012:
    return;

  anon08:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon012, CallToYieldProc;

  anon04:
    call VC.Join_10(tid, ShadowableTid(tid), ShadowableLock(l));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Release_10(tid: Tid, l: Lock)
{
  var sm: Shadowable;
  var st: Shadowable;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Copy(tid, ShadowableLock(l), ShadowableTid(tid));
    call VC.Inc(tid, ShadowableTid(tid), tid);
    call Yield20(tid);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon016:
    return;

  anon012:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon016, CallToYieldProc;

  anon08:
    call VC.Inc_10(tid, ShadowableTid(tid), tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon012, CallToYieldProc;

  anon04:
    call VC.Copy_10(tid, ShadowableLock(l), ShadowableTid(tid));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon08, CallToYieldProc;

  anon00:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon04, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Write_10(tid: Tid, x: Var) returns (ok: bool)
{
  var e: Epoch;
  var w: Epoch;
  var vw: Epoch;
  var r: Epoch;
  var vr: Epoch;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call e := ThreadStateGetE(tid);
    call w := VarStateGetWNoLock(tid, x);
    if (w == e)
    {
        ok := true;
        call Yield20(tid);
        return;
    }

    call Yield20(tid);
    call AcquireVarLock(tid, x);
    call w := VarStateGetW(tid, x);
    call vw := VCGetElem(tid, ShadowableTid(tid), tid#epoch(w));
    if (!EpochLeq(w, vw))
    {
        call ReleaseVarLock(tid, x);
        ok := false;
        call Yield20(tid);
        return;
    }

    call r := VarStateGetR(tid, x);
    if (r != SHARED)
    {
        call vr := VCGetElem(tid, ShadowableTid(tid), tid#epoch(r));
        if (!EpochLeq(r, vr))
        {
            call ReleaseVarLock(tid, x);
            ok := false;
            call Yield20(tid);
            return;
        }

        call VarStateSetW(tid, x, e);
    }
    else
    {
        call ok := VC.Leq(tid, ShadowableVar(x), ShadowableTid(tid));
        if (!ok)
        {
            call ReleaseVarLock(tid, x);
            ok := false;
            call Yield20(tid);
            return;
        }

        call VarStateSetW(tid, x, e);
    }

    call ReleaseVarLock(tid, x);
    ok := true;
    call Yield20(tid);
    return;
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon12_Else:
    assume {:partition} w != e;
    goto anon2;

  anon2:
    goto anon20, CallToYieldProc;

  anon13_Else:
    assume {:partition} EpochLeq(w, vw);
    goto anon4;

  anon4:
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call r := AtomicVarStateGetR_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} r == SHARED;
    goto anon14_Else1, CallToYieldProc;

  anon16_Else:
    assume {:partition} ok;
    goto anon10;

  anon10:
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVarStateSetW_10(tid, x, e);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon11;

  anon11:
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon117, CallToYieldProc;

  anon16_Then:
    assume {:partition} !ok;
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon16_Then8, CallToYieldProc;

  anon14_Then:
    assume {:partition} r != SHARED;
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call vr := AtomicVCGetElem_10(tid, ShadowableTid(tid), tid#epoch(r));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} EpochLeq(r, vr);
    goto anon7;

  anon7:
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVarStateSetW_10(tid, x, e);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon11;

  anon15_Then:
    assume {:partition} !EpochLeq(r, vr);
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon15_Then8, CallToYieldProc;

  anon13_Then:
    assume {:partition} !EpochLeq(w, vw);
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon13_Then8, CallToYieldProc;

  anon12_Then:
    assume {:partition} w == e;
    ok := true;
    goto anon12_Then2, CallToYieldProc;

  anon00:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call e := AtomicThreadStateGetE_10(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    // injected gate >>>
    call w := AtomicVarStateGetWNoLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon12_Then, anon12_Else;

  anon20:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    // injected gate >>>
    call AtomicAcquireVarLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call w := AtomicVarStateGetW_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call vw := AtomicVCGetElem_10(tid, ShadowableTid(tid), tid#epoch(w));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then, anon13_Else;

  anon14_Else1:
    call ok := VC.Leq_10(tid, ShadowableVar(x), ShadowableTid(tid));
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Then, anon16_Else;

  anon1111:
    return;

  anon117:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon1111, CallToYieldProc;

  anon16_Then12:
    return;

  anon16_Then8:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Then12, CallToYieldProc;

  anon15_Then12:
    return;

  anon15_Then8:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then12, CallToYieldProc;

  anon13_Then12:
    return;

  anon13_Then8:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then12, CallToYieldProc;

  anon12_Then6:
    return;

  anon12_Then2:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon12_Then6, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Read_10(tid: Tid, x: Var) returns (ok: bool)
{
  var e: Epoch;
  var w: Epoch;
  var vw: Epoch;
  var r: Epoch;
  var vr: Epoch;
  var xVC: VC;
  var stVC: VC;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call e := ThreadStateGetE(tid);
    if (*)
    {
        call r := VarStateGetRNoLock(tid, x);
        assume r != SHARED;
        if (r == e)
        {
            ok := true;
            call Yield20(tid);
            return;
        }
    }
    else
    {
        call r := VarStateGetRShared(tid, x);
        assume r == SHARED;
        call vw := VCGetElemShared(tid, x);
        if (vw == e)
        {
            ok := true;
            call Yield20(tid);
            return;
        }
    }

    call Yield20(tid);
    call AcquireVarLock(tid, x);
    call w := VarStateGetW(tid, x);
    call vw := VCGetElem(tid, ShadowableTid(tid), tid#epoch(w));
    if (!EpochLeq(w, vw))
    {
        call ReleaseVarLock(tid, x);
        ok := false;
        call Yield20(tid);
        return;
    }

    call r := VarStateGetR(tid, x);
    if (r != SHARED)
    {
        call vr := VCGetElem(tid, ShadowableTid(tid), tid#epoch(r));
        if (EpochLeq(r, vr))
        {
            assert tid#epoch(e) >= 0;
            call VarStateSetR(tid, x, e);
            call ReleaseVarLock(tid, x);
            ok := true;
            call Yield20(tid);
            return;
        }
        else
        {
            call VCInit(tid, ShadowableVar(x));
            call VCSetElem(tid, ShadowableVar(x), tid#epoch(r), r);
            call VCSetElem(tid, ShadowableVar(x), tid, e);
            call VarStateSetR(tid, x, SHARED);
            call ReleaseVarLock(tid, x);
            ok := true;
            call Yield20(tid);
            return;
        }
    }
    else
    {
        call VCSetElemShared(tid, x, e);
        call ReleaseVarLock(tid, x);
        ok := true;
        call Yield20(tid);
        return;
    }
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon12_Else:
    // <<< injected gate
    assume ValidTid(tid);
    // injected gate >>>
    call r := AtomicVarStateGetRShared_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume r == SHARED;
    // <<< injected gate
    assume sx.R[x] == SHARED;
    assume ValidTid(tid);
    // injected gate >>>
    call vw := AtomicVCGetElemShared_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} vw != e;
    goto anon5;

  anon5:
    goto anon50, CallToYieldProc;

  anon15_Else:
    assume {:partition} EpochLeq(w, vw);
    goto anon7;

  anon7:
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call r := AtomicVarStateGetR_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Then, anon16_Else;

  anon16_Else:
    assume {:partition} r == SHARED;
    // <<< injected gate
    assume sx.R[x] == SHARED;
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVCSetElemShared_10(tid, x, e);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon16_Else15, CallToYieldProc;

  anon16_Then:
    assume {:partition} r != SHARED;
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call vr := AtomicVCGetElem_10(tid, ShadowableTid(tid), tid#epoch(r));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:partition} !EpochLeq(r, vr);
    // <<< injected gate
    assume ValidTid(tid);
    assume is#ShadowableVar(ShadowableVar(x))
       ==> sx.R[x#ShadowableVar(ShadowableVar(x))] != SHARED;
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVCInit_10(tid, ShadowableVar(x));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume is#ShadowableVar(ShadowableVar(x))
       ==> sx.R[x#ShadowableVar(ShadowableVar(x))] != SHARED;
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVCSetElem_10(tid, ShadowableVar(x), tid#epoch(r), r);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume is#ShadowableVar(ShadowableVar(x))
       ==> sx.R[x#ShadowableVar(ShadowableVar(x))] != SHARED;
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVCSetElem_10(tid, ShadowableVar(x), tid, e);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    assume sx.R[x] != SHARED;
    // injected gate >>>
    call AtomicVarStateSetR_10(tid, x, SHARED);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon17_Else36, CallToYieldProc;

  anon17_Then:
    assume {:partition} EpochLeq(r, vr);
    assert tid#epoch(e) >= 0;
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    assume sx.R[x] != SHARED;
    // injected gate >>>
    call AtomicVarStateSetR_10(tid, x, e);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon17_Then16, CallToYieldProc;

  anon15_Then:
    assume {:partition} !EpochLeq(w, vw);
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon15_Then8, CallToYieldProc;

  anon14_Then:
    assume {:partition} vw == e;
    ok := true;
    goto anon14_Then2, CallToYieldProc;

  anon12_Then:
    // <<< injected gate
    assume ValidTid(tid);
    // injected gate >>>
    call r := AtomicVarStateGetRNoLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume r != SHARED;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:partition} r != e;
    goto anon5;

  anon13_Then:
    assume {:partition} r == e;
    ok := true;
    goto anon13_Then2, CallToYieldProc;

  anon00:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call e := AtomicThreadStateGetE_10(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon12_Then, anon12_Else;

  anon50:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    // injected gate >>>
    call AtomicAcquireVarLock_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call w := AtomicVarStateGetW_10(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call vw := AtomicVCGetElem_10(tid, ShadowableTid(tid), tid#epoch(w));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then, anon15_Else;

  anon16_Else19:
    return;

  anon16_Else15:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Else19, CallToYieldProc;

  anon17_Else40:
    return;

  anon17_Else36:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Else40, CallToYieldProc;

  anon17_Then20:
    return;

  anon17_Then16:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Then20, CallToYieldProc;

  anon15_Then12:
    return;

  anon15_Then8:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then12, CallToYieldProc;

  anon14_Then6:
    return;

  anon14_Then2:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then6, CallToYieldProc;

  anon13_Then6:
    return;

  anon13_Then2:
    call Yield20_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then6, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Yield30_10(tid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    yield;
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert thread.State[tid] == RUNNING();
    assert (forall t: Tid :: 
      old(shadow.Lock)[ShadowableTid(t)] == tid
         ==> thread.State[t] == old(thread.State)[t]);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    goto anon05, CallToYieldProc;

  anon013:
    return;

  anon05:
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assume FTRepOk(shadow.VC, sx.W, sx.R);
    assume FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    goto anon013, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Driver_10(tid: Tid) returns (ok: bool)
{
  var x: Var;
  var l: Lock;
  var uid: Tid;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield30(tid);
    ok := true;
    while (ok)
      invariant ValidTid(tid);
      invariant shadow.Lock[ShadowableTid(tid)] == tid;
      invariant thread.State[tid] == RUNNING();
      invariant (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
      invariant VarsRepOk(sx.W, sx.R);
      invariant (forall t: Tid :: 
        thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    {
        if (*)
        {
            havoc x;
            call ok := Write(tid, x);
        }
        else if (*)
        {
            havoc x;
            call ok := Read(tid, x);
        }
        else if (*)
        {
            assert shadow.Lock[ShadowableTid(tid)] == tid;
            call l := ChooseLockToAcquire(tid);
            call Yield30(tid);
            call Acquire(tid, l);
        }
        else if (*)
        {
            call l := ChooseLockToRelease(tid);
            call Yield30(tid);
            call Release(tid, l);
            call Yield30(tid);
            call ReleaseChosenLock(tid, l);
            call Yield30(tid);
        }
        else if (*)
        {
            call uid := AllocTid(tid);
            assert shadow.Lock[ShadowableTid(tid)] == tid;
            assert shadow.Lock[ShadowableTid(uid)] == tid;
            assert (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
            assert tid != uid;
            assert ValidTid(tid);
            assert ValidTid(uid);
            call Yield30(tid);
            assert ValidTid(tid);
            assert ValidTid(uid);
            call Fork(tid, uid);
            call Yield30(tid);
            call StartThread(tid, uid);
            call Yield30(tid);
        }
        else
        {
            call Yield30(tid);
            call uid := ChooseThreadToJoin(tid);
            call Yield30(tid);
            call Join(tid, uid);
            call Yield30(tid);
            call ReleaseJoinLock(tid, uid);
            call Yield30(tid);
        }

        call Yield30(tid);
        assert shadow.Lock[ShadowableTid(tid)] == tid;
    }

    yield;
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon10_LoopHead:
    assume linear_tid_available
       == linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false));
    assume shadow.VC == og_global_old_shadow.VC;
    assume shadow.Lock == og_global_old_shadow.Lock;
    assume sx.W == og_global_old_sx.W;
    assume sx.R == og_global_old_sx.R;
    assume thread.State == og_global_old_thread.State;
    assume thread.ForkedBy == og_global_old_thread.ForkedBy;
    assume thread.HasJoined == og_global_old_thread.HasJoined;
    assume pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
    assert VarsRepOk(sx.W, sx.R);
    goto anon10_LoopDone, anon10_LoopBody;

  anon10_LoopBody:
    assume {:partition} ok;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    goto anon12_Then, anon12_Else;

  anon12_Else:
    goto anon13_Then, anon13_Else;

  anon13_Else:
    goto anon14_Then, anon14_Else;

  anon14_Else:
    goto anon15_Then, anon15_Else;

  anon15_Else:
    goto anon15_Else0, CallToYieldProc;

  anon8:
    goto anon80, CallToYieldProc;

  anon15_Then:
    // <<< injected gate
    assume thread.State[tid] == RUNNING() && ValidTid(tid);
    assume (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    // injected gate >>>
    call uid := AtomicAllocTid_10(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
    assert tid != uid;
    assert ValidTid(tid);
    assert ValidTid(uid);
    goto anon15_Then12, CallToYieldProc;

  anon14_Then:
    // <<< injected gate
    assume ValidTid(tid);
    // injected gate >>>
    call l := AtomicChooseLockToRelease_10(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then5, CallToYieldProc;

  anon13_Then:
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    // <<< injected gate
    assume ValidTid(tid);
    // injected gate >>>
    call l := AtomicChooseLockToAcquire_10(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then6, CallToYieldProc;

  anon12_Then:
    havoc x;
    goto anon12_Then1, CallToYieldProc;

  anon11_Then:
    havoc x;
    goto anon11_Then1, CallToYieldProc;

  anon10_LoopDone:
    assume {:partition} !ok;
    goto anon9;

  anon9:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon91, CallToYieldProc;

  anon05:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon10_LoopHead;

  anon00:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon05, CallToYieldProc;

  anon15_Else29:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon15_Else17:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume ValidTid(uid);
    assume tid != uid;
    assume shadow.Lock[ShadowableTid(uid)] == tid;
    // injected gate >>>
    call AtomicReleaseJoinLock_10(tid, uid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else29, CallToYieldProc;

  anon15_Else13:
    call Join_10(tid, uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else17, CallToYieldProc;

  anon15_Else9:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else13, CallToYieldProc;

  anon15_Else0:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume thread.State[tid] == RUNNING() && ValidTid(tid);
    // injected gate >>>
    call uid := AtomicChooseThreadToJoin_10(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else9, CallToYieldProc;

  anon84:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon10_LoopHead;

  anon80:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon84, CallToYieldProc;

  anon15_Then35:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon15_Then22:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume ValidTid(uid);
    assume tid != uid;
    assume shadow.Lock[ShadowableTid(uid)] == tid;
    assume thread.State[uid] == NEW();
    // injected gate >>>
    call AtomicStartThread_10(tid, uid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then35, CallToYieldProc;

  anon15_Then18:
    call Fork_10(tid, uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then22, CallToYieldProc;

  anon15_Then12:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert ValidTid(uid);
    goto anon15_Then18, CallToYieldProc;

  anon14_Then23:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon14_Then13:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == tid;
    // injected gate >>>
    call AtomicReleaseChosenLock_10(tid, l);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then23, CallToYieldProc;

  anon14_Then9:
    call Release_10(tid, l);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then13, CallToYieldProc;

  anon14_Then5:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then9, CallToYieldProc;

  anon13_Then10:
    call Acquire_10(tid, l);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon13_Then6:
    call Yield30_10(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then10, CallToYieldProc;

  anon12_Then1:
    call ok := Read_10(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon11_Then1:
    call ok := Write_10(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon95:
    return;

  anon91:
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon95, CallToYieldProc;

  CallToYieldProc:
    call og_yield_10(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



procedure {:inline 1} Impl_YieldChecker_Yield10_10(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



procedure {:inline 1} Impl_YieldChecker_Yield20_10(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



procedure {:inline 1} Impl_YieldChecker_Yield30_10(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



procedure {:inline 1} Impl_YieldChecker_Driver_10(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



implementation {:inline 1} Impl_YieldChecker_Yield10_10(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var tid: Tid;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, og_local_old_shadow.Lock, og_global_old_shadow.Lock);
    assume FTPreserved(tid, 
      og_local_old_shadow.Lock, 
      og_local_old_shadow.VC, 
      og_local_old_sx.W, 
      og_local_old_sx.R, 
      og_global_old_shadow.Lock, 
      og_global_old_shadow.VC, 
      og_global_old_sx.W, 
      og_global_old_sx.R);
    assume FTRepOk(og_global_old_shadow.VC, og_global_old_sx.W, og_global_old_sx.R);
    assert ValidTid(tid);
    assert LocksPreserved(tid, og_local_old_shadow.Lock, shadow.Lock);
    assert FTPreserved(tid, 
      og_local_old_shadow.Lock, 
      og_local_old_shadow.VC, 
      og_local_old_sx.W, 
      og_local_old_sx.R, 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assume false;
    return;
}



implementation {:inline 1} Impl_YieldChecker_Yield20_10(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var tid: Tid;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, og_local_old_shadow.Lock, og_global_old_shadow.Lock);
    assume FTPreserved(tid, 
      og_local_old_shadow.Lock, 
      og_local_old_shadow.VC, 
      og_local_old_sx.W, 
      og_local_old_sx.R, 
      og_global_old_shadow.Lock, 
      og_global_old_shadow.VC, 
      og_global_old_sx.W, 
      og_global_old_sx.R);
    assume FTRepOk(og_global_old_shadow.VC, og_global_old_sx.W, og_global_old_sx.R);
    assert ValidTid(tid);
    assert LocksPreserved(tid, og_local_old_shadow.Lock, shadow.Lock);
    assert FTPreserved(tid, 
      og_local_old_shadow.Lock, 
      og_local_old_shadow.VC, 
      og_local_old_sx.W, 
      og_local_old_sx.R, 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assume false;
    return;
}



implementation {:inline 1} Impl_YieldChecker_Yield30_10(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var tid: Tid;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, og_local_old_shadow.Lock, og_global_old_shadow.Lock);
    assume FTRepOk(og_global_old_shadow.VC, og_global_old_sx.W, og_global_old_sx.R);
    assume FTPreserved(tid, 
      og_local_old_shadow.Lock, 
      og_local_old_shadow.VC, 
      og_local_old_sx.W, 
      og_local_old_sx.R, 
      og_global_old_shadow.Lock, 
      og_global_old_shadow.VC, 
      og_global_old_sx.W, 
      og_global_old_sx.R);
    assert ValidTid(tid);
    assert LocksPreserved(tid, og_local_old_shadow.Lock, shadow.Lock);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assert FTPreserved(tid, 
      og_local_old_shadow.Lock, 
      og_local_old_shadow.VC, 
      og_local_old_sx.W, 
      og_local_old_sx.R, 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assume false;
    return;
}



implementation {:inline 1} Impl_YieldChecker_Driver_10(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var x: Var;
  var l: Lock;
  var uid: Tid;
  var tid: Tid;
  var ok: bool;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume false;
    return;
}



procedure {:inline 1} og_yield_10(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



implementation {:inline 1} og_yield_10(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{

  enter:
    goto L_0, L_1, L_2, L_3;

  L_0:
    call Impl_YieldChecker_Yield10_10(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;

  L_1:
    call Impl_YieldChecker_Yield20_10(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;

  L_2:
    call Impl_YieldChecker_Yield30_10(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;

  L_3:
    call Impl_YieldChecker_Driver_10(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;
}



procedure Yield20_20(tid: Tid);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTPreserved(tid, 
    old(shadow.Lock), 
    old(shadow.VC), 
    old(sx.W), 
    old(sx.R), 
    shadow.Lock, 
    shadow.VC, 
    sx.W, 
    sx.R);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);



procedure Fork_20(tid: Tid, uid: Tid);
  requires ValidTid(tid);
  requires ValidTid(uid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[ShadowableTid(uid)] == tid;
  requires tid != uid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures (forall s: Shadowable :: 
    s != ShadowableTid(tid) && s != ShadowableTid(uid)
       ==> 
      old(shadow.Lock)[s] == tid
       ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure Join_20(tid: Tid, uid: Tid);
  requires ValidTid(tid);
  requires ValidTid(uid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[ShadowableTid(uid)] == tid;
  requires tid != uid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures (forall s: Shadowable :: 
    s != ShadowableTid(tid) && old(shadow.Lock)[s] == tid
       ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure Acquire_20(tid: Tid, l: Lock);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[ShadowableLock(l)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures (forall s: Shadowable :: 
    s != ShadowableTid(tid) && old(shadow.Lock)[s] == tid
       ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure Release_20(tid: Tid, l: Lock);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires shadow.Lock[ShadowableLock(l)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);
  ensures (forall s: Shadowable :: 
    s != ShadowableTid(tid) && s != ShadowableLock(l) && old(shadow.Lock)[s] == tid
       ==> old(shadow.VC)[s] == shadow.VC[s]);



procedure Write_20(tid: Tid, x: Var) returns (ok: bool);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);



procedure Read_20(tid: Tid, x: Var) returns (ok: bool);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);



procedure Yield30_20(tid: Tid);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires FTRepOk(shadow.VC, sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures FTRepOk(shadow.VC, sx.W, sx.R);



procedure Driver_20(tid: Tid) returns (ok: bool);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
  requires VarsRepOk(sx.W, sx.R);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



implementation Yield20_20(tid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    yield;
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    goto anon05, CallToYieldProc;

  anon017:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_ok;
    return;

  anon05:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset);
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assume FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assume FTRepOk(shadow.VC, sx.W, sx.R);
    goto anon017, CallToYieldProc;

  CallToYieldProc:
    call og_yield_20(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Fork_20(tid: Tid, uid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Join(tid, ShadowableTid(uid), ShadowableTid(tid));
    call VC.Inc(tid, ShadowableTid(tid), tid);
    call Yield20(tid);
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon037:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    assert og_ok;
    return;

  anon029:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    call Yield20_20(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && ValidTid(uid)
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[ShadowableTid(uid)] == tid
         && tid != uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon037, CallToYieldProc;

  anon00:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(uid) := #tmp_0_second_vcNew][ShadowableTid(uid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    call Yield20_20(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && ValidTid(uid)
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[ShadowableTid(uid)] == tid
         && tid != uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert !is#ShadowableVar(ShadowableTid(uid));
    assert !is#ShadowableVar(ShadowableTid(tid));
    assert VCRepOk(shadow.VC[ShadowableTid(tid)]);
    // injected gate >>>
    call AtomicVC.Join_20(tid, ShadowableTid(uid), ShadowableTid(tid));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert !is#ShadowableVar(ShadowableTid(tid));
    assert tid >= 0;
    assert VCRepOk(shadow.VC[ShadowableTid(tid)]);
    // injected gate >>>
    call AtomicVC.Inc_20(tid, ShadowableTid(tid), tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon029, CallToYieldProc;

  CallToYieldProc:
    call og_yield_20(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Join_20(tid: Tid, uid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Join(tid, ShadowableTid(tid), ShadowableTid(uid));
    call Yield20(tid);
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon027:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    assert og_ok;
    return;

  anon019:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    call Yield20_20(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && ValidTid(uid)
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[ShadowableTid(uid)] == tid
         && tid != uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon027, CallToYieldProc;

  anon00:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(uid)], 
                    second_j)))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)])
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(uid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)])));
    call Yield20_20(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && ValidTid(uid)
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[ShadowableTid(uid)] == tid
         && tid != uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert !is#ShadowableVar(ShadowableTid(tid));
    assert !is#ShadowableVar(ShadowableTid(uid));
    assert VCRepOk(shadow.VC[ShadowableTid(uid)]);
    // injected gate >>>
    call AtomicVC.Join_20(tid, ShadowableTid(tid), ShadowableTid(uid));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon019, CallToYieldProc;

  CallToYieldProc:
    call og_yield_20(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Acquire_20(tid: Tid, l: Lock)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Join(tid, ShadowableTid(tid), ShadowableLock(l));
    call Yield20(tid);
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon027:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                    second_j)))
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)]));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                    second_j)))
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)]));
    assert og_ok;
    return;

  anon019:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                    second_j)))
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)]));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                    second_j)))
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)]));
    call Yield20_20(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[ShadowableLock(l)] == tid
         && shadow.Lock[ShadowableTid(tid)] == tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon027, CallToYieldProc;

  anon00:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                    second_j)))
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)]));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || (exists #tmp_0_second_vcNew: VC :: 
        shadow.VC == og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j)
                 == EpochMax(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j), 
                  VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                    second_j)))
           && VCArrayLen(#tmp_0_second_vcNew)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]))
           && VCRepOk(og_global_old_shadow.VC[ShadowableTid(tid) := #tmp_0_second_vcNew][ShadowableTid(tid)]));
    call Yield20_20(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[ShadowableLock(l)] == tid
         && shadow.Lock[ShadowableTid(tid)] == tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableLock(l)] == tid;
    assert !is#ShadowableVar(ShadowableTid(tid));
    assert !is#ShadowableVar(ShadowableLock(l));
    assert VCRepOk(shadow.VC[ShadowableLock(l)]);
    // injected gate >>>
    call AtomicVC.Join_20(tid, ShadowableTid(tid), ShadowableLock(l));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon019, CallToYieldProc;

  CallToYieldProc:
    call og_yield_20(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Release_20(tid: Tid, l: Lock)
{
  var sm: Shadowable;
  var st: Shadowable;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call VC.Copy(tid, ShadowableLock(l), ShadowableTid(tid));
    call VC.Inc(tid, ShadowableTid(tid), tid);
    call Yield20(tid);
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon039:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j))
           && VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)])
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)]))
           && VCRepOk(#tmp_0_second_vcNew))
       || (exists #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j))
           && VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)])
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)]))
           && VCRepOk(#tmp_0_second_vcNew))
       || (exists #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2));
    assert og_ok;
    return;

  anon031:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j))
           && VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)])
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)]))
           && VCRepOk(#tmp_0_second_vcNew))
       || (exists #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j))
           && VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)])
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)]))
           && VCRepOk(#tmp_0_second_vcNew))
       || (exists #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2));
    call Yield20_20(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[ShadowableLock(l)] == tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon039, CallToYieldProc;

  anon00:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j))
           && VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)])
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)]))
           && VCRepOk(#tmp_0_second_vcNew))
       || (exists #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (exists #tmp_0_second_vcNew: VC, #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2)
           && (forall second_j: int :: 
            0 <= second_j
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)], 
                  second_j))
           && VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableLock(l)])
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l)]), 
              VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := #tmp_0_second_vcNew][ShadowableTid(tid)]))
           && VCRepOk(#tmp_0_second_vcNew))
       || (exists #tmp_1_second_vcNew2: VC :: 
        shadow.VC
             == og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2]
           && shadow.Lock == og_global_old_shadow.Lock
           && sx.W == og_global_old_sx.W
           && sx.R == og_global_old_sx.R
           && thread.State == og_global_old_thread.State
           && thread.ForkedBy == og_global_old_thread.ForkedBy
           && thread.HasJoined == og_global_old_thread.HasJoined
           && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
           && VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
              tid)
             == EpochInc(VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
           && (forall second_j: int :: 
            0 <= second_j && second_j != tid
               ==> VCArrayGet(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)], 
                  second_j)
                 == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j))
           && VCArrayLen(#tmp_1_second_vcNew2)
             == max(VCArrayLen(og_global_old_shadow.VC[ShadowableLock(l) := og_global_old_shadow.VC[ShadowableTid(tid)]][ShadowableTid(tid) := #tmp_1_second_vcNew2][ShadowableTid(tid)]), 
              tid + 1)
           && VCRepOk(#tmp_1_second_vcNew2));
    call Yield20_20(tid);
    assume og_pc
       || (
        ValidTid(tid)
         && shadow.Lock[ShadowableTid(tid)] == tid
         && shadow.Lock[ShadowableLock(l)] == tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert ShadowableLock(l) != ShadowableTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableLock(l)] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert !is#ShadowableVar(ShadowableLock(l));
    assert !is#ShadowableVar(ShadowableTid(tid));
    assert VCRepOk(shadow.VC[ShadowableTid(tid)]);
    assert VCRepOk(shadow.VC[ShadowableLock(l)]);
    // injected gate >>>
    call AtomicVC.Copy_20(tid, ShadowableLock(l), ShadowableTid(tid));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert !is#ShadowableVar(ShadowableTid(tid));
    assert tid >= 0;
    assert VCRepOk(shadow.VC[ShadowableTid(tid)]);
    // injected gate >>>
    call AtomicVC.Inc_20(tid, ShadowableTid(tid), tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon031, CallToYieldProc;

  CallToYieldProc:
    call og_yield_20(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Write_20(tid: Tid, x: Var) returns (ok: bool)
{
  var e: Epoch;
  var w: Epoch;
  var vw: Epoch;
  var r: Epoch;
  var vr: Epoch;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var og_old_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call e := ThreadStateGetE(tid);
    call w := VarStateGetWNoLock(tid, x);
    if (w == e)
    {
        ok := true;
        call Yield20(tid);
        return;
    }

    call Yield20(tid);
    call AcquireVarLock(tid, x);
    call w := VarStateGetW(tid, x);
    call vw := VCGetElem(tid, ShadowableTid(tid), tid#epoch(w));
    if (!EpochLeq(w, vw))
    {
        call ReleaseVarLock(tid, x);
        ok := false;
        call Yield20(tid);
        return;
    }

    call r := VarStateGetR(tid, x);
    if (r != SHARED)
    {
        call vr := VCGetElem(tid, ShadowableTid(tid), tid#epoch(r));
        if (!EpochLeq(r, vr))
        {
            call ReleaseVarLock(tid, x);
            ok := false;
            call Yield20(tid);
            return;
        }

        call VarStateSetW(tid, x, e);
    }
    else
    {
        call ok := VC.Leq(tid, ShadowableVar(x), ShadowableTid(tid));
        if (!ok)
        {
            call ReleaseVarLock(tid, x);
            ok := false;
            call Yield20(tid);
            return;
        }

        call VarStateSetW(tid, x, e);
    }

    call ReleaseVarLock(tid, x);
    ok := true;
    call Yield20(tid);
    return;
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon12_Else:
    assume {:partition} w != e;
    goto anon2;

  anon2:
    goto anon20, CallToYieldProc;

  anon13_Else:
    assume {:partition} EpochLeq(w, vw);
    goto anon4;

  anon4:
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call r := AtomicVarStateGetR_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} r == SHARED;
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert is#ShadowableVar(ShadowableVar(x))
       ==> sx.R[x#ShadowableVar(ShadowableVar(x))] == SHARED;
    assert !is#ShadowableVar(ShadowableTid(tid));
    // injected gate >>>
    call ok := AtomicVC.Leq_20(tid, ShadowableVar(x), ShadowableTid(tid));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Then, anon16_Else;

  anon16_Else:
    assume {:partition} ok;
    goto anon10;

  anon10:
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVarStateSetW_20(tid, x, e);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon11;

  anon11:
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon117, CallToYieldProc;

  anon16_Then:
    assume {:partition} !ok;
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon16_Then8, CallToYieldProc;

  anon14_Then:
    assume {:partition} r != SHARED;
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call vr := AtomicVCGetElem_20(tid, ShadowableTid(tid), tid#epoch(r));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then, anon15_Else;

  anon15_Else:
    assume {:partition} EpochLeq(r, vr);
    goto anon7;

  anon7:
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVarStateSetW_20(tid, x, e);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon11;

  anon15_Then:
    assume {:partition} !EpochLeq(r, vr);
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon15_Then8, CallToYieldProc;

  anon13_Then:
    assume {:partition} !EpochLeq(w, vw);
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon13_Then8, CallToYieldProc;

  anon12_Then:
    assume {:partition} w == e;
    ok := true;
    goto anon12_Then2, CallToYieldProc;

  anon00:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    call Yield20_20(tid);
    assume og_pc || ValidTid(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call e := AtomicThreadStateGetE_20(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    // injected gate >>>
    call w := AtomicVarStateGetWNoLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon12_Then, anon12_Else;

  anon20:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    call Yield20_20(tid);
    assume og_pc || ValidTid(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    // injected gate >>>
    call AtomicAcquireVarLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call w := AtomicVarStateGetW_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call vw := AtomicVCGetElem_20(tid, ShadowableTid(tid), tid#epoch(w));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then, anon13_Else;

  anon1115:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_ok;
    return;

  anon117:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    call Yield20_20(tid);
    assume og_pc || ValidTid(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon1115, CallToYieldProc;

  anon16_Then16:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_ok;
    return;

  anon16_Then8:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    call Yield20_20(tid);
    assume og_pc || ValidTid(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Then16, CallToYieldProc;

  anon15_Then16:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_ok;
    return;

  anon15_Then8:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    call Yield20_20(tid);
    assume og_pc || ValidTid(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then16, CallToYieldProc;

  anon13_Then16:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_ok;
    return;

  anon13_Then8:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    call Yield20_20(tid);
    assume og_pc || ValidTid(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then16, CallToYieldProc;

  anon12_Then10:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_ok;
    return;

  anon12_Then2:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.W[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W
           == og_global_old_sx.W[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && (forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !(forall second_j: int :: 
          { f(second_j) } 
          0 <= second_j
               && second_j
                 < max(VCArrayLen(og_global_old_shadow.VC[ShadowableTid(tid)]), 
                  VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x)]))
               && f(second_j)
             ==> EpochLeq(VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], second_j), 
              VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], second_j)))
         && og_global_old_sx.R[x] == SHARED);
    call Yield20_20(tid);
    assume og_pc || ValidTid(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon12_Then10, CallToYieldProc;

  CallToYieldProc:
    call og_yield_20(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Read_20(tid: Tid, x: Var) returns (ok: bool)
{
  var e: Epoch;
  var w: Epoch;
  var vw: Epoch;
  var r: Epoch;
  var vr: Epoch;
  var xVC: VC;
  var stVC: VC;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var og_old_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield20(tid);
    call e := ThreadStateGetE(tid);
    if (*)
    {
        call r := VarStateGetRNoLock(tid, x);
        assume r != SHARED;
        if (r == e)
        {
            ok := true;
            call Yield20(tid);
            return;
        }
    }
    else
    {
        call r := VarStateGetRShared(tid, x);
        assume r == SHARED;
        call vw := VCGetElemShared(tid, x);
        if (vw == e)
        {
            ok := true;
            call Yield20(tid);
            return;
        }
    }

    call Yield20(tid);
    call AcquireVarLock(tid, x);
    call w := VarStateGetW(tid, x);
    call vw := VCGetElem(tid, ShadowableTid(tid), tid#epoch(w));
    if (!EpochLeq(w, vw))
    {
        call ReleaseVarLock(tid, x);
        ok := false;
        call Yield20(tid);
        return;
    }

    call r := VarStateGetR(tid, x);
    if (r != SHARED)
    {
        call vr := VCGetElem(tid, ShadowableTid(tid), tid#epoch(r));
        if (EpochLeq(r, vr))
        {
            assert tid#epoch(e) >= 0;
            call VarStateSetR(tid, x, e);
            call ReleaseVarLock(tid, x);
            ok := true;
            call Yield20(tid);
            return;
        }
        else
        {
            call VCInit(tid, ShadowableVar(x));
            call VCSetElem(tid, ShadowableVar(x), tid#epoch(r), r);
            call VCSetElem(tid, ShadowableVar(x), tid, e);
            call VarStateSetR(tid, x, SHARED);
            call ReleaseVarLock(tid, x);
            ok := true;
            call Yield20(tid);
            return;
        }
    }
    else
    {
        call VCSetElemShared(tid, x, e);
        call ReleaseVarLock(tid, x);
        ok := true;
        call Yield20(tid);
        return;
    }
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon12_Else:
    // <<< injected gate
    assert ValidTid(tid);
    // injected gate >>>
    call r := AtomicVarStateGetRShared_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume r == SHARED;
    // <<< injected gate
    assert sx.R[x] == SHARED;
    assert ValidTid(tid);
    // injected gate >>>
    call vw := AtomicVCGetElemShared_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then, anon14_Else;

  anon14_Else:
    assume {:partition} vw != e;
    goto anon5;

  anon5:
    goto anon50, CallToYieldProc;

  anon15_Else:
    assume {:partition} EpochLeq(w, vw);
    goto anon7;

  anon7:
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call r := AtomicVarStateGetR_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Then, anon16_Else;

  anon16_Else:
    assume {:partition} r == SHARED;
    // <<< injected gate
    assert sx.R[x] == SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVCSetElemShared_20(tid, x, e);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon16_Else15, CallToYieldProc;

  anon16_Then:
    assume {:partition} r != SHARED;
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call vr := AtomicVCGetElem_20(tid, ShadowableTid(tid), tid#epoch(r));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Then, anon17_Else;

  anon17_Else:
    assume {:partition} !EpochLeq(r, vr);
    // <<< injected gate
    assert ValidTid(tid);
    assert is#ShadowableVar(ShadowableVar(x))
       ==> sx.R[x#ShadowableVar(ShadowableVar(x))] != SHARED;
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVCInit_20(tid, ShadowableVar(x));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert is#ShadowableVar(ShadowableVar(x))
       ==> sx.R[x#ShadowableVar(ShadowableVar(x))] != SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVCSetElem_20(tid, ShadowableVar(x), tid#epoch(r), r);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert is#ShadowableVar(ShadowableVar(x))
       ==> sx.R[x#ShadowableVar(ShadowableVar(x))] != SHARED;
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicVCSetElem_20(tid, ShadowableVar(x), tid, e);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    assert sx.R[x] != SHARED;
    // injected gate >>>
    call AtomicVarStateSetR_20(tid, x, SHARED);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon17_Else36, CallToYieldProc;

  anon17_Then:
    assume {:partition} EpochLeq(r, vr);
    assert tid#epoch(e) >= 0;
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    assert sx.R[x] != SHARED;
    // injected gate >>>
    call AtomicVarStateSetR_20(tid, x, e);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon17_Then16, CallToYieldProc;

  anon15_Then:
    assume {:partition} !EpochLeq(w, vw);
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call AtomicReleaseVarLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := false;
    goto anon15_Then8, CallToYieldProc;

  anon14_Then:
    assume {:partition} vw == e;
    ok := true;
    goto anon14_Then2, CallToYieldProc;

  anon12_Then:
    // <<< injected gate
    assert ValidTid(tid);
    // injected gate >>>
    call r := AtomicVarStateGetRNoLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume r != SHARED;
    goto anon13_Then, anon13_Else;

  anon13_Else:
    assume {:partition} r != e;
    goto anon5;

  anon13_Then:
    assume {:partition} r == e;
    ok := true;
    goto anon13_Then2, CallToYieldProc;

  anon00:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    call Yield20_20(tid);
    assume og_pc || (ValidTid(tid) && tid != nil && tid >= 0 && tid >= 0);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call e := AtomicThreadStateGetE_20(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon12_Then, anon12_Else;

  anon50:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    call Yield20_20(tid);
    assume og_pc || (ValidTid(tid) && tid != nil && tid >= 0 && tid >= 0);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    // injected gate >>>
    call AtomicAcquireVarLock_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableVar(x)] == tid;
    // injected gate >>>
    call w := AtomicVarStateGetW_20(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call vw := AtomicVCGetElem_20(tid, ShadowableTid(tid), tid#epoch(w));
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then, anon15_Else;

  anon16_Else23:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_ok;
    return;

  anon16_Else15:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    call Yield20_20(tid);
    assume og_pc || (ValidTid(tid) && tid != nil && tid >= 0 && tid >= 0);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon16_Else23, CallToYieldProc;

  anon17_Else44:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_ok;
    return;

  anon17_Else36:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    call Yield20_20(tid);
    assume og_pc || (ValidTid(tid) && tid != nil && tid >= 0 && tid >= 0);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Else44, CallToYieldProc;

  anon17_Then24:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_ok;
    return;

  anon17_Then16:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    call Yield20_20(tid);
    assume og_pc || (ValidTid(tid) && tid != nil && tid >= 0 && tid >= 0);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon17_Then24, CallToYieldProc;

  anon15_Then16:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_ok;
    return;

  anon15_Then8:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    call Yield20_20(tid);
    assume og_pc || (ValidTid(tid) && tid != nil && tid >= 0 && tid >= 0);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then16, CallToYieldProc;

  anon14_Then10:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_ok;
    return;

  anon14_Then2:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    call Yield20_20(tid);
    assume og_pc || (ValidTid(tid) && tid != nil && tid >= 0 && tid >= 0);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then10, CallToYieldProc;

  anon13_Then10:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_ok;
    return;

  anon13_Then2:
    assert og_pc
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset)
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    assert og_pc
       ==> shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       ==> og_pc, og_ok
       || 
      (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && og_global_old_sx.R[x]
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid))
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x)], tid)
           == VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R
           == og_global_old_sx.R[x := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.R[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.R[x])))
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)], 
            max(VCArrayLen(og_global_old_shadow.VC[ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid)]][ShadowableVar(x)]), 
              tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] == SHARED)
       || (
        shadow.VC
           == og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
            tid)]][ShadowableVar(x) := VCArraySetLen(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableVar(x)][tid := VCArrayGet(og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x) := og_global_old_shadow.VC[ShadowableVar(x) := VC.bottom()][ShadowableVar(x)][tid#epoch(og_global_old_sx.R[x]) := og_global_old_sx.R[x]]][ShadowableTid(tid)], 
              tid)]][ShadowableVar(x)], 
            max(tid#epoch(og_global_old_sx.R[x]) + 1, tid + 1))]
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R[x := SHARED]
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> true)
         && EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x])))
         && og_global_old_sx.R[x] != SHARED)
       || (
        shadow.VC == og_global_old_shadow.VC
         && shadow.Lock == og_global_old_shadow.Lock
         && sx.W == og_global_old_sx.W
         && sx.R == og_global_old_sx.R
         && thread.State == og_global_old_thread.State
         && thread.ForkedBy == og_global_old_thread.ForkedBy
         && thread.HasJoined == og_global_old_thread.HasJoined
         && pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> false)
         && !EpochLeq(og_global_old_sx.W[x], 
          VCArrayGet(og_global_old_shadow.VC[ShadowableTid(tid)], tid#epoch(og_global_old_sx.W[x]))));
    call Yield20_20(tid);
    assume og_pc || (ValidTid(tid) && tid != nil && tid >= 0 && tid >= 0);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then10, CallToYieldProc;

  CallToYieldProc:
    call og_yield_20(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Yield30_20(tid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    yield;
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert thread.State[tid] == RUNNING();
    assert (forall t: Tid :: 
      old(shadow.Lock)[ShadowableTid(t)] == tid
         ==> thread.State[t] == old(thread.State)[t]);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    goto anon05, CallToYieldProc;

  anon013:
    return;

  anon05:
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assume FTRepOk(shadow.VC, sx.W, sx.R);
    assume FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    goto anon013, CallToYieldProc;

  CallToYieldProc:
    call og_yield_20(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Driver_20(tid: Tid) returns (ok: bool)
{
  var x: Var;
  var l: Lock;
  var uid: Tid;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    call Yield30(tid);
    ok := true;
    while (ok)
      invariant ValidTid(tid);
      invariant shadow.Lock[ShadowableTid(tid)] == tid;
      invariant thread.State[tid] == RUNNING();
      invariant (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
      invariant VarsRepOk(sx.W, sx.R);
      invariant (forall t: Tid :: 
        thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    {
        if (*)
        {
            havoc x;
            call ok := Write(tid, x);
        }
        else if (*)
        {
            havoc x;
            call ok := Read(tid, x);
        }
        else if (*)
        {
            assert shadow.Lock[ShadowableTid(tid)] == tid;
            call l := ChooseLockToAcquire(tid);
            call Yield30(tid);
            call Acquire(tid, l);
        }
        else if (*)
        {
            call l := ChooseLockToRelease(tid);
            call Yield30(tid);
            call Release(tid, l);
            call Yield30(tid);
            call ReleaseChosenLock(tid, l);
            call Yield30(tid);
        }
        else if (*)
        {
            call uid := AllocTid(tid);
            assert shadow.Lock[ShadowableTid(tid)] == tid;
            assert shadow.Lock[ShadowableTid(uid)] == tid;
            assert (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
            assert tid != uid;
            assert ValidTid(tid);
            assert ValidTid(uid);
            call Yield30(tid);
            assert ValidTid(tid);
            assert ValidTid(uid);
            call Fork(tid, uid);
            call Yield30(tid);
            call StartThread(tid, uid);
            call Yield30(tid);
        }
        else
        {
            call Yield30(tid);
            call uid := ChooseThreadToJoin(tid);
            call Yield30(tid);
            call Join(tid, uid);
            call Yield30(tid);
            call ReleaseJoinLock(tid, uid);
            call Yield30(tid);
        }

        call Yield30(tid);
        assert shadow.Lock[ShadowableTid(tid)] == tid;
    }

    yield;
  **** end structured program */

  og_init:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon10_LoopHead:
    assume linear_tid_available
       == linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false));
    assume shadow.VC == og_global_old_shadow.VC;
    assume shadow.Lock == og_global_old_shadow.Lock;
    assume sx.W == og_global_old_sx.W;
    assume sx.R == og_global_old_sx.R;
    assume thread.State == og_global_old_thread.State;
    assume thread.ForkedBy == og_global_old_thread.ForkedBy;
    assume thread.HasJoined == og_global_old_thread.HasJoined;
    assume pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
    assert VarsRepOk(sx.W, sx.R);
    goto anon10_LoopDone, anon10_LoopBody;

  anon10_LoopBody:
    assume {:partition} ok;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    goto anon12_Then, anon12_Else;

  anon12_Else:
    goto anon13_Then, anon13_Else;

  anon13_Else:
    goto anon14_Then, anon14_Else;

  anon14_Else:
    goto anon15_Then, anon15_Else;

  anon15_Else:
    goto anon15_Else0, CallToYieldProc;

  anon8:
    goto anon80, CallToYieldProc;

  anon15_Then:
    // <<< injected gate
    assume thread.State[tid] == RUNNING() && ValidTid(tid);
    assume (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    // injected gate >>>
    call uid := AtomicAllocTid_20(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
    assert tid != uid;
    assert ValidTid(tid);
    assert ValidTid(uid);
    goto anon15_Then12, CallToYieldProc;

  anon14_Then:
    // <<< injected gate
    assume ValidTid(tid);
    // injected gate >>>
    call l := AtomicChooseLockToRelease_20(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then5, CallToYieldProc;

  anon13_Then:
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    // <<< injected gate
    assume ValidTid(tid);
    // injected gate >>>
    call l := AtomicChooseLockToAcquire_20(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then6, CallToYieldProc;

  anon12_Then:
    havoc x;
    goto anon12_Then1, CallToYieldProc;

  anon11_Then:
    havoc x;
    goto anon11_Then1, CallToYieldProc;

  anon10_LoopDone:
    assume {:partition} !ok;
    goto anon9;

  anon9:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon91, CallToYieldProc;

  anon05:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon10_LoopHead;

  anon00:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon05, CallToYieldProc;

  anon15_Else29:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon15_Else17:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume ValidTid(uid);
    assume tid != uid;
    assume shadow.Lock[ShadowableTid(uid)] == tid;
    // injected gate >>>
    call AtomicReleaseJoinLock_20(tid, uid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else29, CallToYieldProc;

  anon15_Else13:
    call Join_20(tid, uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else17, CallToYieldProc;

  anon15_Else9:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else13, CallToYieldProc;

  anon15_Else0:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume thread.State[tid] == RUNNING() && ValidTid(tid);
    // injected gate >>>
    call uid := AtomicChooseThreadToJoin_20(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else9, CallToYieldProc;

  anon85:
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon10_LoopHead;

  anon80:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    goto anon85, CallToYieldProc;

  anon15_Then35:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon15_Then22:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume ValidTid(uid);
    assume tid != uid;
    assume shadow.Lock[ShadowableTid(uid)] == tid;
    assume thread.State[uid] == NEW();
    // injected gate >>>
    call AtomicStartThread_20(tid, uid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then35, CallToYieldProc;

  anon15_Then18:
    call Fork_20(tid, uid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then22, CallToYieldProc;

  anon15_Then12:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert ValidTid(uid);
    goto anon15_Then18, CallToYieldProc;

  anon14_Then23:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon14_Then13:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assume ValidTid(tid);
    assume shadow.Lock[ShadowableLock(l)] == tid;
    // injected gate >>>
    call AtomicReleaseChosenLock_20(tid, l);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then23, CallToYieldProc;

  anon14_Then9:
    call Release_20(tid, l);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then13, CallToYieldProc;

  anon14_Then5:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then9, CallToYieldProc;

  anon13_Then10:
    call Acquire_20(tid, l);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon13_Then6:
    call Yield30_20(tid);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then10, CallToYieldProc;

  anon12_Then1:
    call ok := Read_20(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon11_Then1:
    call ok := Write_20(tid, x);
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon95:
    return;

  anon91:
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon95, CallToYieldProc;

  CallToYieldProc:
    call og_yield_20(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



procedure {:inline 1} Impl_YieldChecker_Yield20_20(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



procedure {:inline 1} Impl_YieldChecker_Yield30_20(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



procedure {:inline 1} Impl_YieldChecker_Driver_20(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



implementation {:inline 1} Impl_YieldChecker_Yield20_20(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var tid: Tid;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, og_local_old_shadow.Lock, og_global_old_shadow.Lock);
    assume FTPreserved(tid, 
      og_local_old_shadow.Lock, 
      og_local_old_shadow.VC, 
      og_local_old_sx.W, 
      og_local_old_sx.R, 
      og_global_old_shadow.Lock, 
      og_global_old_shadow.VC, 
      og_global_old_sx.W, 
      og_global_old_sx.R);
    assume FTRepOk(og_global_old_shadow.VC, og_global_old_sx.W, og_global_old_sx.R);
    assert ValidTid(tid);
    assert LocksPreserved(tid, og_local_old_shadow.Lock, shadow.Lock);
    assert FTPreserved(tid, 
      og_local_old_shadow.Lock, 
      og_local_old_shadow.VC, 
      og_local_old_sx.W, 
      og_local_old_sx.R, 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assume false;
    return;
}



implementation {:inline 1} Impl_YieldChecker_Yield30_20(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var tid: Tid;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, og_local_old_shadow.Lock, og_global_old_shadow.Lock);
    assume FTRepOk(og_global_old_shadow.VC, og_global_old_sx.W, og_global_old_sx.R);
    assume FTPreserved(tid, 
      og_local_old_shadow.Lock, 
      og_local_old_shadow.VC, 
      og_local_old_sx.W, 
      og_local_old_sx.R, 
      og_global_old_shadow.Lock, 
      og_global_old_shadow.VC, 
      og_global_old_sx.W, 
      og_global_old_sx.R);
    assert ValidTid(tid);
    assert LocksPreserved(tid, og_local_old_shadow.Lock, shadow.Lock);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assert FTPreserved(tid, 
      og_local_old_shadow.Lock, 
      og_local_old_shadow.VC, 
      og_local_old_sx.W, 
      og_local_old_sx.R, 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assume false;
    return;
}



implementation {:inline 1} Impl_YieldChecker_Driver_20(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var x: Var;
  var l: Lock;
  var uid: Tid;
  var tid: Tid;
  var ok: bool;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume false;
    return;
}



procedure {:inline 1} og_yield_20(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



implementation {:inline 1} og_yield_20(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{

  enter:
    goto L_0, L_1, L_2;

  L_0:
    call Impl_YieldChecker_Yield20_20(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;

  L_1:
    call Impl_YieldChecker_Yield30_20(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;

  L_2:
    call Impl_YieldChecker_Driver_20(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;
}



procedure Yield30_30(tid: Tid);
  requires ValidTid(tid);
  requires thread.State[tid] == RUNNING();
  requires (forall t: Tid :: 
    thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
  ensures LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
  ensures thread.State[tid] == RUNNING();
  ensures (forall t: Tid :: 
    old(shadow.Lock)[ShadowableTid(t)] == tid
       ==> thread.State[t] == old(thread.State)[t]);
  ensures (forall t: Tid :: 
    thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);



procedure Driver_30(tid: Tid) returns (ok: bool);
  requires ValidTid(tid);
  requires shadow.Lock[ShadowableTid(tid)] == tid;
  requires thread.State[tid] == RUNNING();
  requires (forall t: Tid :: 
    thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
  modifies shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;



implementation Yield30_30(tid: Tid)
{
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var linear_tid_available: [Tid]bool;

  /*** structured program:
    yield;
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert FTRepOk(shadow.VC, sx.W, sx.R);
    assert FTPreserved(tid, 
      old(shadow.Lock), 
      old(shadow.VC), 
      old(sx.W), 
      old(sx.R), 
      shadow.Lock, 
      shadow.VC, 
      sx.W, 
      sx.R);
    assert thread.State[tid] == RUNNING();
    assert (forall t: Tid :: 
      old(shadow.Lock)[ShadowableTid(t)] == tid
         ==> thread.State[t] == old(thread.State)[t]);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
  **** end structured program */

  og_init:
    og_pc, og_ok, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    goto anon0;

  anon0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assert thread.State[tid] == RUNNING();
    assert (forall t: Tid :: 
      old(shadow.Lock)[ShadowableTid(t)] == tid
         ==> thread.State[t] == old(thread.State)[t]);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    goto anon06, CallToYieldProc;

  anon019:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_ok;
    return;

  anon06:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, old(shadow.Lock), shadow.Lock);
    assume thread.State[tid] == RUNNING();
    assume (forall t: Tid :: 
      old(shadow.Lock)[ShadowableTid(t)] == tid
         ==> thread.State[t] == old(thread.State)[t]);
    assume (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    goto anon019, CallToYieldProc;

  CallToYieldProc:
    call og_yield_30(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



implementation Driver_30(tid: Tid) returns (ok: bool)
{
  var x: Var;
  var l: Lock;
  var uid: Tid;
  var og_global_old_shadow.VC: [Shadowable]VC;
  var og_global_old_shadow.Lock: [Shadowable]Tid;
  var og_global_old_sx.W: [Var]Epoch;
  var og_global_old_sx.R: [Var]Epoch;
  var og_global_old_thread.State: [Tid]ThreadStatus;
  var og_global_old_thread.ForkedBy: [Tid]Tid;
  var og_global_old_thread.HasJoined: [Tid,Tid]bool;
  var og_global_old_pendingAsyncMultiset: [PendingAsync]int;
  var og_pc: bool;
  var og_ok: bool;
  var og_old_ok: bool;
  var linear_tid_available: [Tid]bool;
  var og_pc_anon10_LoopHead: bool;
  var og_ok_anon10_LoopHead: bool;

  /*** structured program:
    call Yield30(tid);
    ok := true;
    while (ok)
      invariant ValidTid(tid);
      invariant shadow.Lock[ShadowableTid(tid)] == tid;
      invariant thread.State[tid] == RUNNING();
      invariant (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
      invariant VarsRepOk(sx.W, sx.R);
      invariant (forall t: Tid :: 
        thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    {
        if (*)
        {
            havoc x;
            call ok := Write(tid, x);
        }
        else if (*)
        {
            havoc x;
            call ok := Read(tid, x);
        }
        else if (*)
        {
            assert shadow.Lock[ShadowableTid(tid)] == tid;
            call l := ChooseLockToAcquire(tid);
            call Yield30(tid);
            call Acquire(tid, l);
        }
        else if (*)
        {
            call l := ChooseLockToRelease(tid);
            call Yield30(tid);
            call Release(tid, l);
            call Yield30(tid);
            call ReleaseChosenLock(tid, l);
            call Yield30(tid);
        }
        else if (*)
        {
            call uid := AllocTid(tid);
            assert shadow.Lock[ShadowableTid(tid)] == tid;
            assert shadow.Lock[ShadowableTid(uid)] == tid;
            assert (forall s: Shadowable :: VCRepOk(shadow.VC[s]));
            assert tid != uid;
            assert ValidTid(tid);
            assert ValidTid(uid);
            call Yield30(tid);
            assert ValidTid(tid);
            assert ValidTid(uid);
            call Fork(tid, uid);
            call Yield30(tid);
            call StartThread(tid, uid);
            call Yield30(tid);
        }
        else
        {
            call Yield30(tid);
            call uid := ChooseThreadToJoin(tid);
            call Yield30(tid);
            call Join(tid, uid);
            call Yield30(tid);
            call ReleaseJoinLock(tid, uid);
            call Yield30(tid);
        }

        call Yield30(tid);
        assert shadow.Lock[ShadowableTid(tid)] == tid;
    }

    yield;
  **** end structured program */

  og_init:
    og_pc, og_pc_anon10_LoopHead, og_ok, og_ok_anon10_LoopHead, linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := false, false, false, false, linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    goto anon0;

  anon0:
    goto anon00, CallToYieldProc;

  anon10_LoopHead:
    assert og_pc_anon10_LoopHead == og_pc;
    assert og_ok_anon10_LoopHead ==> og_ok;
    assume linear_tid_available
       == linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false));
    assume shadow.VC == og_global_old_shadow.VC;
    assume shadow.Lock == og_global_old_shadow.Lock;
    assume sx.W == og_global_old_sx.W;
    assume sx.R == og_global_old_sx.R;
    assume thread.State == og_global_old_thread.State;
    assume thread.ForkedBy == og_global_old_thread.ForkedBy;
    assume thread.HasJoined == og_global_old_thread.HasJoined;
    assume pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assume ok == og_old_ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert thread.State[tid] == RUNNING();
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    goto anon10_LoopDone, anon10_LoopBody;

  anon10_LoopBody:
    assume {:partition} ok;
    goto anon11_Then, anon11_Else;

  anon11_Else:
    goto anon12_Then, anon12_Else;

  anon12_Else:
    goto anon13_Then, anon13_Else;

  anon13_Else:
    goto anon14_Then, anon14_Else;

  anon14_Else:
    goto anon15_Then, anon15_Else;

  anon15_Else:
    goto anon15_Else0, CallToYieldProc;

  anon8:
    goto anon80, CallToYieldProc;

  anon15_Then:
    // <<< injected gate
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    // injected gate >>>
    call uid := AtomicAllocTid_30(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert tid != uid;
    assert ValidTid(tid);
    assert ValidTid(uid);
    goto anon15_Then9, CallToYieldProc;

  anon14_Then:
    // <<< injected gate
    assert ValidTid(tid);
    // injected gate >>>
    call l := AtomicChooseLockToRelease_30(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then5, CallToYieldProc;

  anon13_Then:
    // <<< injected gate
    assert ValidTid(tid);
    // injected gate >>>
    call l := AtomicChooseLockToAcquire_30(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon13_Then5, CallToYieldProc;

  anon12_Then:
    havoc x;
    // <<< injected gate
    assert ValidTid(tid);
    assert tid != nil && tid >= 0 && tid >= 0;
    // injected gate >>>
    call ok := AtomicRead_30(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon11_Then:
    havoc x;
    // <<< injected gate
    assert ValidTid(tid);
    // injected gate >>>
    call ok := AtomicWrite_30(tid, x);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon10_LoopDone:
    assume {:partition} !ok;
    goto anon9;

  anon9:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon91, CallToYieldProc;

  anon09:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    og_pc_anon10_LoopHead, og_ok_anon10_LoopHead := og_pc, og_ok;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    goto anon10_LoopHead;

  anon00:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    ok := true;
    goto anon09, CallToYieldProc;

  anon15_Else46:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon15_Else30:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    // injected gate >>>
    call AtomicReleaseJoinLock_30(tid, uid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else46, CallToYieldProc;

  anon15_Else13:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert tid != uid;
    // injected gate >>>
    call AtomicJoin_30(tid, uid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else30, CallToYieldProc;

  anon15_Else0:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert thread.State[tid] == RUNNING() && ValidTid(tid);
    // injected gate >>>
    call uid := AtomicChooseThreadToJoin_30(tid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Else13, CallToYieldProc;

  anon88:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    goto anon10_LoopHead;

  anon80:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon88, CallToYieldProc;

  anon15_Then45:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon15_Then28:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert tid != uid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert thread.State[uid] == NEW();
    // injected gate >>>
    call AtomicStartThread_30(tid, uid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then45, CallToYieldProc;

  anon15_Then9:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assert ValidTid(tid);
    assert ValidTid(uid);
    // <<< injected gate
    assert ValidTid(tid);
    assert ValidTid(uid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableTid(uid)] == tid;
    assert tid != uid;
    // injected gate >>>
    call AtomicFork_30(tid, uid);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon15_Then28, CallToYieldProc;

  anon14_Then34:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon14_Then20:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableLock(l)] == tid;
    // injected gate >>>
    call AtomicReleaseChosenLock_30(tid, l);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then34, CallToYieldProc;

  anon14_Then5:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert ValidTid(tid);
    assert shadow.Lock[ShadowableTid(tid)] == tid;
    assert shadow.Lock[ShadowableLock(l)] == tid;
    // injected gate >>>
    call AtomicRelease_30(tid, l);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon14_Then20, CallToYieldProc;

  anon13_Then5:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    call Yield30_30(tid);
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    // <<< injected gate
    assert {:layer 10, 20} ValidTid(tid);
    assert {:layer 10, 20} shadow.Lock[ShadowableLock(l)] == tid;
    assert {:layer 10, 20} shadow.Lock[ShadowableTid(tid)] == tid;
    // injected gate >>>
    call AtomicAcquire_30(tid, l);
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon8;

  anon99:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_ok;
    return;

  anon91:
    assert og_pc
       || 
      pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
       || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    assert og_pc
       ==> pendingAsyncMultiset == og_global_old_pendingAsyncMultiset
         && (ok <==> og_old_ok);
    og_pc, og_ok := pendingAsyncMultiset == og_global_old_pendingAsyncMultiset ==> og_pc, og_ok || pendingAsyncMultiset == og_global_old_pendingAsyncMultiset;
    havoc shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset;
    assume true;
    linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset, og_old_ok := linear_tid_MapOr(TidCollector(tid), linear_tid_MapConstBool(false)), shadow.VC, shadow.Lock, sx.W, sx.R, thread.State, thread.ForkedBy, thread.HasJoined, pendingAsyncMultiset, ok;
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_hole, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    goto anon99, CallToYieldProc;

  CallToYieldProc:
    call og_yield_30(linear_tid_available, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    assume false;
    return;
}



procedure {:inline 1} Impl_YieldChecker_Yield30_30(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



procedure {:inline 1} Impl_YieldChecker_Driver_30(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



implementation {:inline 1} Impl_YieldChecker_Yield30_30(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var tid: Tid;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume ValidTid(tid);
    assume LocksPreserved(tid, og_local_old_shadow.Lock, og_global_old_shadow.Lock);
    assume og_global_old_thread.State[tid] == RUNNING();
    assume (forall t: Tid :: 
      og_local_old_shadow.Lock[ShadowableTid(t)] == tid
         ==> og_global_old_thread.State[t] == og_local_old_thread.State[t]);
    assume (forall t: Tid :: 
      og_global_old_thread.State[t] == UNUSED()
         ==> og_global_old_shadow.Lock[ShadowableTid(t)] == nil);
    assert ValidTid(tid);
    assert LocksPreserved(tid, og_local_old_shadow.Lock, shadow.Lock);
    assert thread.State[tid] == RUNNING();
    assert (forall t: Tid :: 
      og_local_old_shadow.Lock[ShadowableTid(t)] == tid
         ==> thread.State[t] == og_local_old_thread.State[t]);
    assert (forall t: Tid :: 
      thread.State[t] == UNUSED() ==> shadow.Lock[ShadowableTid(t)] == nil);
    assume false;
    return;
}



implementation {:inline 1} Impl_YieldChecker_Driver_30(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{
  var x: Var;
  var l: Lock;
  var uid: Tid;
  var tid: Tid;
  var ok: bool;
  var og_local_old_shadow.VC: [Shadowable]VC;
  var og_local_old_shadow.Lock: [Shadowable]Tid;
  var og_local_old_sx.W: [Var]Epoch;
  var og_local_old_sx.R: [Var]Epoch;
  var og_local_old_thread.State: [Tid]ThreadStatus;
  var og_local_old_thread.ForkedBy: [Tid]Tid;
  var og_local_old_thread.HasJoined: [Tid,Tid]bool;
  var og_local_old_pendingAsyncMultiset: [PendingAsync]int;

  enter:
    goto exit, L0;

  exit:
    return;

  L0:
    assume (exists partition_tid: [Tid]int :: 
      linear_tid_MapImp(linear_tid_in, linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(0)))
           == linear_tid_MapConstBool(true)
         && linear_tid_MapImp(TidCollector(tid), linear_tid_MapEq(partition_tid, linear_tid_MapConstInt(1)))
           == linear_tid_MapConstBool(true));
    assume false;
    return;
}



procedure {:inline 1} og_yield_30(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int);



implementation {:inline 1} og_yield_30(linear_tid_in: [Tid]bool, 
    og_global_old_shadow.VC: [Shadowable]VC, 
    og_global_old_shadow.Lock: [Shadowable]Tid, 
    og_global_old_sx.W: [Var]Epoch, 
    og_global_old_sx.R: [Var]Epoch, 
    og_global_old_thread.State: [Tid]ThreadStatus, 
    og_global_old_thread.ForkedBy: [Tid]Tid, 
    og_global_old_thread.HasJoined: [Tid,Tid]bool, 
    og_global_old_pendingAsyncMultiset: [PendingAsync]int)
{

  enter:
    goto L_0, L_1;

  L_0:
    call Impl_YieldChecker_Yield30_30(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;

  L_1:
    call Impl_YieldChecker_Driver_30(linear_tid_in, og_global_old_shadow.VC, og_global_old_shadow.Lock, og_global_old_sx.W, og_global_old_sx.R, og_global_old_thread.State, og_global_old_thread.ForkedBy, og_global_old_thread.HasJoined, og_global_old_pendingAsyncMultiset);
    return;
}


