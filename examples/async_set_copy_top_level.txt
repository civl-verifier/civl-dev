var copy_thread: Tid;
var is_running: [Tid]bool;
var latest: Set<int>;
var copy: Set<int>;
var requested_copy_bound: int;
var copy_bound: int;
var N: int;

Precondition of Main: 
    N == 0 &&
    !is_running[copy_thread] && 
    latest = {} &&
    copy = {} && 
    requested_copy_bound == 0 && 
    copy_bound == 0

Postcondition of Main:
    copy_bound == requested_copy_bound &&
    copy == {n : int :: n in latest && n <= requested_copy_bound}

action Main() {
    async Write(N+1);
    if (*) {
        requested_copy_bound := N;
        if (!is_running[copy_thread]) {
            havoc copy_thread; 
            assume is_running[copy_thread];
            async Copy();
        }
    }
    N := N + 1;
    if (*) {
        async Main();
    }
}

action Write(n: int) {
    assume n <= N;
    assume !is_running[copy_thread] || n <= requested_copy_bound;
    if (n <= copy_bound) {
        copy += n;
    }
    latest += n;
}

action Copy() {
    assume is_running[copy_thread] && copy_bound <= requested_copy_bound;
    copy := latest;
    copy_bound := requested_copy_bound;
    is_running[copy_thread] := false;
}

action Main'() {
    assert Inv;
    havoc globals;
    assume Inv;
    assume !is_running[copy_thread];
}

action InvMain() {
    assert Inv;
    havoc globals;
    assume Inv;
    while (*) {
        async Write(*);
    }
    if (*) {
        async Main();
    }
    do 
    if (is_running[copy_thread]) {
        async Copy();
    }
    while (*)
}

action Main*() {
    assert Inv;
    havoc globals;
    assume Inv;
    if (*) {
        async Write(*);
    }
    if (*) {
        async Main();
    }
    if (is_running[copy_thread]) {
        async Copy();
    }
}

action Write*(n: int) {
    assert Inv;
    havoc globals;
    assume Inv;
    if (is_running[copy_thread]) {
        async Copy();
    }
}

action Copy*() {
    assert Inv;
    havoc globals;
    assume Inv;
    if (is_running[copy_thread]) {
        async Copy();
    }
}

Inductive invariant Inv:
copy \subseteq latest \subseteq [1..N]
copy_bound <= requested_copy_bound <= N
is_running[copy_thread] ==> latest \subseteq [1..requested_copy_bound]
!is_running[copy_thread] ==> copy = latest \cap [1..requested_copy_bound] && copy_bound == requested_copy_bound
