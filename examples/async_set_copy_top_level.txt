var copy_thread: Tid;
var is_running: [Tid]bool;
var latest: Set<int>;
var copy: Set<int>;
var requested_copy_bound: int;
var copy_bound: int;
var N: int;

Precondition of Main: 
    N == 0 &&
    !is_running[copy_thread] && 
    latest == {} &&
    copy == {} && 
    requested_copy_bound == 0 && 
    copy_bound == 0

Postcondition of Main:
    copy_bound == requested_copy_bound &&
    copy == {n : int :: n in latest && n <= requested_copy_bound}

procedure Main() {
    while (*) {
        call MainLoopBody();
    }
}

action MainLoopBody() {
    async Write(N+1);
    if (*) {
        requested_copy_bound := N;
        if (!is_running[copy_thread]) {
            havoc copy_thread; 
            assume is_running[copy_thread];
            async Copy(copy_thread);
        }
    }
    N := N + 1;
}

action Write(n: int) {
    assert n <= N;
    assume !is_running[copy_thread] || n <= requested_copy_bound;
    if (n <= copy_bound) {
        copy += n;
    }
    latest += n;
}

action Copy(t: Tid) {
    assert t == copy_thread && is_running[copy_thread];
    copy := latest;
    copy_bound := requested_copy_bound;
    is_running[copy_thread] := false;
}

/// Abstraction

Inductive invariant Inv:
    copy ⊆ latest ⊆ [1..N]
    copy_bound <= requested_copy_bound <= N
    is_running[copy_thread] ==> latest ⊆ [1..requested_copy_bound]
    !is_running[copy_thread] ==>
        copy == latest ∩ [1..requested_copy_bound] &&
        copy_bound == requested_copy_bound

action MainLoopBodyAbs_() {
    assert Inv;
    havoc globals;
    assume Inv;
    async Write(*);
    if (!old(is_running[copy_thread]) && is_running[copy_thread]) {
        async Copy(*);
    }
}

action WriteAbs_(n: int) {
    assert Inv;
    havoc globals;
    assume Inv;
}

action CopyAbs(t: Tid) {
    assert Inv;
    havoc globals;
    assume Inv;
}

action MainLoopBodyAbs() {
    assert Inv;
    havoc globals;
    assume Inv;
    async Write(*);
    if (!old(is_running[copy_thread]) && is_running[copy_thread]) {
        async Copy(*);
    }
}

action WriteAbs(n: int) {
    assert Inv;
    havoc globals;
    assume Inv;
    if (!old(is_running[copy_thread]) && is_running[copy_thread]) {
        async Copy(*);
    }
}

action CopyAbs(t: Tid) {
    assert Inv;
    havoc globals;
    assume Inv;
    if (!old(is_running[copy_thread]) && is_running[copy_thread]) {
        async Copy(*);
    }
}

/// Inlining using inductive sequentialization
action MainLoopBody'() {
    assert Inv;
    havoc globals;
    assume Inv;
    assume old(is_running[copy_thread]) || !is_running[copy_thread];
}

action InvMainLoopBody() {
    assert Inv;
    havoc globals;
    assume Inv;
    while (*) {
        async Write(*);
    }
    if (!old(is_running[copy_thread]) && is_running[copy_thread]) {
        async Copy();
    }
}
