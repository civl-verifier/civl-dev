var copy_thread: Tid;
var is_running: [Tid]bool;
var latest: Set<int>;
var copy: Set<int>;
var requested_copy_bound: int;
var copy_bound: int;
var N: int;

Precondition of Main: 
    N == 0 &&
    !is_running[copy_thread] && 
    latest = {} &&
    copy = {} && 
    requested_copy_bound == 0 && 
    copy_bound == 0

Postcondition of Main: 
    requested_copy_bound != 0 ==>
        copy_bound == requested_copy_bound &&
        copy == {n : int :: n in latest && n <= requested_copy_bound}

action Main() {
    async Write(N+1);
    if (*) {
        requested_copy_bound := N;
        if (!is_running[copy_thread]) {
            havoc copy_thread; 
            assume is_running[copy_thread];
            async Copy();
        }
    }
    N := N + 1;
    if (*) {
        async Main();
    }
}

action Write(n: int) {
    assert n <= N;
    assume !is_running[copy_thread] || n <= requested_copy_bound;
    if (n <= copy_bound) {
        copy += n;
    }
    latest += n;
}

action Copy() {
    assert is_running[copy_thread] && copy_bound <= requested_copy_bound;
    copy := latest;
    copy_bound := requested_copy_bound;
    is_running[copy_thread] := false;
}

Inductive invariant:
copy \subseteq latest \subseteq [1..N]
copy_bound <= requested_copy_bound <= N
is_running[copy_thread] ==> latest \subseteq [1..requested_copy_bound]
!is_running[copy_thread] ==> copy = latest \cap [1..requested_copy_bound] && copy_bound == requested_copy_bound
